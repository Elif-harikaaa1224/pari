import JSBI from 'jsbi';
export { default as JSBI } from 'jsbi';
import { BytesLike } from '@ethersproject/bytes';
import * as _ton_ton from '@ton/ton';
import { TonClient4 } from '@ton/ton';
import { Transaction, Address, Cell, Contract } from '@ton/core';
import { Listener, Provider, Filter, Log, TransactionRequest } from '@ethersproject/providers';
import * as ethers from 'ethers';
import { BigNumber, Event, EventFilter, BigNumberish, BytesLike as BytesLike$1, BaseContract, Signer, CallOverrides, Overrides, ContractTransaction, PopulatedTransaction, utils, PayableOverrides } from 'ethers';
import { FunctionFragment, Result, EventFragment, JsonFragment } from '@ethersproject/abi';
import BNJS from 'bignumber.js';
import TronWeb, { TransactionInfo } from 'tronweb';
import { Histogram, Counter } from 'prom-client';
import { Trade as Trade$2, SwapOptions, MethodParameters } from '@uniswap/v3-sdk';
import { Currency, TradeType as TradeType$1 } from '@uniswap/sdk-core';
import { Network } from 'bitcoinjs-lib';
import { Connection } from '@solana/web3.js';

type BigintIsh = JSBI | bigint | string;
type Icons = {
    large?: string;
    small?: string;
};
type TokenConstructor = {
    name?: string;
    symbol?: string;
    address: string;
    decimals: number;
    chainId: ChainId;
    isNative?: boolean;
    chainFromId?: ChainId;
    icons?: Icons;
    userToken?: boolean;
    deprecated?: boolean;
    attributes?: {
        solana?: string;
        ton?: string;
    };
};
type ChainConstructor = {
    id: ChainId;
    name: string;
    explorer: string;
    disabled: boolean;
    icons: Icons;
    swappable?: boolean;
    evm?: boolean;
};
declare enum ChainId {
    ETH_MAINNET = 1,
    ETH_RINKEBY = 4,
    ETH_KOVAN = 42,
    BSC_MAINNET = 56,
    BSC_TESTNET = 97,
    MATIC_MAINNET = 137,
    MATIC_MUMBAI = 80001,
    AVAX_MAINNET = 43114,
    AVAX_TESTNET = 43113,
    HECO_MAINNET = 128,
    HECO_TESTNET = 256,
    OKEX_MAINNET = 66,
    OKEX_TESTNET = 65,
    BOBA_MAINNET = 288,
    SYMBIOSIS_TESTNET = 719095483,
    SYMBIOSIS_MAINNET = 13863860,
    BOBA_AVALANCHE = 43288,
    BOBA_RINKEBY = 28,
    MILKOMEDA_MAINNET = 2001,
    MILKOMEDA_DEVNET = 200101,
    BTC_MAINNET = 3652501241,
    BTC_MUTINY = 2782866891,
    BTC_TESTNET4 = 675223068,
    AURORA_MAINNET = 1313161554,
    AURORA_TESTNET = 1313161555,
    TELOS_MAINNET = 40,
    TELOS_TESTNET = 41,
    SHARDEUM_TESTNET_2 = 8081,
    KAVA_MAINNET = 2222,
    SCROLL_SEPOLIA = 534351,
    SEPOLIA_TESTNET = 11155111,
    ZKSYNC_MAINNET = 324,
    ARBITRUM_MAINNET = 42161,
    ARBITRUM_NOVA = 42170,
    OPTIMISM_MAINNET = 10,
    ZETACHAIN_ATHENS_2 = 7001,
    POLYGON_ZK = 1101,
    TRON_MAINNET = 728126428,
    TRON_TESTNET = 2494104990,
    LINEA_TESTNET = 59140,
    LINEA_MAINNET = 59144,
    MANTLE_MAINNET = 5000,
    MANTLE_TESTNET = 5001,
    BASE_MAINNET = 8453,
    SCROLL_MAINNET = 534352,
    MANTA_MAINNET = 169,
    METIS_MAINNET = 1088,
    OKX_X1_TESTNET = 195,
    BAHAMUT_MAINNET = 5165,
    MODE_MAINNET = 34443,
    RSK_MAINNET = 30,
    BLAST_MAINNET = 81457,
    MERLIN_MAINNET = 4200,
    ZKLINK_MAINNET = 810180,
    CORE_MAINNET = 1116,
    TON_MAINNET = 85918,// correct is 85918
    TON_TESTNET = 85919,// correct is 85918
    TAIKO_MAINNET = 167000,
    SEI_EVM_MAINNET = 1329,
    ZETACHAIN_MAINNET = 7000,
    CRONOS_MAINNET = 25,
    FRAXTAL_MAINNET = 252,
    GRAVITY_MAINNET = 1625,
    BSQUARED_MAINNET = 223,
    CRONOS_ZK_MAINNET = 388,
    MORPH_MAINNET = 2818,
    SOLANA_MAINNET = 5426,
    GOAT_MAINNET = 2345,
    SONIC_MAINNET = 146,
    ABSTRACT_MAINNET = 2741,
    GNOSIS_MAINNET = 100,
    BERACHAIN_MAINNET = 80094,
    UNICHAIN_MAINNET = 130,
    SONEIUM_MAINNET = 1868,
    OPBNB_MAINNET = 204,
    HYPERLIQUID_MAINNET = 999,
    KATANA_MAINNET = 747474,
    APECHAIN_MAINNET = 33139,
    PLASMA_MAINNET = 9745
}
declare enum TradeType {
    EXACT_INPUT = 0,
    EXACT_OUTPUT = 1
}
declare enum Rounding {
    ROUND_DOWN = 0,
    ROUND_HALF_UP = 1,
    ROUND_UP = 2
}
declare const FACTORY_ADDRESS: {
    1: string;
    4: string;
    42: string;
    56: string;
    97: string;
    137: string;
    80001: string;
    43114: string;
    43113: string;
    128: string;
    256: string;
    66: string;
    65: string;
    288: string;
    43288: string;
    719095483: string;
    13863860: string;
    28: string;
    2001: string;
    200101: string;
    3652501241: string;
    2782866891: string;
    675223068: string;
    1313161554: string;
    1313161555: string;
    40: string;
    41: string;
    8081: string;
    2222: string;
    534351: string;
    324: string;
    42161: string;
    42170: string;
    10: string;
    7001: string;
    1101: string;
    728126428: string;
    2494104990: string;
    59140: string;
    59144: string;
    5000: string;
    5001: string;
    8453: string;
    534352: string;
    169: string;
    1088: string;
    195: string;
    5165: string;
    34443: string;
    30: string;
    81457: string;
    4200: string;
    810180: string;
    11155111: string;
    1116: string;
    85918: string;
    85919: string;
    167000: string;
    1329: string;
    7000: string;
    25: string;
    252: string;
    1625: string;
    223: string;
    388: string;
    2818: string;
    5426: string;
    2345: string;
    146: string;
    2741: string;
    100: string;
    80094: string;
    130: string;
    1868: string;
    204: string;
    999: string;
    747474: string;
    33139: string;
    9745: string;
};
declare const INIT_CODE_HASH: {
    1: string;
    4: string;
    42: string;
    56: string;
    97: string;
    137: string;
    80001: string;
    43114: string;
    43113: string;
    128: string;
    256: string;
    66: string;
    65: string;
    288: string;
    43288: string;
    719095483: string;
    13863860: string;
    28: string;
    2001: string;
    200101: string;
    3652501241: string;
    2782866891: string;
    675223068: string;
    1313161554: string;
    1313161555: string;
    40: string;
    41: string;
    8081: string;
    2222: string;
    534351: string;
    324: string;
    42161: string;
    42170: string;
    10: string;
    7001: string;
    1101: string;
    59140: string;
    59144: string;
    5000: string;
    5001: string;
    8453: string;
    728126428: string;
    2494104990: string;
    534352: string;
    169: string;
    1088: string;
    195: string;
    5165: string;
    34443: string;
    30: string;
    81457: string;
    4200: string;
    810180: string;
    11155111: string;
    1116: string;
    85918: string;
    85919: string;
    167000: string;
    1329: string;
    7000: string;
    25: string;
    252: string;
    1625: string;
    223: string;
    388: string;
    2818: string;
    5426: string;
    2345: string;
    146: string;
    2741: string;
    100: string;
    80094: string;
    130: string;
    1868: string;
    204: string;
    999: string;
    747474: string;
    33139: string;
    9745: string;
};
declare const MINIMUM_LIQUIDITY: JSBI;
declare const ZERO: JSBI;

/**
 * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be
 * obtained by sending any amount of input.
 */
declare class InsufficientReservesError extends Error {
    readonly isInsufficientReservesError = true;
    constructor();
}
/**
 * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less
 * than the price of a single unit of output after fees.
 */
declare class InsufficientInputAmountError extends Error {
    readonly isInsufficientInputAmountError = true;
    constructor();
}

declare class Chain {
    readonly id: ChainId;
    readonly name: string;
    readonly disabled: boolean;
    readonly swappable: boolean;
    readonly evm: boolean;
    readonly explorer: string;
    readonly icons: Icons;
    constructor(params: ChainConstructor);
}
declare const chains: Chain[];
declare const getChainById: (chainId: ChainId | undefined) => Chain | undefined;

declare class Fraction {
    readonly numerator: JSBI;
    readonly denominator: JSBI;
    constructor(numerator: BigintIsh, denominator?: BigintIsh);
    get quotient(): JSBI;
    get remainder(): Fraction;
    invert(): Fraction;
    add(other: Fraction | BigintIsh): Fraction;
    subtract(other: Fraction | BigintIsh): Fraction;
    lessThan(other: Fraction | BigintIsh): boolean;
    equalTo(other: Fraction | BigintIsh): boolean;
    greaterThan(other: Fraction | BigintIsh): boolean;
    multiply(other: Fraction | BigintIsh): Fraction;
    divide(other: Fraction | BigintIsh): Fraction;
    toSignificant(significantDigits: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces: number, format?: object, rounding?: Rounding): string;
    toExact(decimalPlaces: number, format?: object): string;
}

declare class Percent extends Fraction {
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
}

declare class TokenAmount extends Fraction {
    readonly token: Token;
    constructor(token: Token, amount: BigintIsh);
    get raw(): JSBI;
    add(other: TokenAmount): TokenAmount;
    subtract(other: TokenAmount): TokenAmount;
    greaterThanOrEqual(amount: JSBI): boolean;
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
    toExact(decimalPlaces?: number, format?: object): string;
    toBigInt(): bigint;
}

/**
 * A token is any fungible financial instrument on Ethereum.
 *
 */
declare class Token {
    readonly decimals: number;
    readonly symbol?: string;
    readonly name?: string;
    readonly chainId: ChainId;
    readonly address: string;
    readonly icons?: Icons;
    readonly chainFromId?: ChainId;
    readonly isNative: boolean;
    readonly userToken?: boolean;
    readonly deprecated: boolean;
    readonly attributes?: {
        solana?: string;
        ton?: string;
    };
    /**
     * Constructs an instance of the base class `Token`.
     * @param params TokenConstructor
     */
    constructor(params: TokenConstructor);
    /**
     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
     * @param other other token to compare
     */
    equals(other: Token): boolean;
    /**
     * Returns true if the address of this token sorts before the address of the other token
     * @param other other token to compare
     * @throws if the tokens have the same address
     * @throws if the tokens are on different chains
     */
    sortsBefore(other: Token): boolean;
    get isSynthetic(): boolean;
    get chain(): Chain | undefined;
    get chainFrom(): Chain | undefined;
    get tonAddress(): string;
    get solAddress(): string;
}
/**
 * Compares two currencies for equality
 */
declare function tokenEquals(tokenA: Token, tokenB: Token): boolean;
declare const WETH: {
    85918: Token;
    85919: Token;
    3652501241: Token;
    2782866891: Token;
    675223068: Token;
    5426: Token;
    728126428: Token;
    1: Token;
    4: Token;
    42: Token;
    56: Token;
    97: Token;
    137: Token;
    80001: Token;
    43114: Token;
    43113: Token;
    128: Token;
    256: Token;
    66: Token;
    65: Token;
    288: Token;
    43288: Token;
    719095483: Token;
    13863860: Token;
    28: Token;
    2001: Token;
    200101: Token;
    1313161554: Token;
    1313161555: Token;
    40: Token;
    41: Token;
    8081: Token;
    2222: Token;
    534351: Token;
    324: Token;
    42161: Token;
    42170: Token;
    10: Token;
    7001: Token;
    1101: Token;
    2494104990: Token;
    59140: Token;
    59144: Token;
    5000: Token;
    5001: Token;
    8453: Token;
    534352: Token;
    169: Token;
    1088: Token;
    195: Token;
    5165: Token;
    34443: Token;
    30: Token;
    81457: Token;
    4200: Token;
    810180: Token;
    11155111: Token;
    1116: Token;
    167000: Token;
    1329: Token;
    7000: Token;
    25: Token;
    252: Token;
    1625: Token;
    223: Token;
    388: Token;
    2818: Token;
    2345: Token;
    146: Token;
    2741: Token;
    100: Token;
    80094: Token;
    130: Token;
    1868: Token;
    204: Token;
    999: Token;
    747474: Token;
    33139: Token;
    9745: Token;
};

declare let PAIR_ADDRESS_CACHE: {
    [token0Address: string]: {
        [token1Address: string]: string;
    };
};
declare function getZkCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string;
declare class Pair {
    readonly liquidityToken: Token;
    private readonly tokenAmounts;
    static getAddress(tokenA: Token, tokenB: Token): string;
    constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount);
    /**
     * Returns true if the token is either token0 or token1
     * @param token to check
     */
    involvesToken(token: Token): boolean;
    /**
     * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0
     */
    get token0Price(): Price;
    /**
     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1
     */
    get token1Price(): Price;
    /**
     * Return the price of the given token in terms of the other token in the pair.
     * @param token token to return price of
     */
    priceOf(token: Token): Price;
    /**
     * Returns the chain ID of the tokens in the pair.
     */
    get chainId(): ChainId;
    get token0(): Token;
    get token1(): Token;
    get reserve0(): TokenAmount;
    get reserve1(): TokenAmount;
    reserveOf(token: Token): TokenAmount;
    getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair];
    getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair];
    getLiquidityMinted(totalSupply: TokenAmount, tokenAmountA: TokenAmount, tokenAmountB: TokenAmount): TokenAmount;
    getLiquidityValue(token: Token, totalSupply: TokenAmount, liquidity: TokenAmount, feeOn?: boolean, kLast?: BigintIsh): TokenAmount;
}

declare class Route$1 {
    readonly pairs: Pair[];
    readonly path: Token[];
    readonly input: Token;
    readonly output: Token;
    readonly midPrice: Price;
    constructor(pairs: Pair[], input: Token, output?: Token);
    get chainId(): ChainId;
}

declare class Price extends Fraction {
    readonly baseToken: Token;
    readonly quoteToken: Token;
    readonly scalar: Fraction;
    static fromRoute(route: Route$1): Price;
    constructor(baseToken: Token, quoteToken: Token, denominator: BigintIsh, numerator: BigintIsh);
    get raw(): Fraction;
    get adjusted(): Fraction;
    invert(): Price;
    multiply(other: Price): Price;
    quote(tokenAmount: TokenAmount): TokenAmount;
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
}

declare const GAS_TOKEN: Record<ChainId, Token>;

interface InputOutput {
    readonly inputAmount: TokenAmount;
    readonly outputAmount: TokenAmount;
}
declare function inputOutputComparator(a: InputOutput, b: InputOutput): number;
declare function tradeComparator(a: Trade$1, b: Trade$1): number;
interface BestTradeOptions {
    maxNumResults?: number;
    maxHops?: number;
}
/**
 * Given a token amount and a chain ID, returns the equivalent representation as the token amount.
 */
declare function wrappedAmount(tokenAmount: TokenAmount): TokenAmount;
declare function wrappedToken(token: Token): Token;
/**
 * Represents a trade executed against a list of pairs.
 * Does not account for slippage, i.e. trades that front run this trade and move the price.
 */
declare class Trade$1 {
    /**
     * The route of the trade, i.e. which pairs the trade goes through.
     */
    readonly route: Route$1;
    /**
     * The type of the trade, either exact in or exact out.
     */
    readonly tradeType: TradeType;
    /**
     * The input amount for the trade assuming no slippage.
     */
    readonly inputAmount: TokenAmount;
    /**
     * The output amount for the trade assuming no slippage.
     */
    readonly outputAmount: TokenAmount;
    /**
     * The price expressed in terms of output amount/input amount.
     */
    readonly executionPrice: Price;
    /**
     * The mid price after the trade executes assuming no slippage.
     */
    readonly nextMidPrice: Price;
    /**
     * The percent difference between the mid price before the trade and the trade execution price.
     */
    readonly priceImpact: Percent;
    /**
     * Constructs an exact in trade with the given amount in and route
     * @param route route of the exact in trade
     * @param amountIn the amount being passed in
     */
    static exactIn(route: Route$1, amountIn: TokenAmount): Trade$1;
    /**
     * Constructs an exact out trade with the given amount out and route
     * @param route route of the exact out trade
     * @param amountOut the amount returned by the trade
     */
    static exactOut(route: Route$1, amountOut: TokenAmount): Trade$1;
    constructor(route: Route$1, amount: TokenAmount, tradeType: TradeType);
    /**
     * Get the minimum amount that must be received from this trade for the given slippage tolerance
     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade
     */
    minimumAmountOut(slippageTolerance: Percent): TokenAmount;
    /**
     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade
     */
    maximumAmountIn(slippageTolerance: Percent): TokenAmount;
    /**
     * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
     * amount to an output token, making at most `maxHops` hops.
     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
     * the amount in among multiple routes.
     * @param pairs the pairs to consider in finding the best trade
     * @param tokenAmountIn exact amount of input token to spend
     * @param tokenOut the desired token out
     * @param maxNumResults maximum number of results to return
     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair
     * @param currentPairs used in recursion; the current list of pairs
     * @param originalAmountIn used in recursion; the original value of the tokenAmountIn parameter
     * @param bestTrades used in recursion; the current list of best trades
     */
    static bestTradeExactIn(pairs: Pair[], tokenAmountIn: TokenAmount, tokenOut: Token, { maxNumResults, maxHops }?: BestTradeOptions, currentPairs?: Pair[], originalAmountIn?: TokenAmount, bestTrades?: Trade$1[]): Trade$1[];
    /**
     * similar to the above method but instead targets a fixed output amount
     * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
     * to an output token amount, making at most `maxHops` hops
     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
     * the amount in among multiple routes.
     * @param pairs the pairs to consider in finding the best trade
     * @param tokenIn the token to spend
     * @param tokenAmountOut the exact amount of token out
     * @param maxNumResults maximum number of results to return
     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair
     * @param currentPairs used in recursion; the current list of pairs
     * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter
     * @param bestTrades used in recursion; the current list of best trades
     */
    static bestTradeExactOut(pairs: Pair[], tokenIn: Token, tokenAmountOut: TokenAmount, { maxNumResults, maxHops }?: BestTradeOptions, currentPairs?: Pair[], originalAmountOut?: TokenAmount, bestTrades?: Trade$1[]): Trade$1[];
}

interface ProfilerItem {
    name: string;
    start: number;
    stop: number;
    duration?: number;
}
declare class Profiler {
    private start;
    private stop;
    private list;
    constructor();
    tick(name: string): void;
    toString(): ProfilerItem[];
}

/**
 * Options for producing the arguments to send call to the router.
 */
interface TradeOptions {
    /**
     * How much the execution price is allowed to move unfavorably from the trade execution price.
     */
    allowedSlippage: Percent;
    /**
     * How long the swap is valid until it expires, in seconds.
     * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters
     * are generated.
     */
    ttl: number;
    /**
     * The account that should receive the output of the swap.
     */
    recipient: string;
    /**
     * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods
     */
    feeOnTransfer?: boolean;
}
type Route = {
    from: string;
    to: string;
    stable: boolean;
};
/**
 * The parameters to use in the call to the Uniswap V2 Router to execute a trade.
 */
interface SwapParameters {
    /**
     * The method to call on the Uniswap V2 Router.
     */
    methodName: string;
    /**
     * The arguments to pass to the method, all hex encoded.
     */
    args: (string | string[] | Route[])[];
    /**
     * The amount of wei to send in hex.
     */
    value: string;
    /**
     * The offset of amount.
     */
    offset: number;
    minReceivedOffset: number;
}
/**
 * Represents the Uniswap V2 Router, and has static methods for helping execute trades.
 */
declare abstract class Router {
    /**
     * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.
     * @param trade to produce call parameters for
     * @param options options for the call parameters
     */
    static swapCallParameters(trade: Trade$1, options: TradeOptions): SwapParameters;
}

interface WaitForCompleteParams {
    symbiosis: Symbiosis;
    chainId: ChainId;
    txId: string;
    txTon?: Transaction;
}
/**
 * @param symbiosis - context class
 * @param chainId - chain evm id to check event
 * @param txId - transaction hash to check
 * @param txTon - optional, TON tx on bridge
 * @returns Transaction hash from portal contract in bitcoin network to user's wallet
 */
declare function waitForComplete({ symbiosis, chainId, txId, txTon }: WaitForCompleteParams): Promise<string>;

type SymbiosisTradeType = 'uni-v2' | 'uni-v3' | '1inch' | 'open-ocean' | 'wrap' | 'izumi' | 'octopool' | 'symbiosis' | 'thorchain-bridge' | 'chainflip-bridge' | 'raydium' | 'stonfi' | 'dedust' | 'jupiter' | 'depository';
type SymbiosisKind = 'onchain-swap' | 'crosschain-swap' | 'wrap' | 'unwrap' | 'bridge' | 'from-btc-swap';
interface SymbiosisTradeParams {
    tokenAmountIn: TokenAmount;
    tokenAmountInMin: TokenAmount;
    tokenOut: Token;
    to: string;
    slippage: number;
}
interface SymbiosisTradeOutResult {
    amountOut: TokenAmount;
    amountOutMin: TokenAmount;
    routerAddress: string;
    route: Token[];
    priceImpact: Percent;
    callData: string;
    callDataOffset: number;
    minReceivedOffset: number;
    minReceivedOffset2?: number;
    functionSelector?: string;
    instructions?: string;
    fees?: FeeItem[];
    value?: bigint;
}
declare abstract class SymbiosisTrade {
    tokenAmountIn: TokenAmount;
    tokenAmountInMin: TokenAmount;
    tokenOut: Token;
    to: string;
    slippage: number;
    protected out?: SymbiosisTradeOutResult;
    protected constructor({ tokenAmountIn, tokenAmountInMin, tokenOut, to, slippage }: SymbiosisTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    get amountOut(): TokenAmount;
    get amountOutMin(): TokenAmount;
    get routerAddress(): string;
    get value(): bigint | undefined;
    get route(): Token[];
    get callData(): string;
    get callDataOffset(): number;
    get minReceivedOffset(): number;
    get minReceivedOffset2(): number;
    get priceImpact(): Percent;
    get functionSelector(): string | undefined;
    get instructions(): string | undefined;
    get fees(): FeeItem[] | undefined;
    applyAmountIn(newAmountIn: TokenAmount, newAmountInMin: TokenAmount): void;
    private assertOutInitialized;
    static getAmountFromCallData(data: string, bytesOffset: number): BigNumber;
    static patchCallData(data: string, bytesOffset: number, amount: BigNumber): string;
}

type OneInchProtocols = string[];
interface OneInchTradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    from: string;
    protocols?: OneInchProtocols;
}
declare class OneInchTrade extends SymbiosisTrade {
    private readonly symbiosis;
    private readonly from;
    private readonly protocols;
    static isAvailable(chainId: ChainId): boolean;
    constructor(params: OneInchTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    private static request;
    static getProtocols(symbiosis: Symbiosis, chainId: ChainId): Promise<OneInchProtocols>;
    private getOffsets;
    private getTradePriceImpact;
}

interface OpenOceanTradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
}
declare class OpenOceanTrade extends SymbiosisTrade {
    private readonly chain;
    private readonly endpoint;
    private readonly symbiosis;
    static isAvailable(chainId: ChainId): boolean;
    constructor(params: OpenOceanTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    private getOffsets;
    private convertPriceImpact;
    private getGasPrice;
}

interface IzumiRoute {
    tokens: Token[];
    fees: number[];
    path: string;
}
interface IzumiTradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    deadline: number;
}
declare class IzumiTrade extends SymbiosisTrade {
    private readonly symbiosis;
    private readonly deadline;
    static isSupported(chainId: ChainId): boolean;
    constructor(params: IzumiTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    getCurrentPoolPoints({ fees, tokens }: IzumiRoute): Promise<any[]>;
}

interface UniV2TradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    deadline: number;
}
declare class UniV2Trade extends SymbiosisTrade {
    private router;
    private readonly symbiosis;
    private readonly deadline;
    static isSupported(symbiosis: Symbiosis, chainId: ChainId): boolean;
    constructor(params: UniV2TradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    private buildCallData;
    private static getPairs;
    private static allPairs;
    private uniV2Router;
    private avaxRouter;
    private adaRouter;
    private kavaRouter;
    private kimRouter;
    private hyperSwapRouter;
    private dragonSwapRouter;
    private getRouterConfig;
}

interface UniV3TradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    deadline: number;
}
declare class UniV3Trade extends SymbiosisTrade {
    private readonly symbiosis;
    private readonly deadline;
    static isSupported(chainId: ChainId): boolean;
    constructor(params: UniV3TradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    private static getOffsets;
    static swapCallParameters(trades: Trade$2<Currency, Currency, TradeType$1> | Trade$2<Currency, Currency, TradeType$1>[], options: SwapOptions, routerAddress: string): MethodParameters;
}

type Trade = OneInchTrade | OpenOceanTrade | IzumiTrade | UniV2Trade | UniV3Trade;
interface AggregatorTradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    from: string;
    clientId: string;
    deadline: number;
    preferOneInchUsage?: boolean;
    oneInchProtocols?: OneInchProtocols;
}
declare class AggregatorTrade extends SymbiosisTrade {
    private params;
    protected trade: Trade | undefined;
    protected preferOneInchUsage: boolean;
    constructor(params: AggregatorTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    private selectTheBestTrade;
    get amountOut(): TokenAmount;
    get amountOutMin(): TokenAmount;
    get routerAddress(): string;
    get route(): Token[];
    get callData(): string;
    get callDataOffset(): number;
    get minReceivedOffset(): number;
    get priceImpact(): Percent;
    get functionSelector(): string | undefined;
    applyAmountIn(newAmountIn: TokenAmount, newAmountInMin: TokenAmount): void;
    get fees(): FeeItem[] | undefined;
    private assertTradeInitialized;
}

interface OctoPoolTradeParams extends SymbiosisTradeParams {
    symbiosis: Symbiosis;
    deadline: number;
    omniPoolConfig: OmniPoolConfig;
}
declare class OctoPoolTrade extends SymbiosisTrade {
    readonly symbiosis: Symbiosis;
    readonly deadline: number;
    readonly poolConfig: OmniPoolConfig;
    constructor(params: OctoPoolTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
    quote(indexIn: number, indexOut: number, amountIn: BigNumber): Promise<BigNumber>;
}

interface WrapTradeParams {
    tokenAmountIn: TokenAmount;
    tokenAmountInMin: TokenAmount;
    tokenOut: Token;
    to: string;
}
declare class WrapTrade extends SymbiosisTrade {
    static isSupported(tokenIn: Token, tokenOut: Token): boolean;
    constructor(params: WrapTradeParams);
    get tradeType(): SymbiosisTradeType;
    init(): Promise<this>;
}

declare class Cache {
    private data;
    get<T>(key: string[], func: () => Promise<T>, ttl?: number): Promise<T>;
    private fromCache;
}

interface TypedEvent<TArgsArray extends Array<any> = any, TArgsObject = any> extends Event {
    args: TArgsArray & TArgsObject;
}
interface TypedEventFilter<_TEvent extends TypedEvent> extends EventFilter {
}
interface TypedListener<TEvent extends TypedEvent> {
    (...listenerArg: [...__TypechainArgsArray<TEvent>, TEvent]): void;
}
type __TypechainArgsArray<T> = T extends TypedEvent<infer U> ? U : never;
interface OnEvent<TRes> {
    <TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>, listener: TypedListener<TEvent>): TRes;
    (eventName: string, listener: Listener): TRes;
}

declare namespace DepositoryTypes$4 {
    type UnlockerStruct = {
        unlocker: string;
        condition: BytesLike$1;
    };
    type UnlockerStructOutput = [string, string] & {
        unlocker: string;
        condition: string;
    };
    type DepositStruct = {
        token: string;
        amount: BigNumberish;
        nonce: BigNumberish;
    };
    type DepositStructOutput = [string, BigNumber, BigNumber] & {
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
    };
}
interface BranchedUnlockerInterface extends utils.Interface {
    contractName: 'BranchedUnlocker';
    functions: {
        'decodeCondition(bytes)': FunctionFragment;
        'encodeCondition(((address,bytes)[]))': FunctionFragment;
        'encodeSolution((uint256,bytes))': FunctionFragment;
        'unlock(address,(address,uint256,uint256),bytes,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'decodeCondition', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'encodeCondition', values: [BranchedUnlocker.ConditionStruct]): string;
    encodeFunctionData(functionFragment: 'encodeSolution', values: [BranchedUnlocker.SolutionStruct]): string;
    encodeFunctionData(functionFragment: 'unlock', values: [string, DepositoryTypes$4.DepositStruct, BytesLike$1, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'decodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeSolution', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unlock', data: BytesLike$1): Result;
    events: {};
}
declare namespace BranchedUnlocker {
    type ConditionStruct = {
        unlockers: DepositoryTypes$4.UnlockerStruct[];
    };
    type ConditionStructOutput = [DepositoryTypes$4.UnlockerStructOutput[]] & {
        unlockers: DepositoryTypes$4.UnlockerStructOutput[];
    };
    type SolutionStruct = {
        index: BigNumberish;
        solution: BytesLike$1;
    };
    type SolutionStructOutput = [BigNumber, string] & {
        index: BigNumber;
        solution: string;
    };
}
interface BranchedUnlocker extends BaseContract {
    contractName: 'BranchedUnlocker';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BranchedUnlockerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<[BranchedUnlocker.ConditionStructOutput]>;
        encodeCondition(c: BranchedUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<[string]>;
        encodeSolution(s: BranchedUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<[string]>;
        unlock(metarouter: string, deposit: DepositoryTypes$4.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BranchedUnlocker.ConditionStructOutput>;
    encodeCondition(c: BranchedUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
    encodeSolution(s: BranchedUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
    unlock(metarouter: string, deposit: DepositoryTypes$4.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BranchedUnlocker.ConditionStructOutput>;
        encodeCondition(c: BranchedUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
        encodeSolution(s: BranchedUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
        unlock(metarouter: string, deposit: DepositoryTypes$4.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        encodeCondition(c: BranchedUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        encodeSolution(s: BranchedUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        unlock(metarouter: string, deposit: DepositoryTypes$4.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeCondition(c: BranchedUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeSolution(s: BranchedUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unlock(metarouter: string, deposit: DepositoryTypes$4.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface BridgeInterface extends utils.Interface {
    contractName: 'Bridge';
    functions: {
        'changeMPC(address)': FunctionFragment;
        'changeMPCSigned(address,bytes)': FunctionFragment;
        'currentChainId()': FunctionFragment;
        'initialize(address)': FunctionFragment;
        'isAdmin(address)': FunctionFragment;
        'isTransmitter(address)': FunctionFragment;
        'mpc()': FunctionFragment;
        'newMPC()': FunctionFragment;
        'newMPCEffectiveTime()': FunctionFragment;
        'oldMPC()': FunctionFragment;
        'owner()': FunctionFragment;
        'receiveRequestV2(bytes,address)': FunctionFragment;
        'receiveRequestV2Signed(bytes,address,bytes)': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'setAdminPermission(address,bool)': FunctionFragment;
        'setTransmitterStatus(address,bool)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'transmitRequestV2(bytes,address,address,uint256)': FunctionFragment;
        'withdrawFee(address,address,uint256)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'changeMPC', values: [string]): string;
    encodeFunctionData(functionFragment: 'changeMPCSigned', values: [string, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'currentChainId', values?: undefined): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
    encodeFunctionData(functionFragment: 'isAdmin', values: [string]): string;
    encodeFunctionData(functionFragment: 'isTransmitter', values: [string]): string;
    encodeFunctionData(functionFragment: 'mpc', values?: undefined): string;
    encodeFunctionData(functionFragment: 'newMPC', values?: undefined): string;
    encodeFunctionData(functionFragment: 'newMPCEffectiveTime', values?: undefined): string;
    encodeFunctionData(functionFragment: 'oldMPC', values?: undefined): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'receiveRequestV2', values: [BytesLike$1, string]): string;
    encodeFunctionData(functionFragment: 'receiveRequestV2Signed', values: [BytesLike$1, string, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'setAdminPermission', values: [string, boolean]): string;
    encodeFunctionData(functionFragment: 'setTransmitterStatus', values: [string, boolean]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'transmitRequestV2', values: [BytesLike$1, string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'withdrawFee', values: [string, string, BigNumberish]): string;
    decodeFunctionResult(functionFragment: 'changeMPC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeMPCSigned', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'currentChainId', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'isAdmin', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'isTransmitter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'mpc', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'newMPC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'newMPCEffectiveTime', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'oldMPC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'receiveRequestV2', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'receiveRequestV2Signed', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setAdminPermission', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setTransmitterStatus', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transmitRequestV2', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'withdrawFee', data: BytesLike$1): Result;
    events: {
        'LogChangeMPC(address,address,uint256,uint256)': EventFragment;
        'OracleRequest(address,bytes,address,address,uint256)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'SetAdminPermission(address,bool)': EventFragment;
        'SetTransmitterStatus(address,bool)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'LogChangeMPC'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OracleRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetAdminPermission'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetTransmitterStatus'): EventFragment;
}
type LogChangeMPCEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], {
    oldMPC: string;
    newMPC: string;
    effectiveTime: BigNumber;
    chainId: BigNumber;
}>;
type LogChangeMPCEventFilter = TypedEventFilter<LogChangeMPCEvent>;
type OracleRequestEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber
], {
    bridge: string;
    callData: string;
    receiveSide: string;
    oppositeBridge: string;
    chainId: BigNumber;
}>;
type OracleRequestEventFilter = TypedEventFilter<OracleRequestEvent>;
type OwnershipTransferredEvent$8 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$8 = TypedEventFilter<OwnershipTransferredEvent$8>;
type SetAdminPermissionEvent = TypedEvent<[string, boolean], {
    admin: string;
    permission: boolean;
}>;
type SetAdminPermissionEventFilter = TypedEventFilter<SetAdminPermissionEvent>;
type SetTransmitterStatusEvent = TypedEvent<[string, boolean], {
    transmitter: string;
    status: boolean;
}>;
type SetTransmitterStatusEventFilter = TypedEventFilter<SetTransmitterStatusEvent>;
interface Bridge$1 extends BaseContract {
    contractName: 'Bridge';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BridgeInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        changeMPC(_newMPC: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeMPCSigned(_newMPC: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        currentChainId(overrides?: CallOverrides): Promise<[BigNumber]>;
        initialize(_mpc: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isAdmin(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        isTransmitter(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        mpc(overrides?: CallOverrides): Promise<[string]>;
        newMPC(overrides?: CallOverrides): Promise<[string]>;
        newMPCEffectiveTime(overrides?: CallOverrides): Promise<[BigNumber]>;
        oldMPC(overrides?: CallOverrides): Promise<[string]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        receiveRequestV2(_callData: BytesLike$1, _receiveSide: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        receiveRequestV2Signed(_callData: BytesLike$1, _receiveSide: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setAdminPermission(_user: string, _permission: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setTransmitterStatus(_transmitter: string, _status: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transmitRequestV2(_callData: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        withdrawFee(token: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    changeMPC(_newMPC: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeMPCSigned(_newMPC: string, signature: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    currentChainId(overrides?: CallOverrides): Promise<BigNumber>;
    initialize(_mpc: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isAdmin(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    isTransmitter(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    mpc(overrides?: CallOverrides): Promise<string>;
    newMPC(overrides?: CallOverrides): Promise<string>;
    newMPCEffectiveTime(overrides?: CallOverrides): Promise<BigNumber>;
    oldMPC(overrides?: CallOverrides): Promise<string>;
    owner(overrides?: CallOverrides): Promise<string>;
    receiveRequestV2(_callData: BytesLike$1, _receiveSide: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    receiveRequestV2Signed(_callData: BytesLike$1, _receiveSide: string, signature: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setAdminPermission(_user: string, _permission: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setTransmitterStatus(_transmitter: string, _status: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transmitRequestV2(_callData: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    withdrawFee(token: string, to: string, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        changeMPC(_newMPC: string, overrides?: CallOverrides): Promise<boolean>;
        changeMPCSigned(_newMPC: string, signature: BytesLike$1, overrides?: CallOverrides): Promise<boolean>;
        currentChainId(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_mpc: string, overrides?: CallOverrides): Promise<void>;
        isAdmin(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        isTransmitter(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        mpc(overrides?: CallOverrides): Promise<string>;
        newMPC(overrides?: CallOverrides): Promise<string>;
        newMPCEffectiveTime(overrides?: CallOverrides): Promise<BigNumber>;
        oldMPC(overrides?: CallOverrides): Promise<string>;
        owner(overrides?: CallOverrides): Promise<string>;
        receiveRequestV2(_callData: BytesLike$1, _receiveSide: string, overrides?: CallOverrides): Promise<void>;
        receiveRequestV2Signed(_callData: BytesLike$1, _receiveSide: string, signature: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        setAdminPermission(_user: string, _permission: boolean, overrides?: CallOverrides): Promise<void>;
        setTransmitterStatus(_transmitter: string, _status: boolean, overrides?: CallOverrides): Promise<void>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        transmitRequestV2(_callData: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        withdrawFee(token: string, to: string, amount: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        'LogChangeMPC(address,address,uint256,uint256)'(oldMPC?: string | null, newMPC?: string | null, effectiveTime?: BigNumberish | null, chainId?: null): LogChangeMPCEventFilter;
        LogChangeMPC(oldMPC?: string | null, newMPC?: string | null, effectiveTime?: BigNumberish | null, chainId?: null): LogChangeMPCEventFilter;
        'OracleRequest(address,bytes,address,address,uint256)'(bridge?: null, callData?: null, receiveSide?: null, oppositeBridge?: null, chainId?: null): OracleRequestEventFilter;
        OracleRequest(bridge?: null, callData?: null, receiveSide?: null, oppositeBridge?: null, chainId?: null): OracleRequestEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$8;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$8;
        'SetAdminPermission(address,bool)'(admin?: string | null, permission?: null): SetAdminPermissionEventFilter;
        SetAdminPermission(admin?: string | null, permission?: null): SetAdminPermissionEventFilter;
        'SetTransmitterStatus(address,bool)'(transmitter?: string | null, status?: null): SetTransmitterStatusEventFilter;
        SetTransmitterStatus(transmitter?: string | null, status?: null): SetTransmitterStatusEventFilter;
    };
    estimateGas: {
        changeMPC(_newMPC: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeMPCSigned(_newMPC: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        currentChainId(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_mpc: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isAdmin(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        isTransmitter(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        mpc(overrides?: CallOverrides): Promise<BigNumber>;
        newMPC(overrides?: CallOverrides): Promise<BigNumber>;
        newMPCEffectiveTime(overrides?: CallOverrides): Promise<BigNumber>;
        oldMPC(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        receiveRequestV2(_callData: BytesLike$1, _receiveSide: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        receiveRequestV2Signed(_callData: BytesLike$1, _receiveSide: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setAdminPermission(_user: string, _permission: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setTransmitterStatus(_transmitter: string, _status: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transmitRequestV2(_callData: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        withdrawFee(token: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        changeMPC(_newMPC: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeMPCSigned(_newMPC: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        currentChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_mpc: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isAdmin(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isTransmitter(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mpc(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        newMPC(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        newMPCEffectiveTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        oldMPC(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        receiveRequestV2(_callData: BytesLike$1, _receiveSide: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        receiveRequestV2Signed(_callData: BytesLike$1, _receiveSide: string, signature: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setAdminPermission(_user: string, _permission: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setTransmitterStatus(_transmitter: string, _status: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transmitRequestV2(_callData: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        withdrawFee(token: string, to: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace DepositoryTypes$3 {
    type DepositStruct = {
        token: string;
        amount: BigNumberish;
        nonce: BigNumberish;
    };
    type DepositStructOutput = [string, BigNumber, BigNumber] & {
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
    };
}
interface BtcRefundUnlockerInterface extends utils.Interface {
    contractName: 'BtcRefundUnlocker';
    functions: {
        'decodeCondition(bytes)': FunctionFragment;
        'encodeCondition((bytes))': FunctionFragment;
        'encodeSolution((uint256,bytes32))': FunctionFragment;
        'synthesis()': FunctionFragment;
        'unlock(address,(address,uint256,uint256),bytes,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'decodeCondition', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'encodeCondition', values: [BtcRefundUnlocker.ConditionStruct]): string;
    encodeFunctionData(functionFragment: 'encodeSolution', values: [BtcRefundUnlocker.SolutionStruct]): string;
    encodeFunctionData(functionFragment: 'synthesis', values?: undefined): string;
    encodeFunctionData(functionFragment: 'unlock', values: [string, DepositoryTypes$3.DepositStruct, BytesLike$1, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'decodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeSolution', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesis', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unlock', data: BytesLike$1): Result;
    events: {};
}
declare namespace BtcRefundUnlocker {
    type ConditionStruct = {
        refundAddress: BytesLike$1;
    };
    type ConditionStructOutput = [string] & {
        refundAddress: string;
    };
    type SolutionStruct = {
        stableBridgingFee: BigNumberish;
        clientID: BytesLike$1;
    };
    type SolutionStructOutput = [BigNumber, string] & {
        stableBridgingFee: BigNumber;
        clientID: string;
    };
}
interface BtcRefundUnlocker extends BaseContract {
    contractName: 'BtcRefundUnlocker';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BtcRefundUnlockerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<[BtcRefundUnlocker.ConditionStructOutput]>;
        encodeCondition(c: BtcRefundUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<[string]>;
        encodeSolution(s: BtcRefundUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<[string]>;
        synthesis(overrides?: CallOverrides): Promise<[string]>;
        unlock(metarouter: string, deposit: DepositoryTypes$3.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BtcRefundUnlocker.ConditionStructOutput>;
    encodeCondition(c: BtcRefundUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
    encodeSolution(s: BtcRefundUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
    synthesis(overrides?: CallOverrides): Promise<string>;
    unlock(metarouter: string, deposit: DepositoryTypes$3.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BtcRefundUnlocker.ConditionStructOutput>;
        encodeCondition(c: BtcRefundUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
        encodeSolution(s: BtcRefundUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
        synthesis(overrides?: CallOverrides): Promise<string>;
        unlock(metarouter: string, deposit: DepositoryTypes$3.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        encodeCondition(c: BtcRefundUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        encodeSolution(s: BtcRefundUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        synthesis(overrides?: CallOverrides): Promise<BigNumber>;
        unlock(metarouter: string, deposit: DepositoryTypes$3.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeCondition(c: BtcRefundUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeSolution(s: BtcRefundUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        synthesis(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unlock(metarouter: string, deposit: DepositoryTypes$3.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace DepositoryTypes$2 {
    type DepositStruct = {
        token: string;
        amount: BigNumberish;
        nonce: BigNumberish;
    };
    type DepositStructOutput = [string, BigNumber, BigNumber] & {
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
    };
    type UnlockerStruct = {
        unlocker: string;
        condition: BytesLike$1;
    };
    type UnlockerStructOutput = [string, string] & {
        unlocker: string;
        condition: string;
    };
}
interface DepositoryInterface extends utils.Interface {
    contractName: 'Depository';
    functions: {
        'UPGRADE_INTERFACE_VERSION()': FunctionFragment;
        'depositID((address,uint256,uint256),(address,bytes))': FunctionFragment;
        'deposits(bytes32)': FunctionFragment;
        'initialize(address)': FunctionFragment;
        'lock((address,uint256,uint256),(address,bytes))': FunctionFragment;
        'metaRouter()': FunctionFragment;
        'owner()': FunctionFragment;
        'proxiableUUID()': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unlock((address,uint256,uint256),(address,bytes),bytes)': FunctionFragment;
        'upgradeToAndCall(address,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'UPGRADE_INTERFACE_VERSION', values?: undefined): string;
    encodeFunctionData(functionFragment: 'depositID', values: [DepositoryTypes$2.DepositStruct, DepositoryTypes$2.UnlockerStruct]): string;
    encodeFunctionData(functionFragment: 'deposits', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
    encodeFunctionData(functionFragment: 'lock', values: [DepositoryTypes$2.DepositStruct, DepositoryTypes$2.UnlockerStruct]): string;
    encodeFunctionData(functionFragment: 'metaRouter', values?: undefined): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'proxiableUUID', values?: undefined): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unlock', values: [DepositoryTypes$2.DepositStruct, DepositoryTypes$2.UnlockerStruct, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'upgradeToAndCall', values: [string, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'UPGRADE_INTERFACE_VERSION', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'depositID', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'deposits', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lock', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRouter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'proxiableUUID', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unlock', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'upgradeToAndCall', data: BytesLike$1): Result;
    events: {
        'DepositLocked(bytes32,tuple,tuple)': EventFragment;
        'DepositUnlocked(bytes32)': EventFragment;
        'Initialized(uint64)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'Upgraded(address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'DepositLocked'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'DepositUnlocked'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
}
type DepositLockedEvent = TypedEvent<[
    string,
    DepositoryTypes$2.DepositStructOutput,
    DepositoryTypes$2.UnlockerStructOutput
], {
    depositID: string;
    deposit: DepositoryTypes$2.DepositStructOutput;
    unlocker: DepositoryTypes$2.UnlockerStructOutput;
}>;
type DepositLockedEventFilter = TypedEventFilter<DepositLockedEvent>;
type DepositUnlockedEvent = TypedEvent<[string], {
    depositID: string;
}>;
type DepositUnlockedEventFilter = TypedEventFilter<DepositUnlockedEvent>;
type InitializedEvent$2 = TypedEvent<[BigNumber], {
    version: BigNumber;
}>;
type InitializedEventFilter$2 = TypedEventFilter<InitializedEvent$2>;
type OwnershipTransferredEvent$7 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$7 = TypedEventFilter<OwnershipTransferredEvent$7>;
type UpgradedEvent = TypedEvent<[string], {
    implementation: string;
}>;
type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;
interface Depository extends BaseContract {
    contractName: 'Depository';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: DepositoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<[string]>;
        depositID(d: DepositoryTypes$2.DepositStruct, u: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<[string]>;
        deposits(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[boolean]>;
        initialize(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        lock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<[string]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        proxiableUUID(overrides?: CallOverrides): Promise<[string]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unlock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        upgradeToAndCall(newImplementation: string, data: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<string>;
    depositID(d: DepositoryTypes$2.DepositStruct, u: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<string>;
    deposits(arg0: BytesLike$1, overrides?: CallOverrides): Promise<boolean>;
    initialize(_metaRouter: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    lock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaRouter(overrides?: CallOverrides): Promise<string>;
    owner(overrides?: CallOverrides): Promise<string>;
    proxiableUUID(overrides?: CallOverrides): Promise<string>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unlock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, solution: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    upgradeToAndCall(newImplementation: string, data: BytesLike$1, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<string>;
        depositID(d: DepositoryTypes$2.DepositStruct, u: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<string>;
        deposits(arg0: BytesLike$1, overrides?: CallOverrides): Promise<boolean>;
        initialize(_metaRouter: string, overrides?: CallOverrides): Promise<void>;
        lock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<void>;
        metaRouter(overrides?: CallOverrides): Promise<string>;
        owner(overrides?: CallOverrides): Promise<string>;
        proxiableUUID(overrides?: CallOverrides): Promise<string>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unlock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, solution: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        upgradeToAndCall(newImplementation: string, data: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'DepositLocked(bytes32,tuple,tuple)'(depositID?: BytesLike$1 | null, deposit?: null, unlocker?: null): DepositLockedEventFilter;
        DepositLocked(depositID?: BytesLike$1 | null, deposit?: null, unlocker?: null): DepositLockedEventFilter;
        'DepositUnlocked(bytes32)'(depositID?: BytesLike$1 | null): DepositUnlockedEventFilter;
        DepositUnlocked(depositID?: BytesLike$1 | null): DepositUnlockedEventFilter;
        'Initialized(uint64)'(version?: null): InitializedEventFilter$2;
        Initialized(version?: null): InitializedEventFilter$2;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$7;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$7;
        'Upgraded(address)'(implementation?: string | null): UpgradedEventFilter;
        Upgraded(implementation?: string | null): UpgradedEventFilter;
    };
    estimateGas: {
        UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<BigNumber>;
        depositID(d: DepositoryTypes$2.DepositStruct, u: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<BigNumber>;
        deposits(arg0: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        lock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaRouter(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unlock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        upgradeToAndCall(newImplementation: string, data: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        depositID(d: DepositoryTypes$2.DepositStruct, u: DepositoryTypes$2.UnlockerStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deposits(arg0: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        lock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unlock(deposit: DepositoryTypes$2.DepositStruct, unlocker: DepositoryTypes$2.UnlockerStruct, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        upgradeToAndCall(newImplementation: string, data: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface FabricInterface extends utils.Interface {
    contractName: 'Fabric';
    functions: {
        'createRepresentationByAdmin(address,uint256,string,string,uint8)': FunctionFragment;
        'getRealRepresentation(address)': FunctionFragment;
        'getSyntRepresentation(address,uint256)': FunctionFragment;
        'getSyntRepresentationByKey(bytes32)': FunctionFragment;
        'initialize(address)': FunctionFragment;
        'owner()': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'synthesis()': FunctionFragment;
        'synthesize(address,uint256,address)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unsynthesize(address,uint256,address)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'createRepresentationByAdmin', values: [string, BigNumberish, string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getRealRepresentation', values: [string]): string;
    encodeFunctionData(functionFragment: 'getSyntRepresentation', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getSyntRepresentationByKey', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'synthesis', values?: undefined): string;
    encodeFunctionData(functionFragment: 'synthesize', values: [string, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unsynthesize', values: [string, BigNumberish, string]): string;
    decodeFunctionResult(functionFragment: 'createRepresentationByAdmin', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getRealRepresentation', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getSyntRepresentation', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getSyntRepresentationByKey', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesis', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unsynthesize', data: BytesLike$1): Result;
    events: {
        'OwnershipTransferred(address,address)': EventFragment;
        'RepresentationCreated(address,uint256,address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'RepresentationCreated'): EventFragment;
}
type OwnershipTransferredEvent$6 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$6 = TypedEventFilter<OwnershipTransferredEvent$6>;
type RepresentationCreatedEvent = TypedEvent<[
    string,
    BigNumber,
    string
], {
    rToken: string;
    chainID: BigNumber;
    sToken: string;
}>;
type RepresentationCreatedEventFilter = TypedEventFilter<RepresentationCreatedEvent>;
interface Fabric extends BaseContract {
    contractName: 'Fabric';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: FabricInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        createRepresentationByAdmin(_rtoken: string, _chainID: BigNumberish, _stokenName: string, _stokenSymbol: string, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getRealRepresentation(_syntTokenAdr: string, overrides?: CallOverrides): Promise<[string]>;
        getSyntRepresentation(_realTokenAdr: string, _chainID: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        getSyntRepresentationByKey(_key: BytesLike$1, overrides?: CallOverrides): Promise<[string]>;
        initialize(_synthesis: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        synthesis(overrides?: CallOverrides): Promise<[string]>;
        synthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unsynthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    createRepresentationByAdmin(_rtoken: string, _chainID: BigNumberish, _stokenName: string, _stokenSymbol: string, _decimals: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getRealRepresentation(_syntTokenAdr: string, overrides?: CallOverrides): Promise<string>;
    getSyntRepresentation(_realTokenAdr: string, _chainID: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getSyntRepresentationByKey(_key: BytesLike$1, overrides?: CallOverrides): Promise<string>;
    initialize(_synthesis: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    synthesis(overrides?: CallOverrides): Promise<string>;
    synthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unsynthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        createRepresentationByAdmin(_rtoken: string, _chainID: BigNumberish, _stokenName: string, _stokenSymbol: string, _decimals: BigNumberish, overrides?: CallOverrides): Promise<void>;
        getRealRepresentation(_syntTokenAdr: string, overrides?: CallOverrides): Promise<string>;
        getSyntRepresentation(_realTokenAdr: string, _chainID: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getSyntRepresentationByKey(_key: BytesLike$1, overrides?: CallOverrides): Promise<string>;
        initialize(_synthesis: string, overrides?: CallOverrides): Promise<void>;
        owner(overrides?: CallOverrides): Promise<string>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        synthesis(overrides?: CallOverrides): Promise<string>;
        synthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: CallOverrides): Promise<void>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unsynthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$6;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$6;
        'RepresentationCreated(address,uint256,address)'(rToken?: null, chainID?: null, sToken?: null): RepresentationCreatedEventFilter;
        RepresentationCreated(rToken?: null, chainID?: null, sToken?: null): RepresentationCreatedEventFilter;
    };
    estimateGas: {
        createRepresentationByAdmin(_rtoken: string, _chainID: BigNumberish, _stokenName: string, _stokenSymbol: string, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getRealRepresentation(_syntTokenAdr: string, overrides?: CallOverrides): Promise<BigNumber>;
        getSyntRepresentation(_realTokenAdr: string, _chainID: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getSyntRepresentationByKey(_key: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_synthesis: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        synthesis(overrides?: CallOverrides): Promise<BigNumber>;
        synthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unsynthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        createRepresentationByAdmin(_rtoken: string, _chainID: BigNumberish, _stokenName: string, _stokenSymbol: string, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getRealRepresentation(_syntTokenAdr: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSyntRepresentation(_realTokenAdr: string, _chainID: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSyntRepresentationByKey(_key: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_synthesis: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        synthesis(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        synthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unsynthesize(_to: string, _amount: BigNumberish, _stoken: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace MetaRouteStructs$2 {
    type MetaMintTransactionStruct = {
        stableBridgingFee: BigNumberish;
        amount: BigNumberish;
        crossChainID: BytesLike$1;
        externalID: BytesLike$1;
        tokenReal: string;
        chainID: BigNumberish;
        to: string;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: BytesLike$1;
        finalReceiveSide: string;
        finalCalldata: BytesLike$1;
        finalOffset: BigNumberish;
    };
    type MetaMintTransactionStructOutput = [
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        BigNumber,
        string,
        string[],
        string,
        string,
        string,
        string,
        BigNumber
    ] & {
        stableBridgingFee: BigNumber;
        amount: BigNumber;
        crossChainID: string;
        externalID: string;
        tokenReal: string;
        chainID: BigNumber;
        to: string;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: string;
        finalReceiveSide: string;
        finalCalldata: string;
        finalOffset: BigNumber;
    };
    type MetaRouteTransactionStruct = {
        firstSwapCalldata: BytesLike$1;
        secondSwapCalldata: BytesLike$1;
        approvedTokens: string[];
        firstDexRouter: string;
        secondDexRouter: string;
        amount: BigNumberish;
        nativeIn: boolean;
        relayRecipient: string;
        otherSideCalldata: BytesLike$1;
    };
    type MetaRouteTransactionStructOutput = [
        string,
        string,
        string[],
        string,
        string,
        BigNumber,
        boolean,
        string,
        string
    ] & {
        firstSwapCalldata: string;
        secondSwapCalldata: string;
        approvedTokens: string[];
        firstDexRouter: string;
        secondDexRouter: string;
        amount: BigNumber;
        nativeIn: boolean;
        relayRecipient: string;
        otherSideCalldata: string;
    };
}
interface MetaRouterInterface extends utils.Interface {
    contractName: 'MetaRouter';
    functions: {
        'externalCall(address,uint256,address,bytes,uint256,address)': FunctionFragment;
        'metaMintSwap((uint256,uint256,bytes32,bytes32,address,uint256,address,address[],address,bytes,address,bytes,uint256))': FunctionFragment;
        'metaRoute((bytes,bytes,address[],address,address,uint256,bool,address,bytes))': FunctionFragment;
        'metaRouterGateway()': FunctionFragment;
        'returnSwap(address,uint256,address,bytes,address,address,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'externalCall', values: [string, BigNumberish, string, BytesLike$1, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'metaMintSwap', values: [MetaRouteStructs$2.MetaMintTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaRoute', values: [MetaRouteStructs$2.MetaRouteTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaRouterGateway', values?: undefined): string;
    encodeFunctionData(functionFragment: 'returnSwap', values: [string, BigNumberish, string, BytesLike$1, string, string, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'externalCall', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaMintSwap', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRoute', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRouterGateway', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'returnSwap', data: BytesLike$1): Result;
    events: {
        'TransitTokenSent(address,uint256,address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'TransitTokenSent'): EventFragment;
}
type TransitTokenSentEvent = TypedEvent<[
    string,
    BigNumber,
    string
], {
    to: string;
    amount: BigNumber;
    token: string;
}>;
type TransitTokenSentEventFilter = TypedEventFilter<TransitTokenSentEvent>;
interface MetaRouter extends BaseContract {
    contractName: 'MetaRouter';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MetaRouterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        externalCall(_token: string, _amount: BigNumberish, _receiveSide: string, _calldata: BytesLike$1, _offset: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaMintSwap(_metaMintTransaction: MetaRouteStructs$2.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaRoute(_metarouteTransaction: MetaRouteStructs$2.MetaRouteTransactionStruct, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaRouterGateway(overrides?: CallOverrides): Promise<[string]>;
        returnSwap(_token: string, _amount: BigNumberish, _router: string, _swapCalldata: BytesLike$1, _burnToken: string, _synthesis: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    externalCall(_token: string, _amount: BigNumberish, _receiveSide: string, _calldata: BytesLike$1, _offset: BigNumberish, _to: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaMintSwap(_metaMintTransaction: MetaRouteStructs$2.MetaMintTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaRoute(_metarouteTransaction: MetaRouteStructs$2.MetaRouteTransactionStruct, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaRouterGateway(overrides?: CallOverrides): Promise<string>;
    returnSwap(_token: string, _amount: BigNumberish, _router: string, _swapCalldata: BytesLike$1, _burnToken: string, _synthesis: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        externalCall(_token: string, _amount: BigNumberish, _receiveSide: string, _calldata: BytesLike$1, _offset: BigNumberish, _to: string, overrides?: CallOverrides): Promise<void>;
        metaMintSwap(_metaMintTransaction: MetaRouteStructs$2.MetaMintTransactionStruct, overrides?: CallOverrides): Promise<void>;
        metaRoute(_metarouteTransaction: MetaRouteStructs$2.MetaRouteTransactionStruct, overrides?: CallOverrides): Promise<void>;
        metaRouterGateway(overrides?: CallOverrides): Promise<string>;
        returnSwap(_token: string, _amount: BigNumberish, _router: string, _swapCalldata: BytesLike$1, _burnToken: string, _synthesis: string, _burnCalldata: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'TransitTokenSent(address,uint256,address)'(to?: null, amount?: null, token?: null): TransitTokenSentEventFilter;
        TransitTokenSent(to?: null, amount?: null, token?: null): TransitTokenSentEventFilter;
    };
    estimateGas: {
        externalCall(_token: string, _amount: BigNumberish, _receiveSide: string, _calldata: BytesLike$1, _offset: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaMintSwap(_metaMintTransaction: MetaRouteStructs$2.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaRoute(_metarouteTransaction: MetaRouteStructs$2.MetaRouteTransactionStruct, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaRouterGateway(overrides?: CallOverrides): Promise<BigNumber>;
        returnSwap(_token: string, _amount: BigNumberish, _router: string, _swapCalldata: BytesLike$1, _burnToken: string, _synthesis: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        externalCall(_token: string, _amount: BigNumberish, _receiveSide: string, _calldata: BytesLike$1, _offset: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaMintSwap(_metaMintTransaction: MetaRouteStructs$2.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaRoute(_metarouteTransaction: MetaRouteStructs$2.MetaRouteTransactionStruct, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaRouterGateway(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        returnSwap(_token: string, _amount: BigNumberish, _router: string, _swapCalldata: BytesLike$1, _burnToken: string, _synthesis: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace Multicall2 {
    type CallStruct = {
        target: string;
        callData: BytesLike$1;
    };
    type CallStructOutput = [string, string] & {
        target: string;
        callData: string;
    };
    type ResultStruct = {
        success: boolean;
        returnData: BytesLike$1;
    };
    type ResultStructOutput = [boolean, string] & {
        success: boolean;
        returnData: string;
    };
}
interface MulticallInterface extends utils.Interface {
    contractName: 'Multicall';
    functions: {
        'aggregate((address,bytes)[])': FunctionFragment;
        'blockAndAggregate((address,bytes)[])': FunctionFragment;
        'getBlockHash(uint256)': FunctionFragment;
        'getBlockNumber()': FunctionFragment;
        'getCurrentBlockCoinbase()': FunctionFragment;
        'getCurrentBlockDifficulty()': FunctionFragment;
        'getCurrentBlockGasLimit()': FunctionFragment;
        'getCurrentBlockTimestamp()': FunctionFragment;
        'getEthBalance(address)': FunctionFragment;
        'getLastBlockHash()': FunctionFragment;
        'tryAggregate(bool,(address,bytes)[])': FunctionFragment;
        'tryBlockAndAggregate(bool,(address,bytes)[])': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'aggregate', values: [Multicall2.CallStruct[]]): string;
    encodeFunctionData(functionFragment: 'blockAndAggregate', values: [Multicall2.CallStruct[]]): string;
    encodeFunctionData(functionFragment: 'getBlockHash', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getBlockNumber', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getCurrentBlockCoinbase', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getCurrentBlockDifficulty', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getCurrentBlockGasLimit', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getCurrentBlockTimestamp', values?: undefined): string;
    encodeFunctionData(functionFragment: 'getEthBalance', values: [string]): string;
    encodeFunctionData(functionFragment: 'getLastBlockHash', values?: undefined): string;
    encodeFunctionData(functionFragment: 'tryAggregate', values: [boolean, Multicall2.CallStruct[]]): string;
    encodeFunctionData(functionFragment: 'tryBlockAndAggregate', values: [boolean, Multicall2.CallStruct[]]): string;
    decodeFunctionResult(functionFragment: 'aggregate', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'blockAndAggregate', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getBlockHash', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getBlockNumber', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getCurrentBlockCoinbase', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getCurrentBlockDifficulty', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getCurrentBlockGasLimit', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getCurrentBlockTimestamp', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getEthBalance', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'getLastBlockHash', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tryAggregate', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tryBlockAndAggregate', data: BytesLike$1): Result;
    events: {};
}
interface Multicall extends BaseContract {
    contractName: 'Multicall';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MulticallInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        aggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        blockAndAggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getBlockHash(blockNumber: BigNumberish, overrides?: CallOverrides): Promise<[string] & {
            blockHash: string;
        }>;
        getBlockNumber(overrides?: CallOverrides): Promise<[BigNumber] & {
            blockNumber: BigNumber;
        }>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<[string] & {
            coinbase: string;
        }>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<[BigNumber] & {
            difficulty: BigNumber;
        }>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<[BigNumber] & {
            gaslimit: BigNumber;
        }>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<[BigNumber] & {
            timestamp: BigNumber;
        }>;
        getEthBalance(addr: string, overrides?: CallOverrides): Promise<[BigNumber] & {
            balance: BigNumber;
        }>;
        getLastBlockHash(overrides?: CallOverrides): Promise<[string] & {
            blockHash: string;
        }>;
        tryAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        tryBlockAndAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    aggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    blockAndAggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getBlockHash(blockNumber: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;
    getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<string>;
    getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber>;
    getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber>;
    getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
    getEthBalance(addr: string, overrides?: CallOverrides): Promise<BigNumber>;
    getLastBlockHash(overrides?: CallOverrides): Promise<string>;
    tryAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    tryBlockAndAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        aggregate(calls: Multicall2.CallStruct[], overrides?: CallOverrides): Promise<[BigNumber, string[]] & {
            blockNumber: BigNumber;
            returnData: string[];
        }>;
        blockAndAggregate(calls: Multicall2.CallStruct[], overrides?: CallOverrides): Promise<[
            BigNumber,
            string,
            Multicall2.ResultStructOutput[]
        ] & {
            blockNumber: BigNumber;
            blockHash: string;
            returnData: Multicall2.ResultStructOutput[];
        }>;
        getBlockHash(blockNumber: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<string>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
        getEthBalance(addr: string, overrides?: CallOverrides): Promise<BigNumber>;
        getLastBlockHash(overrides?: CallOverrides): Promise<string>;
        tryAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: CallOverrides): Promise<Multicall2.ResultStructOutput[]>;
        tryBlockAndAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: CallOverrides): Promise<[
            BigNumber,
            string,
            Multicall2.ResultStructOutput[]
        ] & {
            blockNumber: BigNumber;
            blockHash: string;
            returnData: Multicall2.ResultStructOutput[];
        }>;
    };
    filters: {};
    estimateGas: {
        aggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        blockAndAggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getBlockHash(blockNumber: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
        getEthBalance(addr: string, overrides?: CallOverrides): Promise<BigNumber>;
        getLastBlockHash(overrides?: CallOverrides): Promise<BigNumber>;
        tryAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        tryBlockAndAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        aggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        blockAndAggregate(calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getBlockHash(blockNumber: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getEthBalance(addr: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastBlockHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tryAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        tryBlockAndAggregate(requireSuccess: boolean, calls: Multicall2.CallStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface MulticallRouterInterface extends utils.Interface {
    contractName: 'MulticallRouter';
    functions: {
        'multicall(uint256,bytes[],address[],address[],uint256[],address)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'multicall', values: [BigNumberish, BytesLike$1[], string[], string[], BigNumberish[], string]): string;
    decodeFunctionResult(functionFragment: 'multicall', data: BytesLike$1): Result;
    events: {};
}
interface MulticallRouter extends BaseContract {
    contractName: 'MulticallRouter';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MulticallRouterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        multicall(_amountIn: BigNumberish, _calldata: BytesLike$1[], _receiveSides: string[], _path: string[], _offset: BigNumberish[], _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    multicall(_amountIn: BigNumberish, _calldata: BytesLike$1[], _receiveSides: string[], _path: string[], _offset: BigNumberish[], _to: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        multicall(_amountIn: BigNumberish, _calldata: BytesLike$1[], _receiveSides: string[], _path: string[], _offset: BigNumberish[], _to: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        multicall(_amountIn: BigNumberish, _calldata: BytesLike$1[], _receiveSides: string[], _path: string[], _offset: BigNumberish[], _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        multicall(_amountIn: BigNumberish, _calldata: BytesLike$1[], _receiveSides: string[], _path: string[], _offset: BigNumberish[], _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface OmniPoolInterface extends utils.Interface {
    contractName: 'OmniPool';
    functions: {
        'a()': FunctionFragment;
        'addAssetOcto(address,uint256,uint8)': FunctionFragment;
        'assetToIndex(address)': FunctionFragment;
        'balanceOf(address,uint256)': FunctionFragment;
        'balanceOfBatch(address[],uint256[])': FunctionFragment;
        'changeMaxSupply(uint256,uint256)': FunctionFragment;
        'deposit(uint256,uint256,uint256,address,uint256)': FunctionFragment;
        'devaddr()': FunctionFragment;
        'feeTo()': FunctionFragment;
        'globalEquilCovRatio()': FunctionFragment;
        'indexToAsset(uint256)': FunctionFragment;
        'initialize(uint256,uint256)': FunctionFragment;
        'isApprovedForAll(address,address)': FunctionFragment;
        'lastIndex()': FunctionFragment;
        'lpDividendRatio()': FunctionFragment;
        'lpFee()': FunctionFragment;
        'mintFee(uint256)': FunctionFragment;
        'mintFeeThreshold()': FunctionFragment;
        'owner()': FunctionFragment;
        'pause()': FunctionFragment;
        'paused()': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
        'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
        'setA(uint256)': FunctionFragment;
        'setApprovalForAll(address,bool)': FunctionFragment;
        'setAssetStatus(uint256,bool)': FunctionFragment;
        'setFeeRatio(uint256)': FunctionFragment;
        'setFeeTo(address)': FunctionFragment;
        'setLPFee(uint256)': FunctionFragment;
        'setMintFeeThreshold(uint256)': FunctionFragment;
        'setVeSISAddress(address)': FunctionFragment;
        'spreadAccumulatedError(uint256,uint256)': FunctionFragment;
        'supportsInterface(bytes4)': FunctionFragment;
        'swap(uint256,uint256,uint256,uint256,address,uint256)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unpause()': FunctionFragment;
        'uri(uint256)': FunctionFragment;
        'veSIS()': FunctionFragment;
        'withdraw(uint256,uint256,uint256,address,uint256)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'a', values?: undefined): string;
    encodeFunctionData(functionFragment: 'addAssetOcto', values: [string, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'assetToIndex', values: [string]): string;
    encodeFunctionData(functionFragment: 'balanceOf', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'balanceOfBatch', values: [string[], BigNumberish[]]): string;
    encodeFunctionData(functionFragment: 'changeMaxSupply', values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'deposit', values: [BigNumberish, BigNumberish, BigNumberish, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'devaddr', values?: undefined): string;
    encodeFunctionData(functionFragment: 'feeTo', values?: undefined): string;
    encodeFunctionData(functionFragment: 'globalEquilCovRatio', values?: undefined): string;
    encodeFunctionData(functionFragment: 'indexToAsset', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'initialize', values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'isApprovedForAll', values: [string, string]): string;
    encodeFunctionData(functionFragment: 'lastIndex', values?: undefined): string;
    encodeFunctionData(functionFragment: 'lpDividendRatio', values?: undefined): string;
    encodeFunctionData(functionFragment: 'lpFee', values?: undefined): string;
    encodeFunctionData(functionFragment: 'mintFee', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'mintFeeThreshold', values?: undefined): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'safeBatchTransferFrom', values: [string, string, BigNumberish[], BigNumberish[], BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'safeTransferFrom', values: [string, string, BigNumberish, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'setA', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setApprovalForAll', values: [string, boolean]): string;
    encodeFunctionData(functionFragment: 'setAssetStatus', values: [BigNumberish, boolean]): string;
    encodeFunctionData(functionFragment: 'setFeeRatio', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setFeeTo', values: [string]): string;
    encodeFunctionData(functionFragment: 'setLPFee', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setMintFeeThreshold', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setVeSISAddress', values: [string]): string;
    encodeFunctionData(functionFragment: 'spreadAccumulatedError', values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'swap', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'veSIS', values?: undefined): string;
    encodeFunctionData(functionFragment: 'withdraw', values: [BigNumberish, BigNumberish, BigNumberish, string, BigNumberish]): string;
    decodeFunctionResult(functionFragment: 'a', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'addAssetOcto', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'assetToIndex', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'balanceOfBatch', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeMaxSupply', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'deposit', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'devaddr', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'feeTo', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'globalEquilCovRatio', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'indexToAsset', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lastIndex', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lpDividendRatio', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lpFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'mintFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'mintFeeThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'pause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'paused', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'safeBatchTransferFrom', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'safeTransferFrom', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setA', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setApprovalForAll', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setAssetStatus', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setFeeRatio', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setFeeTo', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setLPFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setMintFeeThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setVeSISAddress', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'spreadAccumulatedError', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'swap', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unpause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'uri', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'veSIS', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike$1): Result;
    events: {
        'ApprovalForAll(address,address,bool)': EventFragment;
        'AssetAdded(address)': EventFragment;
        'AssetStatusChanged(address,bool)': EventFragment;
        'Deposit(address,address,uint256,uint256,address)': EventFragment;
        'FillPool(address,uint256)': EventFragment;
        'Initialized(uint8)': EventFragment;
        'NewA(uint256)': EventFragment;
        'NewFee(uint256)': EventFragment;
        'NewFeeTo(address)': EventFragment;
        'NewLPFee(uint256)': EventFragment;
        'NewMaxSupply(address,uint256)': EventFragment;
        'NewMintFeeThreshold(uint256)': EventFragment;
        'NewVeSIS(address)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'Paused(address)': EventFragment;
        'Swap(address,address,address,uint256,uint256,address)': EventFragment;
        'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
        'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
        'URI(string,uint256)': EventFragment;
        'Unpaused(address)': EventFragment;
        'Withdraw(address,address,uint256,uint256,address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'AssetAdded'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'AssetStatusChanged'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'FillPool'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewA'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewFee'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewFeeTo'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewLPFee'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewMaxSupply'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewMintFeeThreshold'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'NewVeSIS'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Swap'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment;
}
type ApprovalForAllEvent = TypedEvent<[
    string,
    string,
    boolean
], {
    account: string;
    operator: string;
    approved: boolean;
}>;
type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;
type AssetAddedEvent = TypedEvent<[string], {
    token: string;
}>;
type AssetAddedEventFilter = TypedEventFilter<AssetAddedEvent>;
type AssetStatusChangedEvent = TypedEvent<[string, boolean], {
    token: string;
    status: boolean;
}>;
type AssetStatusChangedEventFilter = TypedEventFilter<AssetStatusChangedEvent>;
type DepositEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    sender: string;
    token: string;
    amount: BigNumber;
    liquidity: BigNumber;
    to: string;
}>;
type DepositEventFilter = TypedEventFilter<DepositEvent>;
type FillPoolEvent = TypedEvent<[string, BigNumber], {
    token: string;
    amount: BigNumber;
}>;
type FillPoolEventFilter = TypedEventFilter<FillPoolEvent>;
type InitializedEvent$1 = TypedEvent<[number], {
    version: number;
}>;
type InitializedEventFilter$1 = TypedEventFilter<InitializedEvent$1>;
type NewAEvent = TypedEvent<[BigNumber], {
    value: BigNumber;
}>;
type NewAEventFilter = TypedEventFilter<NewAEvent>;
type NewFeeEvent = TypedEvent<[BigNumber], {
    lpDividendRatio: BigNumber;
}>;
type NewFeeEventFilter = TypedEventFilter<NewFeeEvent>;
type NewFeeToEvent = TypedEvent<[string], {
    addr: string;
}>;
type NewFeeToEventFilter = TypedEventFilter<NewFeeToEvent>;
type NewLPFeeEvent = TypedEvent<[BigNumber], {
    value: BigNumber;
}>;
type NewLPFeeEventFilter = TypedEventFilter<NewLPFeeEvent>;
type NewMaxSupplyEvent = TypedEvent<[string, BigNumber], {
    token: string;
    newMaxSupply: BigNumber;
}>;
type NewMaxSupplyEventFilter = TypedEventFilter<NewMaxSupplyEvent>;
type NewMintFeeThresholdEvent = TypedEvent<[BigNumber], {
    value: BigNumber;
}>;
type NewMintFeeThresholdEventFilter = TypedEventFilter<NewMintFeeThresholdEvent>;
type NewVeSISEvent = TypedEvent<[string], {
    newVeSIS: string;
}>;
type NewVeSISEventFilter = TypedEventFilter<NewVeSISEvent>;
type OwnershipTransferredEvent$5 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$5 = TypedEventFilter<OwnershipTransferredEvent$5>;
type PausedEvent$3 = TypedEvent<[string], {
    account: string;
}>;
type PausedEventFilter$3 = TypedEventFilter<PausedEvent$3>;
type SwapEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    sender: string;
    fromToken: string;
    toToken: string;
    fromAmount: BigNumber;
    toAmount: BigNumber;
    to: string;
}>;
type SwapEventFilter = TypedEventFilter<SwapEvent>;
type TransferBatchEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber[],
    BigNumber[]
], {
    operator: string;
    from: string;
    to: string;
    ids: BigNumber[];
    values: BigNumber[];
}>;
type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;
type TransferSingleEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber
], {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
}>;
type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;
type URIEvent = TypedEvent<[string, BigNumber], {
    value: string;
    id: BigNumber;
}>;
type URIEventFilter = TypedEventFilter<URIEvent>;
type UnpausedEvent$3 = TypedEvent<[string], {
    account: string;
}>;
type UnpausedEventFilter$3 = TypedEventFilter<UnpausedEvent$3>;
type WithdrawEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    sender: string;
    token: string;
    amount: BigNumber;
    liquidity: BigNumber;
    to: string;
}>;
type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;
interface OmniPool extends BaseContract {
    contractName: 'OmniPool';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: OmniPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        a(overrides?: CallOverrides): Promise<[BigNumber]>;
        addAssetOcto(_token: string, _maxSupply: BigNumberish, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        assetToIndex(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        balanceOf(account: string, id: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
        balanceOfBatch(accounts: string[], ids: BigNumberish[], overrides?: CallOverrides): Promise<[BigNumber[]]>;
        changeMaxSupply(_tokenID: BigNumberish, _newMaxSupply: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        deposit(_id: BigNumberish, _amount: BigNumberish, _minimumLiquidity: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        devaddr(overrides?: CallOverrides): Promise<[string]>;
        feeTo(overrides?: CallOverrides): Promise<[string]>;
        globalEquilCovRatio(overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            equilCovRatio: BigNumber;
            invariant: BigNumber;
        }>;
        indexToAsset(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber,
            number,
            string,
            boolean
        ] & {
            cash: BigNumber;
            liability: BigNumber;
            maxSupply: BigNumber;
            totalSupply: BigNumber;
            decimals: number;
            token: string;
            active: boolean;
        }>;
        initialize(_a: BigNumberish, _lpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isApprovedForAll(account: string, operator: string, overrides?: CallOverrides): Promise<[boolean]>;
        lastIndex(overrides?: CallOverrides): Promise<[BigNumber]>;
        lpDividendRatio(overrides?: CallOverrides): Promise<[BigNumber]>;
        lpFee(overrides?: CallOverrides): Promise<[BigNumber]>;
        mintFee(_id: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        mintFeeThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        safeBatchTransferFrom(from: string, to: string, ids: BigNumberish[], amounts: BigNumberish[], data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        safeTransferFrom(from: string, to: string, id: BigNumberish, amount: BigNumberish, data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setA(_newA: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setApprovalForAll(operator: string, approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setAssetStatus(_id: BigNumberish, _active: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setFeeRatio(_newLpDividendRatio: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setFeeTo(_newFeeTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setLPFee(_newLpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMintFeeThreshold(_newMintFeeThreshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setVeSISAddress(_newVeSIS: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        spreadAccumulatedError(_id: BigNumberish, _amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        supportsInterface(interfaceId: BytesLike$1, overrides?: CallOverrides): Promise<[boolean]>;
        swap(_fromID: BigNumberish, _toID: BigNumberish, _fromAmount: BigNumberish, _minToAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        veSIS(overrides?: CallOverrides): Promise<[string]>;
        withdraw(_id: BigNumberish, _liquidity: BigNumberish, _minAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    a(overrides?: CallOverrides): Promise<BigNumber>;
    addAssetOcto(_token: string, _maxSupply: BigNumberish, _decimals: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    assetToIndex(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    balanceOf(account: string, id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    balanceOfBatch(accounts: string[], ids: BigNumberish[], overrides?: CallOverrides): Promise<BigNumber[]>;
    changeMaxSupply(_tokenID: BigNumberish, _newMaxSupply: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    deposit(_id: BigNumberish, _amount: BigNumberish, _minimumLiquidity: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    devaddr(overrides?: CallOverrides): Promise<string>;
    feeTo(overrides?: CallOverrides): Promise<string>;
    globalEquilCovRatio(overrides?: CallOverrides): Promise<[BigNumber, BigNumber] & {
        equilCovRatio: BigNumber;
        invariant: BigNumber;
    }>;
    indexToAsset(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        boolean
    ] & {
        cash: BigNumber;
        liability: BigNumber;
        maxSupply: BigNumber;
        totalSupply: BigNumber;
        decimals: number;
        token: string;
        active: boolean;
    }>;
    initialize(_a: BigNumberish, _lpFee: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isApprovedForAll(account: string, operator: string, overrides?: CallOverrides): Promise<boolean>;
    lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
    lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
    lpFee(overrides?: CallOverrides): Promise<BigNumber>;
    mintFee(_id: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    mintFeeThreshold(overrides?: CallOverrides): Promise<BigNumber>;
    owner(overrides?: CallOverrides): Promise<string>;
    pause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    paused(overrides?: CallOverrides): Promise<boolean>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    safeBatchTransferFrom(from: string, to: string, ids: BigNumberish[], amounts: BigNumberish[], data: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    safeTransferFrom(from: string, to: string, id: BigNumberish, amount: BigNumberish, data: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setA(_newA: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setApprovalForAll(operator: string, approved: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setAssetStatus(_id: BigNumberish, _active: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setFeeRatio(_newLpDividendRatio: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setFeeTo(_newFeeTo: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setLPFee(_newLpFee: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMintFeeThreshold(_newMintFeeThreshold: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setVeSISAddress(_newVeSIS: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    spreadAccumulatedError(_id: BigNumberish, _amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    supportsInterface(interfaceId: BytesLike$1, overrides?: CallOverrides): Promise<boolean>;
    swap(_fromID: BigNumberish, _toID: BigNumberish, _fromAmount: BigNumberish, _minToAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
    veSIS(overrides?: CallOverrides): Promise<string>;
    withdraw(_id: BigNumberish, _liquidity: BigNumberish, _minAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        a(overrides?: CallOverrides): Promise<BigNumber>;
        addAssetOcto(_token: string, _maxSupply: BigNumberish, _decimals: BigNumberish, overrides?: CallOverrides): Promise<void>;
        assetToIndex(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        balanceOf(account: string, id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        balanceOfBatch(accounts: string[], ids: BigNumberish[], overrides?: CallOverrides): Promise<BigNumber[]>;
        changeMaxSupply(_tokenID: BigNumberish, _newMaxSupply: BigNumberish, overrides?: CallOverrides): Promise<void>;
        deposit(_id: BigNumberish, _amount: BigNumberish, _minimumLiquidity: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, BigNumber] & {
            liquidity: BigNumber;
            fee: BigNumber;
        }>;
        devaddr(overrides?: CallOverrides): Promise<string>;
        feeTo(overrides?: CallOverrides): Promise<string>;
        globalEquilCovRatio(overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            equilCovRatio: BigNumber;
            invariant: BigNumber;
        }>;
        indexToAsset(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber,
            number,
            string,
            boolean
        ] & {
            cash: BigNumber;
            liability: BigNumber;
            maxSupply: BigNumber;
            totalSupply: BigNumber;
            decimals: number;
            token: string;
            active: boolean;
        }>;
        initialize(_a: BigNumberish, _lpFee: BigNumberish, overrides?: CallOverrides): Promise<void>;
        isApprovedForAll(account: string, operator: string, overrides?: CallOverrides): Promise<boolean>;
        lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
        lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
        lpFee(overrides?: CallOverrides): Promise<BigNumber>;
        mintFee(_id: BigNumberish, overrides?: CallOverrides): Promise<void>;
        mintFeeThreshold(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<string>;
        pause(overrides?: CallOverrides): Promise<void>;
        paused(overrides?: CallOverrides): Promise<boolean>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        safeBatchTransferFrom(from: string, to: string, ids: BigNumberish[], amounts: BigNumberish[], data: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        safeTransferFrom(from: string, to: string, id: BigNumberish, amount: BigNumberish, data: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        setA(_newA: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setApprovalForAll(operator: string, approved: boolean, overrides?: CallOverrides): Promise<void>;
        setAssetStatus(_id: BigNumberish, _active: boolean, overrides?: CallOverrides): Promise<void>;
        setFeeRatio(_newLpDividendRatio: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setFeeTo(_newFeeTo: string, overrides?: CallOverrides): Promise<void>;
        setLPFee(_newLpFee: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setMintFeeThreshold(_newMintFeeThreshold: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setVeSISAddress(_newVeSIS: string, overrides?: CallOverrides): Promise<void>;
        spreadAccumulatedError(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        supportsInterface(interfaceId: BytesLike$1, overrides?: CallOverrides): Promise<boolean>;
        swap(_fromID: BigNumberish, _toID: BigNumberish, _fromAmount: BigNumberish, _minToAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            actualToAmount: BigNumber;
            lpFeeAmount: BigNumber;
        }>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unpause(overrides?: CallOverrides): Promise<void>;
        uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
        veSIS(overrides?: CallOverrides): Promise<string>;
        withdraw(_id: BigNumberish, _liquidity: BigNumberish, _minAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, BigNumber] & {
            amount: BigNumber;
            fee: BigNumber;
        }>;
    };
    filters: {
        'ApprovalForAll(address,address,bool)'(account?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;
        ApprovalForAll(account?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;
        'AssetAdded(address)'(token?: string | null): AssetAddedEventFilter;
        AssetAdded(token?: string | null): AssetAddedEventFilter;
        'AssetStatusChanged(address,bool)'(token?: string | null, status?: boolean | null): AssetStatusChangedEventFilter;
        AssetStatusChanged(token?: string | null, status?: boolean | null): AssetStatusChangedEventFilter;
        'Deposit(address,address,uint256,uint256,address)'(sender?: string | null, token?: string | null, amount?: null, liquidity?: null, to?: string | null): DepositEventFilter;
        Deposit(sender?: string | null, token?: string | null, amount?: null, liquidity?: null, to?: string | null): DepositEventFilter;
        'FillPool(address,uint256)'(token?: string | null, amount?: null): FillPoolEventFilter;
        FillPool(token?: string | null, amount?: null): FillPoolEventFilter;
        'Initialized(uint8)'(version?: null): InitializedEventFilter$1;
        Initialized(version?: null): InitializedEventFilter$1;
        'NewA(uint256)'(value?: null): NewAEventFilter;
        NewA(value?: null): NewAEventFilter;
        'NewFee(uint256)'(lpDividendRatio?: null): NewFeeEventFilter;
        NewFee(lpDividendRatio?: null): NewFeeEventFilter;
        'NewFeeTo(address)'(addr?: string | null): NewFeeToEventFilter;
        NewFeeTo(addr?: string | null): NewFeeToEventFilter;
        'NewLPFee(uint256)'(value?: null): NewLPFeeEventFilter;
        NewLPFee(value?: null): NewLPFeeEventFilter;
        'NewMaxSupply(address,uint256)'(token?: string | null, newMaxSupply?: BigNumberish | null): NewMaxSupplyEventFilter;
        NewMaxSupply(token?: string | null, newMaxSupply?: BigNumberish | null): NewMaxSupplyEventFilter;
        'NewMintFeeThreshold(uint256)'(value?: null): NewMintFeeThresholdEventFilter;
        NewMintFeeThreshold(value?: null): NewMintFeeThresholdEventFilter;
        'NewVeSIS(address)'(newVeSIS?: string | null): NewVeSISEventFilter;
        NewVeSIS(newVeSIS?: string | null): NewVeSISEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$5;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$5;
        'Paused(address)'(account?: null): PausedEventFilter$3;
        Paused(account?: null): PausedEventFilter$3;
        'Swap(address,address,address,uint256,uint256,address)'(sender?: string | null, fromToken?: null, toToken?: null, fromAmount?: null, toAmount?: null, to?: string | null): SwapEventFilter;
        Swap(sender?: string | null, fromToken?: null, toToken?: null, fromAmount?: null, toAmount?: null, to?: string | null): SwapEventFilter;
        'TransferBatch(address,address,address,uint256[],uint256[])'(operator?: string | null, from?: string | null, to?: string | null, ids?: null, values?: null): TransferBatchEventFilter;
        TransferBatch(operator?: string | null, from?: string | null, to?: string | null, ids?: null, values?: null): TransferBatchEventFilter;
        'TransferSingle(address,address,address,uint256,uint256)'(operator?: string | null, from?: string | null, to?: string | null, id?: null, value?: null): TransferSingleEventFilter;
        TransferSingle(operator?: string | null, from?: string | null, to?: string | null, id?: null, value?: null): TransferSingleEventFilter;
        'URI(string,uint256)'(value?: null, id?: BigNumberish | null): URIEventFilter;
        URI(value?: null, id?: BigNumberish | null): URIEventFilter;
        'Unpaused(address)'(account?: null): UnpausedEventFilter$3;
        Unpaused(account?: null): UnpausedEventFilter$3;
        'Withdraw(address,address,uint256,uint256,address)'(sender?: string | null, token?: string | null, amount?: null, liquidity?: null, to?: string | null): WithdrawEventFilter;
        Withdraw(sender?: string | null, token?: string | null, amount?: null, liquidity?: null, to?: string | null): WithdrawEventFilter;
    };
    estimateGas: {
        a(overrides?: CallOverrides): Promise<BigNumber>;
        addAssetOcto(_token: string, _maxSupply: BigNumberish, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        assetToIndex(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        balanceOf(account: string, id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        balanceOfBatch(accounts: string[], ids: BigNumberish[], overrides?: CallOverrides): Promise<BigNumber>;
        changeMaxSupply(_tokenID: BigNumberish, _newMaxSupply: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        deposit(_id: BigNumberish, _amount: BigNumberish, _minimumLiquidity: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        devaddr(overrides?: CallOverrides): Promise<BigNumber>;
        feeTo(overrides?: CallOverrides): Promise<BigNumber>;
        globalEquilCovRatio(overrides?: CallOverrides): Promise<BigNumber>;
        indexToAsset(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_a: BigNumberish, _lpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isApprovedForAll(account: string, operator: string, overrides?: CallOverrides): Promise<BigNumber>;
        lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
        lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
        lpFee(overrides?: CallOverrides): Promise<BigNumber>;
        mintFee(_id: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        mintFeeThreshold(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        paused(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        safeBatchTransferFrom(from: string, to: string, ids: BigNumberish[], amounts: BigNumberish[], data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        safeTransferFrom(from: string, to: string, id: BigNumberish, amount: BigNumberish, data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setA(_newA: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setApprovalForAll(operator: string, approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setAssetStatus(_id: BigNumberish, _active: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setFeeRatio(_newLpDividendRatio: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setFeeTo(_newFeeTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setLPFee(_newLpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMintFeeThreshold(_newMintFeeThreshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setVeSISAddress(_newVeSIS: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        spreadAccumulatedError(_id: BigNumberish, _amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        supportsInterface(interfaceId: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        swap(_fromID: BigNumberish, _toID: BigNumberish, _fromAmount: BigNumberish, _minToAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        veSIS(overrides?: CallOverrides): Promise<BigNumber>;
        withdraw(_id: BigNumberish, _liquidity: BigNumberish, _minAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        a(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        addAssetOcto(_token: string, _maxSupply: BigNumberish, _decimals: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        assetToIndex(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        balanceOf(account: string, id: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        balanceOfBatch(accounts: string[], ids: BigNumberish[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        changeMaxSupply(_tokenID: BigNumberish, _newMaxSupply: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        deposit(_id: BigNumberish, _amount: BigNumberish, _minimumLiquidity: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        devaddr(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        feeTo(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        globalEquilCovRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        indexToAsset(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_a: BigNumberish, _lpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isApprovedForAll(account: string, operator: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lastIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lpDividendRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lpFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mintFee(_id: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        mintFeeThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        safeBatchTransferFrom(from: string, to: string, ids: BigNumberish[], amounts: BigNumberish[], data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        safeTransferFrom(from: string, to: string, id: BigNumberish, amount: BigNumberish, data: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setA(_newA: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setApprovalForAll(operator: string, approved: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setAssetStatus(_id: BigNumberish, _active: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setFeeRatio(_newLpDividendRatio: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setFeeTo(_newFeeTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setLPFee(_newLpFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMintFeeThreshold(_newMintFeeThreshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setVeSISAddress(_newVeSIS: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        spreadAccumulatedError(_id: BigNumberish, _amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        supportsInterface(interfaceId: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        swap(_fromID: BigNumberish, _toID: BigNumberish, _fromAmount: BigNumberish, _minToAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        veSIS(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        withdraw(_id: BigNumberish, _liquidity: BigNumberish, _minAmount: BigNumberish, _to: string, _deadline: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface OmniPoolOracleInterface extends utils.Interface {
    contractName: 'OmniPoolOracle';
    functions: {
        'a()': FunctionFragment;
        'devaddr()': FunctionFragment;
        'initialize(address)': FunctionFragment;
        'lastIndex()': FunctionFragment;
        'lpDividendRatio()': FunctionFragment;
        'lpFee()': FunctionFragment;
        'owner()': FunctionFragment;
        'pause()': FunctionFragment;
        'paused()': FunctionFragment;
        'pool()': FunctionFragment;
        'poolDev()': FunctionFragment;
        'quoteDeposit(uint256,uint256)': FunctionFragment;
        'quoteFrom(uint256,uint256,int256)': FunctionFragment;
        'quoteWithdraw(uint256,uint256)': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unpause()': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'a', values?: undefined): string;
    encodeFunctionData(functionFragment: 'devaddr', values?: undefined): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
    encodeFunctionData(functionFragment: 'lastIndex', values?: undefined): string;
    encodeFunctionData(functionFragment: 'lpDividendRatio', values?: undefined): string;
    encodeFunctionData(functionFragment: 'lpFee', values?: undefined): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
    encodeFunctionData(functionFragment: 'pool', values?: undefined): string;
    encodeFunctionData(functionFragment: 'poolDev', values?: undefined): string;
    encodeFunctionData(functionFragment: 'quoteDeposit', values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'quoteFrom', values: [BigNumberish, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'quoteWithdraw', values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
    decodeFunctionResult(functionFragment: 'a', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'devaddr', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lastIndex', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lpDividendRatio', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'lpFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'pause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'paused', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'pool', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'poolDev', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'quoteDeposit', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'quoteFrom', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'quoteWithdraw', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unpause', data: BytesLike$1): Result;
    events: {
        'Initialized(uint8)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'Paused(address)': EventFragment;
        'Unpaused(address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}
type InitializedEvent = TypedEvent<[number], {
    version: number;
}>;
type InitializedEventFilter = TypedEventFilter<InitializedEvent>;
type OwnershipTransferredEvent$4 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$4 = TypedEventFilter<OwnershipTransferredEvent$4>;
type PausedEvent$2 = TypedEvent<[string], {
    account: string;
}>;
type PausedEventFilter$2 = TypedEventFilter<PausedEvent$2>;
type UnpausedEvent$2 = TypedEvent<[string], {
    account: string;
}>;
type UnpausedEventFilter$2 = TypedEventFilter<UnpausedEvent$2>;
interface OmniPoolOracle extends BaseContract {
    contractName: 'OmniPoolOracle';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: OmniPoolOracleInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        a(overrides?: CallOverrides): Promise<[BigNumber]>;
        devaddr(overrides?: CallOverrides): Promise<[string]>;
        initialize(_pool: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        lastIndex(overrides?: CallOverrides): Promise<[BigNumber]>;
        lpDividendRatio(overrides?: CallOverrides): Promise<[BigNumber]>;
        lpFee(overrides?: CallOverrides): Promise<[BigNumber]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        pool(overrides?: CallOverrides): Promise<[string]>;
        poolDev(overrides?: CallOverrides): Promise<[string]>;
        quoteDeposit(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            lpTokenToMint: BigNumber;
            liabilityToMint: BigNumber;
            reward: BigNumber;
        }>;
        quoteFrom(_fromAsset: BigNumberish, _toAsset: BigNumberish, _fromAmount: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            actualToAmount: BigNumber;
            lpFeeAmount: BigNumber;
        }>;
        quoteWithdraw(_id: BigNumberish, _liquidity: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            amount: BigNumber;
            liabilityToBurn: BigNumber;
            fee: BigNumber;
        }>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    a(overrides?: CallOverrides): Promise<BigNumber>;
    devaddr(overrides?: CallOverrides): Promise<string>;
    initialize(_pool: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
    lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
    lpFee(overrides?: CallOverrides): Promise<BigNumber>;
    owner(overrides?: CallOverrides): Promise<string>;
    pause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    paused(overrides?: CallOverrides): Promise<boolean>;
    pool(overrides?: CallOverrides): Promise<string>;
    poolDev(overrides?: CallOverrides): Promise<string>;
    quoteDeposit(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        lpTokenToMint: BigNumber;
        liabilityToMint: BigNumber;
        reward: BigNumber;
    }>;
    quoteFrom(_fromAsset: BigNumberish, _toAsset: BigNumberish, _fromAmount: BigNumberish, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber
    ] & {
        actualToAmount: BigNumber;
        lpFeeAmount: BigNumber;
    }>;
    quoteWithdraw(_id: BigNumberish, _liquidity: BigNumberish, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        amount: BigNumber;
        liabilityToBurn: BigNumber;
        fee: BigNumber;
    }>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        a(overrides?: CallOverrides): Promise<BigNumber>;
        devaddr(overrides?: CallOverrides): Promise<string>;
        initialize(_pool: string, overrides?: CallOverrides): Promise<void>;
        lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
        lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
        lpFee(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<string>;
        pause(overrides?: CallOverrides): Promise<void>;
        paused(overrides?: CallOverrides): Promise<boolean>;
        pool(overrides?: CallOverrides): Promise<string>;
        poolDev(overrides?: CallOverrides): Promise<string>;
        quoteDeposit(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            lpTokenToMint: BigNumber;
            liabilityToMint: BigNumber;
            reward: BigNumber;
        }>;
        quoteFrom(_fromAsset: BigNumberish, _toAsset: BigNumberish, _fromAmount: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            actualToAmount: BigNumber;
            lpFeeAmount: BigNumber;
        }>;
        quoteWithdraw(_id: BigNumberish, _liquidity: BigNumberish, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            amount: BigNumber;
            liabilityToBurn: BigNumber;
            fee: BigNumber;
        }>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unpause(overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'Initialized(uint8)'(version?: null): InitializedEventFilter;
        Initialized(version?: null): InitializedEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$4;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$4;
        'Paused(address)'(account?: null): PausedEventFilter$2;
        Paused(account?: null): PausedEventFilter$2;
        'Unpaused(address)'(account?: null): UnpausedEventFilter$2;
        Unpaused(account?: null): UnpausedEventFilter$2;
    };
    estimateGas: {
        a(overrides?: CallOverrides): Promise<BigNumber>;
        devaddr(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_pool: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        lastIndex(overrides?: CallOverrides): Promise<BigNumber>;
        lpDividendRatio(overrides?: CallOverrides): Promise<BigNumber>;
        lpFee(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        paused(overrides?: CallOverrides): Promise<BigNumber>;
        pool(overrides?: CallOverrides): Promise<BigNumber>;
        poolDev(overrides?: CallOverrides): Promise<BigNumber>;
        quoteDeposit(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        quoteFrom(_fromAsset: BigNumberish, _toAsset: BigNumberish, _fromAmount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        quoteWithdraw(_id: BigNumberish, _liquidity: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        a(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        devaddr(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_pool: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        lastIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lpDividendRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lpFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        poolDev(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        quoteDeposit(_id: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        quoteFrom(_fromAsset: BigNumberish, _toAsset: BigNumberish, _fromAmount: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        quoteWithdraw(_id: BigNumberish, _liquidity: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface PartnerFeeCollectorInterface extends utils.Interface {
    contractName: 'PartnerFeeCollector';
    functions: {
        'WAD()': FunctionFragment;
        'activatePartner(address,uint256)': FunctionFragment;
        'changeDefaultPartner(address,uint256)': FunctionFragment;
        'claimFee(address)': FunctionFragment;
        'collectFee(uint256,address,address)': FunctionFragment;
        'collectedFees(address,address)': FunctionFragment;
        'deactivatePartner(address)': FunctionFragment;
        'defaultPartner()': FunctionFragment;
        'fixedFee(address,address)': FunctionFragment;
        'initialize(address,uint256)': FunctionFragment;
        'owner()': FunctionFragment;
        'partners(address)': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'setFeeRate(address,uint256)': FunctionFragment;
        'setFixedFee(address,address,uint256)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'WAD', values?: undefined): string;
    encodeFunctionData(functionFragment: 'activatePartner', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'changeDefaultPartner', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'claimFee', values: [string]): string;
    encodeFunctionData(functionFragment: 'collectFee', values: [BigNumberish, string, string]): string;
    encodeFunctionData(functionFragment: 'collectedFees', values: [string, string]): string;
    encodeFunctionData(functionFragment: 'deactivatePartner', values: [string]): string;
    encodeFunctionData(functionFragment: 'defaultPartner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'fixedFee', values: [string, string]): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'partners', values: [string]): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'setFeeRate', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setFixedFee', values: [string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    decodeFunctionResult(functionFragment: 'WAD', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'activatePartner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeDefaultPartner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'claimFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'collectFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'collectedFees', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'deactivatePartner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'defaultPartner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'fixedFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'partners', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setFeeRate', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setFixedFee', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    events: {
        'FeeClaimed(address,address,uint256)': EventFragment;
        'FeeCollected(address,address,uint256,uint256)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'PartnerActivated(address,uint256)': EventFragment;
        'PartnerDeactivated(address)': EventFragment;
        'PartnerFeeRateUpdated(address,uint256)': EventFragment;
        'PartnerFixedFeeUpdated(address,address,uint256)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'FeeClaimed'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'FeeCollected'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'PartnerActivated'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'PartnerDeactivated'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'PartnerFeeRateUpdated'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'PartnerFixedFeeUpdated'): EventFragment;
}
type FeeClaimedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], {
    partner: string;
    token: string;
    amount: BigNumber;
}>;
type FeeClaimedEventFilter = TypedEventFilter<FeeClaimedEvent>;
type FeeCollectedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], {
    partner: string;
    token: string;
    amount: BigNumber;
    fee: BigNumber;
}>;
type FeeCollectedEventFilter = TypedEventFilter<FeeCollectedEvent>;
type OwnershipTransferredEvent$3 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$3 = TypedEventFilter<OwnershipTransferredEvent$3>;
type PartnerActivatedEvent = TypedEvent<[string, BigNumber], {
    partner: string;
    feeRate: BigNumber;
}>;
type PartnerActivatedEventFilter = TypedEventFilter<PartnerActivatedEvent>;
type PartnerDeactivatedEvent = TypedEvent<[string], {
    partner: string;
}>;
type PartnerDeactivatedEventFilter = TypedEventFilter<PartnerDeactivatedEvent>;
type PartnerFeeRateUpdatedEvent = TypedEvent<[string, BigNumber], {
    partner: string;
    feeRate: BigNumber;
}>;
type PartnerFeeRateUpdatedEventFilter = TypedEventFilter<PartnerFeeRateUpdatedEvent>;
type PartnerFixedFeeUpdatedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], {
    partner: string;
    token: string;
    fee: BigNumber;
}>;
type PartnerFixedFeeUpdatedEventFilter = TypedEventFilter<PartnerFixedFeeUpdatedEvent>;
interface PartnerFeeCollector extends BaseContract {
    contractName: 'PartnerFeeCollector';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: PartnerFeeCollectorInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        WAD(overrides?: CallOverrides): Promise<[BigNumber]>;
        activatePartner(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeDefaultPartner(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        claimFee(token: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        collectFee(amount: BigNumberish, token: string, partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        collectedFees(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        deactivatePartner(partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        defaultPartner(overrides?: CallOverrides): Promise<[string]>;
        fixedFee(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        initialize(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        partners(arg0: string, overrides?: CallOverrides): Promise<[boolean, BigNumber] & {
            isActive: boolean;
            feeRate: BigNumber;
        }>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setFeeRate(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setFixedFee(partner: string, token: string, newFixedFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    WAD(overrides?: CallOverrides): Promise<BigNumber>;
    activatePartner(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeDefaultPartner(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    claimFee(token: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    collectFee(amount: BigNumberish, token: string, partner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    collectedFees(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
    deactivatePartner(partner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    defaultPartner(overrides?: CallOverrides): Promise<string>;
    fixedFee(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
    initialize(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    partners(arg0: string, overrides?: CallOverrides): Promise<[boolean, BigNumber] & {
        isActive: boolean;
        feeRate: BigNumber;
    }>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setFeeRate(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setFixedFee(partner: string, token: string, newFixedFee: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        WAD(overrides?: CallOverrides): Promise<BigNumber>;
        activatePartner(partner: string, feeRate: BigNumberish, overrides?: CallOverrides): Promise<void>;
        changeDefaultPartner(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: CallOverrides): Promise<void>;
        claimFee(token: string, overrides?: CallOverrides): Promise<void>;
        collectFee(amount: BigNumberish, token: string, partner: string, overrides?: CallOverrides): Promise<void>;
        collectedFees(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
        deactivatePartner(partner: string, overrides?: CallOverrides): Promise<void>;
        defaultPartner(overrides?: CallOverrides): Promise<string>;
        fixedFee(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: CallOverrides): Promise<void>;
        owner(overrides?: CallOverrides): Promise<string>;
        partners(arg0: string, overrides?: CallOverrides): Promise<[boolean, BigNumber] & {
            isActive: boolean;
            feeRate: BigNumber;
        }>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        setFeeRate(partner: string, feeRate: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setFixedFee(partner: string, token: string, newFixedFee: BigNumberish, overrides?: CallOverrides): Promise<void>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'FeeClaimed(address,address,uint256)'(partner?: string | null, token?: null, amount?: null): FeeClaimedEventFilter;
        FeeClaimed(partner?: string | null, token?: null, amount?: null): FeeClaimedEventFilter;
        'FeeCollected(address,address,uint256,uint256)'(partner?: string | null, token?: string | null, amount?: null, fee?: null): FeeCollectedEventFilter;
        FeeCollected(partner?: string | null, token?: string | null, amount?: null, fee?: null): FeeCollectedEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$3;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$3;
        'PartnerActivated(address,uint256)'(partner?: string | null, feeRate?: null): PartnerActivatedEventFilter;
        PartnerActivated(partner?: string | null, feeRate?: null): PartnerActivatedEventFilter;
        'PartnerDeactivated(address)'(partner?: string | null): PartnerDeactivatedEventFilter;
        PartnerDeactivated(partner?: string | null): PartnerDeactivatedEventFilter;
        'PartnerFeeRateUpdated(address,uint256)'(partner?: string | null, feeRate?: null): PartnerFeeRateUpdatedEventFilter;
        PartnerFeeRateUpdated(partner?: string | null, feeRate?: null): PartnerFeeRateUpdatedEventFilter;
        'PartnerFixedFeeUpdated(address,address,uint256)'(partner?: string | null, token?: string | null, fee?: null): PartnerFixedFeeUpdatedEventFilter;
        PartnerFixedFeeUpdated(partner?: string | null, token?: string | null, fee?: null): PartnerFixedFeeUpdatedEventFilter;
    };
    estimateGas: {
        WAD(overrides?: CallOverrides): Promise<BigNumber>;
        activatePartner(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeDefaultPartner(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        claimFee(token: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        collectFee(amount: BigNumberish, token: string, partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        collectedFees(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
        deactivatePartner(partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        defaultPartner(overrides?: CallOverrides): Promise<BigNumber>;
        fixedFee(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        partners(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setFeeRate(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setFixedFee(partner: string, token: string, newFixedFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        WAD(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        activatePartner(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeDefaultPartner(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        claimFee(token: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        collectFee(amount: BigNumberish, token: string, partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        collectedFees(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deactivatePartner(partner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        defaultPartner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        fixedFee(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_defaultPartner: string, _defaultFeeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        partners(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setFeeRate(partner: string, feeRate: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setFixedFee(partner: string, token: string, newFixedFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace MetaRouteStructs$1 {
    type MetaRevertTransactionStruct = {
        stableBridgingFee: BigNumberish;
        internalID: BytesLike$1;
        receiveSide: string;
        managerChainBridge: string;
        sourceChainBridge: string;
        managerChainId: BigNumberish;
        sourceChainId: BigNumberish;
        router: string;
        swapCalldata: BytesLike$1;
        sourceChainSynthesis: string;
        burnToken: string;
        burnCalldata: BytesLike$1;
        clientID: BytesLike$1;
    };
    type MetaRevertTransactionStructOutput = [
        BigNumber,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        string
    ] & {
        stableBridgingFee: BigNumber;
        internalID: string;
        receiveSide: string;
        managerChainBridge: string;
        sourceChainBridge: string;
        managerChainId: BigNumber;
        sourceChainId: BigNumber;
        router: string;
        swapCalldata: string;
        sourceChainSynthesis: string;
        burnToken: string;
        burnCalldata: string;
        clientID: string;
    };
    type MetaSynthesizeTransactionStruct = {
        stableBridgingFee: BigNumberish;
        amount: BigNumberish;
        rtoken: string;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        syntCaller: string;
        chainID: BigNumberish;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: BytesLike$1;
        finalReceiveSide: string;
        finalCalldata: BytesLike$1;
        finalOffset: BigNumberish;
        revertableAddress: string;
        clientID: BytesLike$1;
    };
    type MetaSynthesizeTransactionStructOutput = [
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        string[],
        string,
        string,
        string,
        string,
        BigNumber,
        string,
        string
    ] & {
        stableBridgingFee: BigNumber;
        amount: BigNumber;
        rtoken: string;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        syntCaller: string;
        chainID: BigNumber;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: string;
        finalReceiveSide: string;
        finalCalldata: string;
        finalOffset: BigNumber;
        revertableAddress: string;
        clientID: string;
    };
}
interface PortalInterface extends utils.Interface {
    contractName: 'Portal';
    functions: {
        'balanceOf(address)': FunctionFragment;
        'bridge()': FunctionFragment;
        'initialize(address,address,address,address,address)': FunctionFragment;
        'isTrustedForwarder(address)': FunctionFragment;
        'metaRevertRequest((uint256,bytes32,address,address,address,uint256,uint256,address,bytes,address,address,bytes,bytes32))': FunctionFragment;
        'metaRouter()': FunctionFragment;
        'metaSynthesize((uint256,uint256,address,address,address,address,address,uint256,address[],address,bytes,address,bytes,uint256,address,bytes32))': FunctionFragment;
        'metaUnsynthesize(uint256,bytes32,bytes32,address,uint256,address,address,bytes,uint256)': FunctionFragment;
        'owner()': FunctionFragment;
        'pause()': FunctionFragment;
        'paused()': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'requestCount()': FunctionFragment;
        'requests(bytes32)': FunctionFragment;
        'revertBurnRequest(uint256,bytes32,address,address,uint256,bytes32)': FunctionFragment;
        'revertSynthesize(uint256,bytes32)': FunctionFragment;
        'setMetaRouter(address)': FunctionFragment;
        'setTokenThreshold(address,uint256)': FunctionFragment;
        'setWhitelistToken(address,bool)': FunctionFragment;
        'synthesize(uint256,address,uint256,address,address,address,address,uint256,bytes32)': FunctionFragment;
        'synthesizeNative(uint256,address,address,address,address,uint256,bytes32)': FunctionFragment;
        'synthesizeWithPermit((uint256,bytes,address,uint256,address,address,address,address,uint256,bytes32))': FunctionFragment;
        'tokenThreshold(address)': FunctionFragment;
        'tokenWhitelist(address)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unpause()': FunctionFragment;
        'unsynthesize(uint256,bytes32,bytes32,address,uint256,address)': FunctionFragment;
        'unsynthesizeStates(bytes32)': FunctionFragment;
        'versionRecipient()': FunctionFragment;
        'wrapper()': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
    encodeFunctionData(functionFragment: 'bridge', values?: undefined): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string, string, string, string, string]): string;
    encodeFunctionData(functionFragment: 'isTrustedForwarder', values: [string]): string;
    encodeFunctionData(functionFragment: 'metaRevertRequest', values: [MetaRouteStructs$1.MetaRevertTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaRouter', values?: undefined): string;
    encodeFunctionData(functionFragment: 'metaSynthesize', values: [MetaRouteStructs$1.MetaSynthesizeTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaUnsynthesize', values: [BigNumberish, BytesLike$1, BytesLike$1, string, BigNumberish, string, string, BytesLike$1, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'requestCount', values?: undefined): string;
    encodeFunctionData(functionFragment: 'requests', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertBurnRequest', values: [BigNumberish, BytesLike$1, string, string, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertSynthesize', values: [BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'setMetaRouter', values: [string]): string;
    encodeFunctionData(functionFragment: 'setTokenThreshold', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setWhitelistToken', values: [string, boolean]): string;
    encodeFunctionData(functionFragment: 'synthesize', values: [BigNumberish, string, BigNumberish, string, string, string, string, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'synthesizeNative', values: [BigNumberish, string, string, string, string, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'synthesizeWithPermit', values: [Portal.SynthesizeWithPermitTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'tokenThreshold', values: [string]): string;
    encodeFunctionData(functionFragment: 'tokenWhitelist', values: [string]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'unsynthesize', values: [BigNumberish, BytesLike$1, BytesLike$1, string, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'unsynthesizeStates', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'versionRecipient', values?: undefined): string;
    encodeFunctionData(functionFragment: 'wrapper', values?: undefined): string;
    decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'bridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'isTrustedForwarder', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRevertRequest', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRouter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaSynthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaUnsynthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'pause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'paused', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'requestCount', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'requests', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertBurnRequest', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertSynthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setMetaRouter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setTokenThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setWhitelistToken', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesizeNative', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesizeWithPermit', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tokenThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tokenWhitelist', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unpause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unsynthesize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unsynthesizeStates', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'versionRecipient', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'wrapper', data: BytesLike$1): Result;
    events: {
        'BurnCompleted(bytes32,bytes32,address,uint256,uint256,address)': EventFragment;
        'ClientIdLog(bytes32,bytes32)': EventFragment;
        'MetaRevertRequest(bytes32,address)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'Paused(address)': EventFragment;
        'RevertBurnRequest(bytes32,address)': EventFragment;
        'RevertSynthesizeCompleted(bytes32,address,uint256,uint256,address)': EventFragment;
        'SetMetaRouter(address)': EventFragment;
        'SetTokenThreshold(address,uint256)': EventFragment;
        'SetWhitelistToken(address,bool)': EventFragment;
        'SynthesizeRequest(bytes32,address,uint256,address,address,uint256,address)': EventFragment;
        'Unpaused(address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'BurnCompleted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ClientIdLog'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'MetaRevertRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'RevertBurnRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'RevertSynthesizeCompleted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetMetaRouter'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetTokenThreshold'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetWhitelistToken'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SynthesizeRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}
type BurnCompletedEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    id: string;
    crossChainID: string;
    to: string;
    amount: BigNumber;
    bridgingFee: BigNumber;
    token: string;
}>;
type BurnCompletedEventFilter = TypedEventFilter<BurnCompletedEvent>;
type ClientIdLogEvent$1 = TypedEvent<[string, string], {
    requestId: string;
    clientId: string;
}>;
type ClientIdLogEventFilter$1 = TypedEventFilter<ClientIdLogEvent$1>;
type MetaRevertRequestEvent = TypedEvent<[string, string], {
    id: string;
    to: string;
}>;
type MetaRevertRequestEventFilter = TypedEventFilter<MetaRevertRequestEvent>;
type OwnershipTransferredEvent$2 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$2 = TypedEventFilter<OwnershipTransferredEvent$2>;
type PausedEvent$1 = TypedEvent<[string], {
    account: string;
}>;
type PausedEventFilter$1 = TypedEventFilter<PausedEvent$1>;
type RevertBurnRequestEvent = TypedEvent<[string, string], {
    id: string;
    to: string;
}>;
type RevertBurnRequestEventFilter = TypedEventFilter<RevertBurnRequestEvent>;
type RevertSynthesizeCompletedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    id: string;
    to: string;
    amount: BigNumber;
    bridgingFee: BigNumber;
    token: string;
}>;
type RevertSynthesizeCompletedEventFilter = TypedEventFilter<RevertSynthesizeCompletedEvent>;
type SetMetaRouterEvent$1 = TypedEvent<[string], {
    metaRouter: string;
}>;
type SetMetaRouterEventFilter$1 = TypedEventFilter<SetMetaRouterEvent$1>;
type SetTokenThresholdEvent$1 = TypedEvent<[string, BigNumber], {
    token: string;
    threshold: BigNumber;
}>;
type SetTokenThresholdEventFilter$1 = TypedEventFilter<SetTokenThresholdEvent$1>;
type SetWhitelistTokenEvent = TypedEvent<[string, boolean], {
    token: string;
    activate: boolean;
}>;
type SetWhitelistTokenEventFilter = TypedEventFilter<SetWhitelistTokenEvent>;
type SynthesizeRequestEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string,
    string,
    BigNumber,
    string
], {
    id: string;
    from: string;
    chainID: BigNumber;
    revertableAddress: string;
    to: string;
    amount: BigNumber;
    token: string;
}>;
type SynthesizeRequestEventFilter = TypedEventFilter<SynthesizeRequestEvent>;
type UnpausedEvent$1 = TypedEvent<[string], {
    account: string;
}>;
type UnpausedEventFilter$1 = TypedEventFilter<UnpausedEvent$1>;
declare namespace Portal {
    type SynthesizeWithPermitTransactionStruct = {
        stableBridgingFee: BigNumberish;
        approvalData: BytesLike$1;
        token: string;
        amount: BigNumberish;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        revertableAddress: string;
        chainID: BigNumberish;
        clientID: BytesLike$1;
    };
    type SynthesizeWithPermitTransactionStructOutput = [
        BigNumber,
        string,
        string,
        BigNumber,
        string,
        string,
        string,
        string,
        BigNumber,
        string
    ] & {
        stableBridgingFee: BigNumber;
        approvalData: string;
        token: string;
        amount: BigNumber;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        revertableAddress: string;
        chainID: BigNumber;
        clientID: string;
    };
}
interface Portal extends BaseContract {
    contractName: 'Portal';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: PortalInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        balanceOf(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        bridge(overrides?: CallOverrides): Promise<[string]>;
        initialize(_bridge: string, _trustedForwarder: string, _wrapper: string, _whitelistedToken: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<[boolean]>;
        metaRevertRequest(_metaRevertTransaction: MetaRouteStructs$1.MetaRevertTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<[string]>;
        metaSynthesize(_metaSynthesizeTransaction: MetaRouteStructs$1.MetaSynthesizeTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaUnsynthesize(_stableBridgingFee: BigNumberish, _crossChainID: BytesLike$1, _externalID: BytesLike$1, _to: string, _amount: BigNumberish, _rToken: string, _finalReceiveSide: string, _finalCalldata: BytesLike$1, _finalOffset: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        requestCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
            string,
            string,
            BigNumber,
            string,
            number
        ] & {
            recipient: string;
            chain2address: string;
            amount: BigNumber;
            rtoken: string;
            state: number;
        }>;
        revertBurnRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        revertSynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setWhitelistToken(_token: string, _activate: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        synthesize(_stableBridgingFee: BigNumberish, _token: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        synthesizeNative(_stableBridgingFee: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        synthesizeWithPermit(_syntWithPermitTx: Portal.SynthesizeWithPermitTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        tokenWhitelist(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unsynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _token: string, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unsynthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[number]>;
        versionRecipient(overrides?: CallOverrides): Promise<[string]>;
        wrapper(overrides?: CallOverrides): Promise<[string]>;
    };
    balanceOf(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    bridge(overrides?: CallOverrides): Promise<string>;
    initialize(_bridge: string, _trustedForwarder: string, _wrapper: string, _whitelistedToken: string, _metaRouter: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<boolean>;
    metaRevertRequest(_metaRevertTransaction: MetaRouteStructs$1.MetaRevertTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaRouter(overrides?: CallOverrides): Promise<string>;
    metaSynthesize(_metaSynthesizeTransaction: MetaRouteStructs$1.MetaSynthesizeTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaUnsynthesize(_stableBridgingFee: BigNumberish, _crossChainID: BytesLike$1, _externalID: BytesLike$1, _to: string, _amount: BigNumberish, _rToken: string, _finalReceiveSide: string, _finalCalldata: BytesLike$1, _finalOffset: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    pause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    paused(overrides?: CallOverrides): Promise<boolean>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    requestCount(overrides?: CallOverrides): Promise<BigNumber>;
    requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
        string,
        string,
        BigNumber,
        string,
        number
    ] & {
        recipient: string;
        chain2address: string;
        amount: BigNumber;
        rtoken: string;
        state: number;
    }>;
    revertBurnRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    revertSynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMetaRouter(_metaRouter: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setWhitelistToken(_token: string, _activate: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    synthesize(_stableBridgingFee: BigNumberish, _token: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    synthesizeNative(_stableBridgingFee: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    synthesizeWithPermit(_syntWithPermitTx: Portal.SynthesizeWithPermitTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    tokenWhitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unsynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _token: string, _amount: BigNumberish, _to: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unsynthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<number>;
    versionRecipient(overrides?: CallOverrides): Promise<string>;
    wrapper(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        balanceOf(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        bridge(overrides?: CallOverrides): Promise<string>;
        initialize(_bridge: string, _trustedForwarder: string, _wrapper: string, _whitelistedToken: string, _metaRouter: string, overrides?: CallOverrides): Promise<void>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<boolean>;
        metaRevertRequest(_metaRevertTransaction: MetaRouteStructs$1.MetaRevertTransactionStruct, overrides?: CallOverrides): Promise<void>;
        metaRouter(overrides?: CallOverrides): Promise<string>;
        metaSynthesize(_metaSynthesizeTransaction: MetaRouteStructs$1.MetaSynthesizeTransactionStruct, overrides?: CallOverrides): Promise<string>;
        metaUnsynthesize(_stableBridgingFee: BigNumberish, _crossChainID: BytesLike$1, _externalID: BytesLike$1, _to: string, _amount: BigNumberish, _rToken: string, _finalReceiveSide: string, _finalCalldata: BytesLike$1, _finalOffset: BigNumberish, overrides?: CallOverrides): Promise<void>;
        owner(overrides?: CallOverrides): Promise<string>;
        pause(overrides?: CallOverrides): Promise<void>;
        paused(overrides?: CallOverrides): Promise<boolean>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        requestCount(overrides?: CallOverrides): Promise<BigNumber>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
            string,
            string,
            BigNumber,
            string,
            number
        ] & {
            recipient: string;
            chain2address: string;
            amount: BigNumber;
            rtoken: string;
            state: number;
        }>;
        revertBurnRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        revertSynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        setMetaRouter(_metaRouter: string, overrides?: CallOverrides): Promise<void>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setWhitelistToken(_token: string, _activate: boolean, overrides?: CallOverrides): Promise<void>;
        synthesize(_stableBridgingFee: BigNumberish, _token: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<string>;
        synthesizeNative(_stableBridgingFee: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<string>;
        synthesizeWithPermit(_syntWithPermitTx: Portal.SynthesizeWithPermitTransactionStruct, overrides?: CallOverrides): Promise<string>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        tokenWhitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unpause(overrides?: CallOverrides): Promise<void>;
        unsynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _token: string, _amount: BigNumberish, _to: string, overrides?: CallOverrides): Promise<void>;
        unsynthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<number>;
        versionRecipient(overrides?: CallOverrides): Promise<string>;
        wrapper(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        'BurnCompleted(bytes32,bytes32,address,uint256,uint256,address)'(id?: BytesLike$1 | null, crossChainID?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): BurnCompletedEventFilter;
        BurnCompleted(id?: BytesLike$1 | null, crossChainID?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): BurnCompletedEventFilter;
        'ClientIdLog(bytes32,bytes32)'(requestId?: null, clientId?: BytesLike$1 | null): ClientIdLogEventFilter$1;
        ClientIdLog(requestId?: null, clientId?: BytesLike$1 | null): ClientIdLogEventFilter$1;
        'MetaRevertRequest(bytes32,address)'(id?: BytesLike$1 | null, to?: string | null): MetaRevertRequestEventFilter;
        MetaRevertRequest(id?: BytesLike$1 | null, to?: string | null): MetaRevertRequestEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$2;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$2;
        'Paused(address)'(account?: null): PausedEventFilter$1;
        Paused(account?: null): PausedEventFilter$1;
        'RevertBurnRequest(bytes32,address)'(id?: BytesLike$1 | null, to?: string | null): RevertBurnRequestEventFilter;
        RevertBurnRequest(id?: BytesLike$1 | null, to?: string | null): RevertBurnRequestEventFilter;
        'RevertSynthesizeCompleted(bytes32,address,uint256,uint256,address)'(id?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): RevertSynthesizeCompletedEventFilter;
        RevertSynthesizeCompleted(id?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): RevertSynthesizeCompletedEventFilter;
        'SetMetaRouter(address)'(metaRouter?: null): SetMetaRouterEventFilter$1;
        SetMetaRouter(metaRouter?: null): SetMetaRouterEventFilter$1;
        'SetTokenThreshold(address,uint256)'(token?: null, threshold?: null): SetTokenThresholdEventFilter$1;
        SetTokenThreshold(token?: null, threshold?: null): SetTokenThresholdEventFilter$1;
        'SetWhitelistToken(address,bool)'(token?: null, activate?: null): SetWhitelistTokenEventFilter;
        SetWhitelistToken(token?: null, activate?: null): SetWhitelistTokenEventFilter;
        'SynthesizeRequest(bytes32,address,uint256,address,address,uint256,address)'(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): SynthesizeRequestEventFilter;
        SynthesizeRequest(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): SynthesizeRequestEventFilter;
        'Unpaused(address)'(account?: null): UnpausedEventFilter$1;
        Unpaused(account?: null): UnpausedEventFilter$1;
    };
    estimateGas: {
        balanceOf(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        bridge(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_bridge: string, _trustedForwarder: string, _wrapper: string, _whitelistedToken: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<BigNumber>;
        metaRevertRequest(_metaRevertTransaction: MetaRouteStructs$1.MetaRevertTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaRouter(overrides?: CallOverrides): Promise<BigNumber>;
        metaSynthesize(_metaSynthesizeTransaction: MetaRouteStructs$1.MetaSynthesizeTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaUnsynthesize(_stableBridgingFee: BigNumberish, _crossChainID: BytesLike$1, _externalID: BytesLike$1, _to: string, _amount: BigNumberish, _rToken: string, _finalReceiveSide: string, _finalCalldata: BytesLike$1, _finalOffset: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        paused(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        requestCount(overrides?: CallOverrides): Promise<BigNumber>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        revertBurnRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        revertSynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setWhitelistToken(_token: string, _activate: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        synthesize(_stableBridgingFee: BigNumberish, _token: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        synthesizeNative(_stableBridgingFee: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        synthesizeWithPermit(_syntWithPermitTx: Portal.SynthesizeWithPermitTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        tokenWhitelist(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unsynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _token: string, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unsynthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        versionRecipient(overrides?: CallOverrides): Promise<BigNumber>;
        wrapper(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        balanceOf(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        bridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_bridge: string, _trustedForwarder: string, _wrapper: string, _whitelistedToken: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        metaRevertRequest(_metaRevertTransaction: MetaRouteStructs$1.MetaRevertTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        metaSynthesize(_metaSynthesizeTransaction: MetaRouteStructs$1.MetaSynthesizeTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaUnsynthesize(_stableBridgingFee: BigNumberish, _crossChainID: BytesLike$1, _externalID: BytesLike$1, _to: string, _amount: BigNumberish, _rToken: string, _finalReceiveSide: string, _finalCalldata: BytesLike$1, _finalOffset: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        requestCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        revertBurnRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainId: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        revertSynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setWhitelistToken(_token: string, _activate: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        synthesize(_stableBridgingFee: BigNumberish, _token: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        synthesizeNative(_stableBridgingFee: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        synthesizeWithPermit(_syntWithPermitTx: Portal.SynthesizeWithPermitTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenWhitelist(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unsynthesize(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _token: string, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unsynthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        versionRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        wrapper(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace DepositoryTypes$1 {
    type DepositStruct = {
        token: string;
        amount: BigNumberish;
        nonce: BigNumberish;
    };
    type DepositStructOutput = [string, BigNumber, BigNumber] & {
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
    };
}
interface SwapUnlockerInterface extends utils.Interface {
    contractName: 'SwapUnlocker';
    functions: {
        'decodeCondition(bytes)': FunctionFragment;
        'encodeCondition((address,uint256,address,bytes,uint256))': FunctionFragment;
        'encodeSolution((address,bytes))': FunctionFragment;
        'unlock(address,(address,uint256,uint256),bytes,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'decodeCondition', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'encodeCondition', values: [SwapUnlocker.ConditionStruct]): string;
    encodeFunctionData(functionFragment: 'encodeSolution', values: [SwapUnlocker.SolutionStruct]): string;
    encodeFunctionData(functionFragment: 'unlock', values: [string, DepositoryTypes$1.DepositStruct, BytesLike$1, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'decodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeSolution', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unlock', data: BytesLike$1): Result;
    events: {};
}
declare namespace SwapUnlocker {
    type ConditionStruct = {
        outToken: string;
        outMinAmount: BigNumberish;
        target: string;
        targetCalldata: BytesLike$1;
        targetOffset: BigNumberish;
    };
    type ConditionStructOutput = [string, BigNumber, string, string, BigNumber] & {
        outToken: string;
        outMinAmount: BigNumber;
        target: string;
        targetCalldata: string;
        targetOffset: BigNumber;
    };
    type SolutionStruct = {
        swapper: string;
        swapCalldata: BytesLike$1;
    };
    type SolutionStructOutput = [string, string] & {
        swapper: string;
        swapCalldata: string;
    };
}
interface SwapUnlocker extends BaseContract {
    contractName: 'SwapUnlocker';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: SwapUnlockerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<[SwapUnlocker.ConditionStructOutput]>;
        encodeCondition(c: SwapUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<[string]>;
        encodeSolution(s: SwapUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<[string]>;
        unlock(metarouter: string, deposit: DepositoryTypes$1.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<SwapUnlocker.ConditionStructOutput>;
    encodeCondition(c: SwapUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
    encodeSolution(s: SwapUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
    unlock(metarouter: string, deposit: DepositoryTypes$1.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<SwapUnlocker.ConditionStructOutput>;
        encodeCondition(c: SwapUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
        encodeSolution(s: SwapUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<string>;
        unlock(metarouter: string, deposit: DepositoryTypes$1.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        encodeCondition(c: SwapUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        encodeSolution(s: SwapUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        unlock(metarouter: string, deposit: DepositoryTypes$1.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeCondition(c: SwapUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeSolution(s: SwapUnlocker.SolutionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unlock(metarouter: string, deposit: DepositoryTypes$1.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace MetaRouteStructs {
    type MetaBurnTransactionStruct = {
        stableBridgingFee: BigNumberish;
        amount: BigNumberish;
        crossChainID: BytesLike$1;
        syntCaller: string;
        finalReceiveSide: string;
        sToken: string;
        finalCallData: BytesLike$1;
        finalOffset: BigNumberish;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        revertableAddress: string;
        chainID: BigNumberish;
        clientID: BytesLike$1;
    };
    type MetaBurnTransactionStructOutput = [
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        string,
        string,
        string,
        string,
        BigNumber,
        string
    ] & {
        stableBridgingFee: BigNumber;
        amount: BigNumber;
        crossChainID: string;
        syntCaller: string;
        finalReceiveSide: string;
        sToken: string;
        finalCallData: string;
        finalOffset: BigNumber;
        chain2address: string;
        receiveSide: string;
        oppositeBridge: string;
        revertableAddress: string;
        chainID: BigNumber;
        clientID: string;
    };
    type MetaMintTransactionStruct = {
        stableBridgingFee: BigNumberish;
        amount: BigNumberish;
        crossChainID: BytesLike$1;
        externalID: BytesLike$1;
        tokenReal: string;
        chainID: BigNumberish;
        to: string;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: BytesLike$1;
        finalReceiveSide: string;
        finalCalldata: BytesLike$1;
        finalOffset: BigNumberish;
    };
    type MetaMintTransactionStructOutput = [
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        BigNumber,
        string,
        string[],
        string,
        string,
        string,
        string,
        BigNumber
    ] & {
        stableBridgingFee: BigNumber;
        amount: BigNumber;
        crossChainID: string;
        externalID: string;
        tokenReal: string;
        chainID: BigNumber;
        to: string;
        swapTokens: string[];
        secondDexRouter: string;
        secondSwapCalldata: string;
        finalReceiveSide: string;
        finalCalldata: string;
        finalOffset: BigNumber;
    };
    type MetaMintTransactionBTCStruct = {
        stableBridgingFee: BigNumberish;
        amount: BigNumberish;
        serial: BigNumberish;
        crossChainID: BytesLike$1;
        externalID: BytesLike$1;
        tokenReal: string;
        chainID: BigNumberish;
        to: string;
        receiveSide: string;
        receiveSideCalldata: BytesLike$1;
        receiveSideOffset: BigNumberish;
    };
    type MetaMintTransactionBTCStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        BigNumber,
        string,
        string,
        string,
        BigNumber
    ] & {
        stableBridgingFee: BigNumber;
        amount: BigNumber;
        serial: BigNumber;
        crossChainID: string;
        externalID: string;
        tokenReal: string;
        chainID: BigNumber;
        to: string;
        receiveSide: string;
        receiveSideCalldata: string;
        receiveSideOffset: BigNumber;
    };
}
interface SynthesisInterface extends utils.Interface {
    contractName: 'Synthesis';
    functions: {
        'bridge()': FunctionFragment;
        'burnSyntheticToken(uint256,address,uint256,address,address,address,address,uint256,bytes32)': FunctionFragment;
        'burnSyntheticTokenBTC(uint256,uint256,bytes,address,bytes32)': FunctionFragment;
        'burnSyntheticTokenTON(uint256,address,uint256,bytes32,(int8,bytes32),address,address,address,uint256,bytes32)': FunctionFragment;
        'fabric()': FunctionFragment;
        'initialize(address,address,address)': FunctionFragment;
        'isTrustedForwarder(address)': FunctionFragment;
        'metaBurnSyntheticToken((uint256,uint256,bytes32,address,address,address,bytes,uint256,address,address,address,address,uint256,bytes32))': FunctionFragment;
        'metaMintSyntheticToken((uint256,uint256,bytes32,bytes32,address,uint256,address,address[],address,bytes,address,bytes,uint256))': FunctionFragment;
        'metaMintSyntheticTokenBTC((uint256,uint256,uint64,bytes32,bytes32,address,uint256,address,address,bytes,uint256))': FunctionFragment;
        'metaRouter()': FunctionFragment;
        'mintSyntheticToken(uint256,bytes32,bytes32,address,uint256,uint256,address)': FunctionFragment;
        'owner()': FunctionFragment;
        'pause()': FunctionFragment;
        'paused()': FunctionFragment;
        'realToBurnSerialBTC(address)': FunctionFragment;
        'realToMintSerialBTC(address)': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'requestCount()': FunctionFragment;
        'requests(bytes32)': FunctionFragment;
        'revertBurn(uint256,bytes32)': FunctionFragment;
        'revertBurnAndBurn(uint256,bytes32,address,address,uint256,address)': FunctionFragment;
        'revertMetaBurn(uint256,bytes32,address,bytes,address,address,bytes)': FunctionFragment;
        'revertSynthesizeRequest(uint256,bytes32,address,address,uint256,bytes32)': FunctionFragment;
        'revertSynthesizeRequestByBridge(uint256,bytes32,address,address,uint256,address,bytes32)': FunctionFragment;
        'setFabric(address)': FunctionFragment;
        'setMetaRouter(address)': FunctionFragment;
        'setMinFeeBTC(address,uint256)': FunctionFragment;
        'setTokenThreshold(address,uint256)': FunctionFragment;
        'syntToMinFeeBTC(address)': FunctionFragment;
        'synthesizeStates(bytes32)': FunctionFragment;
        'tokenThreshold(address)': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
        'unpause()': FunctionFragment;
        'versionRecipient()': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'bridge', values?: undefined): string;
    encodeFunctionData(functionFragment: 'burnSyntheticToken', values: [BigNumberish, string, BigNumberish, string, string, string, string, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'burnSyntheticTokenBTC', values: [BigNumberish, BigNumberish, BytesLike$1, string, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'burnSyntheticTokenTON', values: [
        BigNumberish,
        string,
        BigNumberish,
        BytesLike$1,
        Synthesis.TonAddressStruct,
        string,
        string,
        string,
        BigNumberish,
        BytesLike$1
    ]): string;
    encodeFunctionData(functionFragment: 'fabric', values?: undefined): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string, string, string]): string;
    encodeFunctionData(functionFragment: 'isTrustedForwarder', values: [string]): string;
    encodeFunctionData(functionFragment: 'metaBurnSyntheticToken', values: [MetaRouteStructs.MetaBurnTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaMintSyntheticToken', values: [MetaRouteStructs.MetaMintTransactionStruct]): string;
    encodeFunctionData(functionFragment: 'metaMintSyntheticTokenBTC', values: [MetaRouteStructs.MetaMintTransactionBTCStruct]): string;
    encodeFunctionData(functionFragment: 'metaRouter', values?: undefined): string;
    encodeFunctionData(functionFragment: 'mintSyntheticToken', values: [BigNumberish, BytesLike$1, BytesLike$1, string, BigNumberish, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
    encodeFunctionData(functionFragment: 'realToBurnSerialBTC', values: [string]): string;
    encodeFunctionData(functionFragment: 'realToMintSerialBTC', values: [string]): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'requestCount', values?: undefined): string;
    encodeFunctionData(functionFragment: 'requests', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertBurn', values: [BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertBurnAndBurn', values: [BigNumberish, BytesLike$1, string, string, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'revertMetaBurn', values: [BigNumberish, BytesLike$1, string, BytesLike$1, string, string, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertSynthesizeRequest', values: [BigNumberish, BytesLike$1, string, string, BigNumberish, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'revertSynthesizeRequestByBridge', values: [BigNumberish, BytesLike$1, string, string, BigNumberish, string, BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'setFabric', values: [string]): string;
    encodeFunctionData(functionFragment: 'setMetaRouter', values: [string]): string;
    encodeFunctionData(functionFragment: 'setMinFeeBTC', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setTokenThreshold', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'syntToMinFeeBTC', values: [string]): string;
    encodeFunctionData(functionFragment: 'synthesizeStates', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'tokenThreshold', values: [string]): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
    encodeFunctionData(functionFragment: 'versionRecipient', values?: undefined): string;
    decodeFunctionResult(functionFragment: 'bridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'burnSyntheticToken', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'burnSyntheticTokenBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'burnSyntheticTokenTON', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'fabric', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'isTrustedForwarder', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaBurnSyntheticToken', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaMintSyntheticToken', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaMintSyntheticTokenBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'metaRouter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'mintSyntheticToken', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'pause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'paused', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'realToBurnSerialBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'realToMintSerialBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'requestCount', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'requests', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertBurn', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertBurnAndBurn', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertMetaBurn', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertSynthesizeRequest', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'revertSynthesizeRequestByBridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setFabric', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setMetaRouter', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setMinFeeBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'setTokenThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'syntToMinFeeBTC', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'synthesizeStates', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tokenThreshold', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unpause', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'versionRecipient', data: BytesLike$1): Result;
    events: {
        'BTCSynthesizeCompleted(bytes32,address,uint256,uint64,uint256,address)': EventFragment;
        'BurnRequest(bytes32,address,uint256,address,address,uint256,address)': EventFragment;
        'BurnRequestBTC(uint64,address,bytes,uint256,uint256,address)': EventFragment;
        'BurnRequestTON(bytes32,address,uint256,address,tuple,uint256,address)': EventFragment;
        'ClientIdLog(bytes32,bytes32)': EventFragment;
        'ClientIdLogBTC(uint64,bytes32)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
        'Paused(address)': EventFragment;
        'RevertBurnCompleted(bytes32,address,uint256,uint256,address)': EventFragment;
        'RevertSynthesizeRequest(bytes32,address)': EventFragment;
        'SetFabric(address)': EventFragment;
        'SetMetaRouter(address)': EventFragment;
        'SetMinFeeBTC(uint256)': EventFragment;
        'SetTokenThreshold(address,uint256)': EventFragment;
        'SynthesizeCompleted(bytes32,address,bytes32,uint256,uint256,address)': EventFragment;
        'Unpaused(address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'BTCSynthesizeCompleted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'BurnRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'BurnRequestBTC'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'BurnRequestTON'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ClientIdLog'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ClientIdLogBTC'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'RevertBurnCompleted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'RevertSynthesizeRequest'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetFabric'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetMetaRouter'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetMinFeeBTC'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SetTokenThreshold'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'SynthesizeCompleted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}
type BTCSynthesizeCompletedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string
], {
    id: string;
    to: string;
    amount: BigNumber;
    serial: BigNumber;
    bridgingFee: BigNumber;
    token: string;
}>;
type BTCSynthesizeCompletedEventFilter = TypedEventFilter<BTCSynthesizeCompletedEvent>;
type BurnRequestEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string,
    string,
    BigNumber,
    string
], {
    id: string;
    from: string;
    chainID: BigNumber;
    revertableAddress: string;
    to: string;
    amount: BigNumber;
    token: string;
}>;
type BurnRequestEventFilter = TypedEventFilter<BurnRequestEvent>;
type BurnRequestBTCEvent = TypedEvent<[
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    burnSerial: BigNumber;
    from: string;
    to: string;
    amount: BigNumber;
    stableBridgingFee: BigNumber;
    rtoken: string;
}>;
type BurnRequestBTCEventFilter = TypedEventFilter<BurnRequestBTCEvent>;
type BurnRequestTONEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    string,
    Synthesis.TonAddressStructOutput,
    BigNumber,
    string
], {
    id: string;
    from: string;
    chainID: BigNumber;
    revertableAddress: string;
    to: Synthesis.TonAddressStructOutput;
    amount: BigNumber;
    token: string;
}>;
type BurnRequestTONEventFilter = TypedEventFilter<BurnRequestTONEvent>;
type ClientIdLogEvent = TypedEvent<[string, string], {
    requestId: string;
    clientId: string;
}>;
type ClientIdLogEventFilter = TypedEventFilter<ClientIdLogEvent>;
type ClientIdLogBTCEvent = TypedEvent<[BigNumber, string], {
    burnSerial: BigNumber;
    clientId: string;
}>;
type ClientIdLogBTCEventFilter = TypedEventFilter<ClientIdLogBTCEvent>;
type OwnershipTransferredEvent$1 = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter$1 = TypedEventFilter<OwnershipTransferredEvent$1>;
type PausedEvent = TypedEvent<[string], {
    account: string;
}>;
type PausedEventFilter = TypedEventFilter<PausedEvent>;
type RevertBurnCompletedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    id: string;
    to: string;
    amount: BigNumber;
    bridgingFee: BigNumber;
    token: string;
}>;
type RevertBurnCompletedEventFilter = TypedEventFilter<RevertBurnCompletedEvent>;
type RevertSynthesizeRequestEvent = TypedEvent<[string, string], {
    id: string;
    to: string;
}>;
type RevertSynthesizeRequestEventFilter = TypedEventFilter<RevertSynthesizeRequestEvent>;
type SetFabricEvent = TypedEvent<[string], {
    fabric: string;
}>;
type SetFabricEventFilter = TypedEventFilter<SetFabricEvent>;
type SetMetaRouterEvent = TypedEvent<[string], {
    metaRouter: string;
}>;
type SetMetaRouterEventFilter = TypedEventFilter<SetMetaRouterEvent>;
type SetMinFeeBTCEvent = TypedEvent<[BigNumber], {
    minFee: BigNumber;
}>;
type SetMinFeeBTCEventFilter = TypedEventFilter<SetMinFeeBTCEvent>;
type SetTokenThresholdEvent = TypedEvent<[string, BigNumber], {
    token: string;
    threshold: BigNumber;
}>;
type SetTokenThresholdEventFilter = TypedEventFilter<SetTokenThresholdEvent>;
type SynthesizeCompletedEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
], {
    id: string;
    to: string;
    crossChainID: string;
    amount: BigNumber;
    bridgingFee: BigNumber;
    token: string;
}>;
type SynthesizeCompletedEventFilter = TypedEventFilter<SynthesizeCompletedEvent>;
type UnpausedEvent = TypedEvent<[string], {
    account: string;
}>;
type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;
declare namespace Synthesis {
    type TonAddressStruct = {
        workchain: BigNumberish;
        address_hash: BytesLike$1;
    };
    type TonAddressStructOutput = [number, string] & {
        workchain: number;
        address_hash: string;
    };
}
interface Synthesis extends BaseContract {
    contractName: 'Synthesis';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: SynthesisInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        bridge(overrides?: CallOverrides): Promise<[string]>;
        burnSyntheticToken(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        burnSyntheticTokenBTC(_stableBridgingFee: BigNumberish, _amount: BigNumberish, _to: BytesLike$1, _stoken: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        burnSyntheticTokenTON(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _crossChainID: BytesLike$1, _chain2address: Synthesis.TonAddressStruct, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        fabric(overrides?: CallOverrides): Promise<[string]>;
        initialize(_bridge: string, _trustedForwarder: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<[boolean]>;
        metaBurnSyntheticToken(_metaBurnTransaction: MetaRouteStructs.MetaBurnTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaMintSyntheticToken(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaMintSyntheticTokenBTC(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionBTCStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<[string]>;
        mintSyntheticToken(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _tokenReal: string, _chainID: BigNumberish, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        realToBurnSerialBTC(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        realToMintSerialBTC(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        requestCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
            string,
            string,
            BigNumber,
            string,
            string,
            number
        ] & {
            recipient: string;
            chain2address: string;
            amount: BigNumber;
            token: string;
            stoken: string;
            state: number;
        }>;
        revertBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        revertBurnAndBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _revertableAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        revertMetaBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _router: string, _swapCalldata: BytesLike$1, _synthesis: string, _burnToken: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        revertSynthesizeRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        revertSynthesizeRequestByBridge(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _sender: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setFabric(_fabric: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMinFeeBTC(_synt: string, _minFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        syntToMinFeeBTC(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        synthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[number]>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        versionRecipient(overrides?: CallOverrides): Promise<[string]>;
    };
    bridge(overrides?: CallOverrides): Promise<string>;
    burnSyntheticToken(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    burnSyntheticTokenBTC(_stableBridgingFee: BigNumberish, _amount: BigNumberish, _to: BytesLike$1, _stoken: string, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    burnSyntheticTokenTON(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _crossChainID: BytesLike$1, _chain2address: Synthesis.TonAddressStruct, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    fabric(overrides?: CallOverrides): Promise<string>;
    initialize(_bridge: string, _trustedForwarder: string, _metaRouter: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<boolean>;
    metaBurnSyntheticToken(_metaBurnTransaction: MetaRouteStructs.MetaBurnTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaMintSyntheticToken(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaMintSyntheticTokenBTC(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionBTCStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    metaRouter(overrides?: CallOverrides): Promise<string>;
    mintSyntheticToken(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _tokenReal: string, _chainID: BigNumberish, _amount: BigNumberish, _to: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    pause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    paused(overrides?: CallOverrides): Promise<boolean>;
    realToBurnSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    realToMintSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    requestCount(overrides?: CallOverrides): Promise<BigNumber>;
    requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
        string,
        string,
        BigNumber,
        string,
        string,
        number
    ] & {
        recipient: string;
        chain2address: string;
        amount: BigNumber;
        token: string;
        stoken: string;
        state: number;
    }>;
    revertBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    revertBurnAndBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _revertableAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    revertMetaBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _router: string, _swapCalldata: BytesLike$1, _synthesis: string, _burnToken: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    revertSynthesizeRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    revertSynthesizeRequestByBridge(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _sender: string, _clientID: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setFabric(_fabric: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMetaRouter(_metaRouter: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMinFeeBTC(_synt: string, _minFee: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    syntToMinFeeBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    synthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<number>;
    tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    versionRecipient(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        bridge(overrides?: CallOverrides): Promise<string>;
        burnSyntheticToken(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<string>;
        burnSyntheticTokenBTC(_stableBridgingFee: BigNumberish, _amount: BigNumberish, _to: BytesLike$1, _stoken: string, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        burnSyntheticTokenTON(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _crossChainID: BytesLike$1, _chain2address: Synthesis.TonAddressStruct, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<string>;
        fabric(overrides?: CallOverrides): Promise<string>;
        initialize(_bridge: string, _trustedForwarder: string, _metaRouter: string, overrides?: CallOverrides): Promise<void>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<boolean>;
        metaBurnSyntheticToken(_metaBurnTransaction: MetaRouteStructs.MetaBurnTransactionStruct, overrides?: CallOverrides): Promise<string>;
        metaMintSyntheticToken(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionStruct, overrides?: CallOverrides): Promise<void>;
        metaMintSyntheticTokenBTC(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionBTCStruct, overrides?: CallOverrides): Promise<void>;
        metaRouter(overrides?: CallOverrides): Promise<string>;
        mintSyntheticToken(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _tokenReal: string, _chainID: BigNumberish, _amount: BigNumberish, _to: string, overrides?: CallOverrides): Promise<void>;
        owner(overrides?: CallOverrides): Promise<string>;
        pause(overrides?: CallOverrides): Promise<void>;
        paused(overrides?: CallOverrides): Promise<boolean>;
        realToBurnSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        realToMintSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        requestCount(overrides?: CallOverrides): Promise<BigNumber>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<[
            string,
            string,
            BigNumber,
            string,
            string,
            number
        ] & {
            recipient: string;
            chain2address: string;
            amount: BigNumber;
            token: string;
            stoken: string;
            state: number;
        }>;
        revertBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        revertBurnAndBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _revertableAddress: string, overrides?: CallOverrides): Promise<void>;
        revertMetaBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _router: string, _swapCalldata: BytesLike$1, _synthesis: string, _burnToken: string, _burnCalldata: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        revertSynthesizeRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        revertSynthesizeRequestByBridge(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _sender: string, _clientID: BytesLike$1, overrides?: CallOverrides): Promise<void>;
        setFabric(_fabric: string, overrides?: CallOverrides): Promise<void>;
        setMetaRouter(_metaRouter: string, overrides?: CallOverrides): Promise<void>;
        setMinFeeBTC(_synt: string, _minFee: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: CallOverrides): Promise<void>;
        syntToMinFeeBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        synthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<number>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
        unpause(overrides?: CallOverrides): Promise<void>;
        versionRecipient(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        'BTCSynthesizeCompleted(bytes32,address,uint256,uint64,uint256,address)'(id?: BytesLike$1 | null, to?: string | null, amount?: null, serial?: null, bridgingFee?: null, token?: string | null): BTCSynthesizeCompletedEventFilter;
        BTCSynthesizeCompleted(id?: BytesLike$1 | null, to?: string | null, amount?: null, serial?: null, bridgingFee?: null, token?: string | null): BTCSynthesizeCompletedEventFilter;
        'BurnRequest(bytes32,address,uint256,address,address,uint256,address)'(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): BurnRequestEventFilter;
        BurnRequest(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): BurnRequestEventFilter;
        'BurnRequestBTC(uint64,address,bytes,uint256,uint256,address)'(burnSerial?: null, from?: string | null, to?: null, amount?: null, stableBridgingFee?: null, rtoken?: string | null): BurnRequestBTCEventFilter;
        BurnRequestBTC(burnSerial?: null, from?: string | null, to?: null, amount?: null, stableBridgingFee?: null, rtoken?: string | null): BurnRequestBTCEventFilter;
        'BurnRequestTON(bytes32,address,uint256,address,tuple,uint256,address)'(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): BurnRequestTONEventFilter;
        BurnRequestTON(id?: null, from?: string | null, chainID?: BigNumberish | null, revertableAddress?: string | null, to?: null, amount?: null, token?: null): BurnRequestTONEventFilter;
        'ClientIdLog(bytes32,bytes32)'(requestId?: null, clientId?: BytesLike$1 | null): ClientIdLogEventFilter;
        ClientIdLog(requestId?: null, clientId?: BytesLike$1 | null): ClientIdLogEventFilter;
        'ClientIdLogBTC(uint64,bytes32)'(burnSerial?: null, clientId?: BytesLike$1 | null): ClientIdLogBTCEventFilter;
        ClientIdLogBTC(burnSerial?: null, clientId?: BytesLike$1 | null): ClientIdLogBTCEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$1;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter$1;
        'Paused(address)'(account?: null): PausedEventFilter;
        Paused(account?: null): PausedEventFilter;
        'RevertBurnCompleted(bytes32,address,uint256,uint256,address)'(id?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): RevertBurnCompletedEventFilter;
        RevertBurnCompleted(id?: BytesLike$1 | null, to?: string | null, amount?: null, bridgingFee?: null, token?: null): RevertBurnCompletedEventFilter;
        'RevertSynthesizeRequest(bytes32,address)'(id?: BytesLike$1 | null, to?: string | null): RevertSynthesizeRequestEventFilter;
        RevertSynthesizeRequest(id?: BytesLike$1 | null, to?: string | null): RevertSynthesizeRequestEventFilter;
        'SetFabric(address)'(fabric?: null): SetFabricEventFilter;
        SetFabric(fabric?: null): SetFabricEventFilter;
        'SetMetaRouter(address)'(metaRouter?: null): SetMetaRouterEventFilter;
        SetMetaRouter(metaRouter?: null): SetMetaRouterEventFilter;
        'SetMinFeeBTC(uint256)'(minFee?: null): SetMinFeeBTCEventFilter;
        SetMinFeeBTC(minFee?: null): SetMinFeeBTCEventFilter;
        'SetTokenThreshold(address,uint256)'(token?: null, threshold?: null): SetTokenThresholdEventFilter;
        SetTokenThreshold(token?: null, threshold?: null): SetTokenThresholdEventFilter;
        'SynthesizeCompleted(bytes32,address,bytes32,uint256,uint256,address)'(id?: BytesLike$1 | null, to?: string | null, crossChainID?: BytesLike$1 | null, amount?: null, bridgingFee?: null, token?: null): SynthesizeCompletedEventFilter;
        SynthesizeCompleted(id?: BytesLike$1 | null, to?: string | null, crossChainID?: BytesLike$1 | null, amount?: null, bridgingFee?: null, token?: null): SynthesizeCompletedEventFilter;
        'Unpaused(address)'(account?: null): UnpausedEventFilter;
        Unpaused(account?: null): UnpausedEventFilter;
    };
    estimateGas: {
        bridge(overrides?: CallOverrides): Promise<BigNumber>;
        burnSyntheticToken(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        burnSyntheticTokenBTC(_stableBridgingFee: BigNumberish, _amount: BigNumberish, _to: BytesLike$1, _stoken: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        burnSyntheticTokenTON(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _crossChainID: BytesLike$1, _chain2address: Synthesis.TonAddressStruct, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        fabric(overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_bridge: string, _trustedForwarder: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<BigNumber>;
        metaBurnSyntheticToken(_metaBurnTransaction: MetaRouteStructs.MetaBurnTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaMintSyntheticToken(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaMintSyntheticTokenBTC(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionBTCStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        metaRouter(overrides?: CallOverrides): Promise<BigNumber>;
        mintSyntheticToken(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _tokenReal: string, _chainID: BigNumberish, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        paused(overrides?: CallOverrides): Promise<BigNumber>;
        realToBurnSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        realToMintSerialBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        requestCount(overrides?: CallOverrides): Promise<BigNumber>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        revertBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        revertBurnAndBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _revertableAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        revertMetaBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _router: string, _swapCalldata: BytesLike$1, _synthesis: string, _burnToken: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        revertSynthesizeRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        revertSynthesizeRequestByBridge(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _sender: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setFabric(_fabric: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMinFeeBTC(_synt: string, _minFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        syntToMinFeeBTC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        synthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        versionRecipient(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        bridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        burnSyntheticToken(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _chain2address: string, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        burnSyntheticTokenBTC(_stableBridgingFee: BigNumberish, _amount: BigNumberish, _to: BytesLike$1, _stoken: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        burnSyntheticTokenTON(_stableBridgingFee: BigNumberish, _stoken: string, _amount: BigNumberish, _crossChainID: BytesLike$1, _chain2address: Synthesis.TonAddressStruct, _receiveSide: string, _oppositeBridge: string, _revertableAddress: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        fabric(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_bridge: string, _trustedForwarder: string, _metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isTrustedForwarder(forwarder: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        metaBurnSyntheticToken(_metaBurnTransaction: MetaRouteStructs.MetaBurnTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaMintSyntheticToken(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaMintSyntheticTokenBTC(_metaMintTransaction: MetaRouteStructs.MetaMintTransactionBTCStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        metaRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mintSyntheticToken(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _crossChainID: BytesLike$1, _tokenReal: string, _chainID: BigNumberish, _amount: BigNumberish, _to: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        realToBurnSerialBTC(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        realToMintSerialBTC(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        requestCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requests(arg0: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        revertBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        revertBurnAndBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _revertableAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        revertMetaBurn(_stableBridgingFee: BigNumberish, _externalID: BytesLike$1, _router: string, _swapCalldata: BytesLike$1, _synthesis: string, _burnToken: string, _burnCalldata: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        revertSynthesizeRequest(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        revertSynthesizeRequestByBridge(_stableBridgingFee: BigNumberish, _internalID: BytesLike$1, _receiveSide: string, _oppositeBridge: string, _chainID: BigNumberish, _sender: string, _clientID: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setFabric(_fabric: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMetaRouter(_metaRouter: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMinFeeBTC(_synt: string, _minFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setTokenThreshold(_token: string, _threshold: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        syntToMinFeeBTC(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        synthesizeStates(arg0: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenThreshold(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        versionRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface TonBridgeInterface extends utils.Interface {
    contractName: 'TonBridge';
    functions: {
        'bridgeChainId()': FunctionFragment;
        'broadcaster()': FunctionFragment;
        'callBridgeRequest(uint256,(int8,bytes32))': FunctionFragment;
        'changeBridgeChainId(uint256)': FunctionFragment;
        'changeBroadcaster(address)': FunctionFragment;
        'changeSymbiosisBridge(address)': FunctionFragment;
        'changeTonBridge(address)': FunctionFragment;
        'initialize(address,address,uint256,address)': FunctionFragment;
        'owner()': FunctionFragment;
        'renounceOwnership()': FunctionFragment;
        'symbiosisBridge()': FunctionFragment;
        'tonBridge()': FunctionFragment;
        'transferOwnership(address)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'bridgeChainId', values?: undefined): string;
    encodeFunctionData(functionFragment: 'broadcaster', values?: undefined): string;
    encodeFunctionData(functionFragment: 'callBridgeRequest', values: [BigNumberish, TonBridge.TonAddressStruct]): string;
    encodeFunctionData(functionFragment: 'changeBridgeChainId', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'changeBroadcaster', values: [string]): string;
    encodeFunctionData(functionFragment: 'changeSymbiosisBridge', values: [string]): string;
    encodeFunctionData(functionFragment: 'changeTonBridge', values: [string]): string;
    encodeFunctionData(functionFragment: 'initialize', values: [string, string, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'symbiosisBridge', values?: undefined): string;
    encodeFunctionData(functionFragment: 'tonBridge', values?: undefined): string;
    encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
    decodeFunctionResult(functionFragment: 'bridgeChainId', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'broadcaster', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'callBridgeRequest', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeBridgeChainId', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeBroadcaster', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeSymbiosisBridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'changeTonBridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'initialize', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'symbiosisBridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'tonBridge', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike$1): Result;
    events: {
        'ChangeBridgeChainId(uint256)': EventFragment;
        'ChangeBroadcaster(address)': EventFragment;
        'ChangeSymbiosisBridge(address)': EventFragment;
        'ChangeTonBridge(address)': EventFragment;
        'OwnershipTransferred(address,address)': EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: 'ChangeBridgeChainId'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ChangeBroadcaster'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ChangeSymbiosisBridge'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ChangeTonBridge'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
}
type ChangeBridgeChainIdEvent = TypedEvent<[BigNumber], {
    newBridgeChainId: BigNumber;
}>;
type ChangeBridgeChainIdEventFilter = TypedEventFilter<ChangeBridgeChainIdEvent>;
type ChangeBroadcasterEvent = TypedEvent<[string], {
    newBroadcaster: string;
}>;
type ChangeBroadcasterEventFilter = TypedEventFilter<ChangeBroadcasterEvent>;
type ChangeSymbiosisBridgeEvent = TypedEvent<[string], {
    newBridge: string;
}>;
type ChangeSymbiosisBridgeEventFilter = TypedEventFilter<ChangeSymbiosisBridgeEvent>;
type ChangeTonBridgeEvent = TypedEvent<[string], {
    newBridge: string;
}>;
type ChangeTonBridgeEventFilter = TypedEventFilter<ChangeTonBridgeEvent>;
type OwnershipTransferredEvent = TypedEvent<[string, string], {
    previousOwner: string;
    newOwner: string;
}>;
type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;
declare namespace TonBridge {
    type TonAddressStruct = {
        workchain: BigNumberish;
        address_hash: BytesLike$1;
    };
    type TonAddressStructOutput = [number, string] & {
        workchain: number;
        address_hash: string;
    };
}
interface TonBridge extends BaseContract {
    contractName: 'TonBridge';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: TonBridgeInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        bridgeChainId(overrides?: CallOverrides): Promise<[BigNumber]>;
        broadcaster(overrides?: CallOverrides): Promise<[string]>;
        callBridgeRequest(_amount: BigNumberish, _tonAddress: TonBridge.TonAddressStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeBridgeChainId(_newBridgeChainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeBroadcaster(_newBroadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeSymbiosisBridge(_newSymbiosisBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        changeTonBridge(_newTonBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        initialize(_tonBridge: string, _symbiosisBridge: string, _bridgeChainId: BigNumberish, _broadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        symbiosisBridge(overrides?: CallOverrides): Promise<[string]>;
        tonBridge(overrides?: CallOverrides): Promise<[string]>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    bridgeChainId(overrides?: CallOverrides): Promise<BigNumber>;
    broadcaster(overrides?: CallOverrides): Promise<string>;
    callBridgeRequest(_amount: BigNumberish, _tonAddress: TonBridge.TonAddressStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeBridgeChainId(_newBridgeChainId: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeBroadcaster(_newBroadcaster: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeSymbiosisBridge(_newSymbiosisBridge: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    changeTonBridge(_newTonBridge: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    initialize(_tonBridge: string, _symbiosisBridge: string, _bridgeChainId: BigNumberish, _broadcaster: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    renounceOwnership(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    symbiosisBridge(overrides?: CallOverrides): Promise<string>;
    tonBridge(overrides?: CallOverrides): Promise<string>;
    transferOwnership(newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        bridgeChainId(overrides?: CallOverrides): Promise<BigNumber>;
        broadcaster(overrides?: CallOverrides): Promise<string>;
        callBridgeRequest(_amount: BigNumberish, _tonAddress: TonBridge.TonAddressStruct, overrides?: CallOverrides): Promise<void>;
        changeBridgeChainId(_newBridgeChainId: BigNumberish, overrides?: CallOverrides): Promise<void>;
        changeBroadcaster(_newBroadcaster: string, overrides?: CallOverrides): Promise<void>;
        changeSymbiosisBridge(_newSymbiosisBridge: string, overrides?: CallOverrides): Promise<void>;
        changeTonBridge(_newTonBridge: string, overrides?: CallOverrides): Promise<void>;
        initialize(_tonBridge: string, _symbiosisBridge: string, _bridgeChainId: BigNumberish, _broadcaster: string, overrides?: CallOverrides): Promise<void>;
        owner(overrides?: CallOverrides): Promise<string>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        symbiosisBridge(overrides?: CallOverrides): Promise<string>;
        tonBridge(overrides?: CallOverrides): Promise<string>;
        transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        'ChangeBridgeChainId(uint256)'(newBridgeChainId?: null): ChangeBridgeChainIdEventFilter;
        ChangeBridgeChainId(newBridgeChainId?: null): ChangeBridgeChainIdEventFilter;
        'ChangeBroadcaster(address)'(newBroadcaster?: null): ChangeBroadcasterEventFilter;
        ChangeBroadcaster(newBroadcaster?: null): ChangeBroadcasterEventFilter;
        'ChangeSymbiosisBridge(address)'(newBridge?: null): ChangeSymbiosisBridgeEventFilter;
        ChangeSymbiosisBridge(newBridge?: null): ChangeSymbiosisBridgeEventFilter;
        'ChangeTonBridge(address)'(newBridge?: null): ChangeTonBridgeEventFilter;
        ChangeTonBridge(newBridge?: null): ChangeTonBridgeEventFilter;
        'OwnershipTransferred(address,address)'(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter;
        OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter;
    };
    estimateGas: {
        bridgeChainId(overrides?: CallOverrides): Promise<BigNumber>;
        broadcaster(overrides?: CallOverrides): Promise<BigNumber>;
        callBridgeRequest(_amount: BigNumberish, _tonAddress: TonBridge.TonAddressStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeBridgeChainId(_newBridgeChainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeBroadcaster(_newBroadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeSymbiosisBridge(_newSymbiosisBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        changeTonBridge(_newTonBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        initialize(_tonBridge: string, _symbiosisBridge: string, _bridgeChainId: BigNumberish, _broadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        symbiosisBridge(overrides?: CallOverrides): Promise<BigNumber>;
        tonBridge(overrides?: CallOverrides): Promise<BigNumber>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        bridgeChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        broadcaster(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        callBridgeRequest(_amount: BigNumberish, _tonAddress: TonBridge.TonAddressStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeBridgeChainId(_newBridgeChainId: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeBroadcaster(_newBroadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeSymbiosisBridge(_newSymbiosisBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        changeTonBridge(_newTonBridge: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        initialize(_tonBridge: string, _symbiosisBridge: string, _bridgeChainId: BigNumberish, _broadcaster: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        symbiosisBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tonBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace DepositoryTypes {
    type DepositStruct = {
        token: string;
        amount: BigNumberish;
        nonce: BigNumberish;
    };
    type DepositStructOutput = [string, BigNumber, BigNumber] & {
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
    };
}
interface WithdrawUnlockerInterface extends utils.Interface {
    contractName: 'WithdrawUnlocker';
    functions: {
        'decodeCondition(bytes)': FunctionFragment;
        'encodeCondition((address))': FunctionFragment;
        'encodeSolution()': FunctionFragment;
        'transfer(address,address,address,uint256)': FunctionFragment;
        'unlock(address,(address,uint256,uint256),bytes,bytes)': FunctionFragment;
    };
    encodeFunctionData(functionFragment: 'decodeCondition', values: [BytesLike$1]): string;
    encodeFunctionData(functionFragment: 'encodeCondition', values: [WithdrawUnlocker.ConditionStruct]): string;
    encodeFunctionData(functionFragment: 'encodeSolution', values?: undefined): string;
    encodeFunctionData(functionFragment: 'transfer', values: [string, string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'unlock', values: [string, DepositoryTypes.DepositStruct, BytesLike$1, BytesLike$1]): string;
    decodeFunctionResult(functionFragment: 'decodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeCondition', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'encodeSolution', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'transfer', data: BytesLike$1): Result;
    decodeFunctionResult(functionFragment: 'unlock', data: BytesLike$1): Result;
    events: {};
}
declare namespace WithdrawUnlocker {
    type ConditionStruct = {
        recipient: string;
    };
    type ConditionStructOutput = [string] & {
        recipient: string;
    };
}
interface WithdrawUnlocker extends BaseContract {
    contractName: 'WithdrawUnlocker';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: WithdrawUnlockerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<[WithdrawUnlocker.ConditionStructOutput]>;
        encodeCondition(c: WithdrawUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<[string]>;
        encodeSolution(overrides?: CallOverrides): Promise<[string]>;
        transfer(metarouter: string, token: string, recipient: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        unlock(metarouter: string, deposit: DepositoryTypes.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<WithdrawUnlocker.ConditionStructOutput>;
    encodeCondition(c: WithdrawUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
    encodeSolution(overrides?: CallOverrides): Promise<string>;
    transfer(metarouter: string, token: string, recipient: string, amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    unlock(metarouter: string, deposit: DepositoryTypes.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<WithdrawUnlocker.ConditionStructOutput>;
        encodeCondition(c: WithdrawUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<string>;
        encodeSolution(overrides?: CallOverrides): Promise<string>;
        transfer(metarouter: string, token: string, recipient: string, amount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        unlock(metarouter: string, deposit: DepositoryTypes.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<BigNumber>;
        encodeCondition(c: WithdrawUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<BigNumber>;
        encodeSolution(overrides?: CallOverrides): Promise<BigNumber>;
        transfer(metarouter: string, token: string, recipient: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        unlock(metarouter: string, deposit: DepositoryTypes.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        decodeCondition(condition: BytesLike$1, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeCondition(c: WithdrawUnlocker.ConditionStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        encodeSolution(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(metarouter: string, token: string, recipient: string, amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        unlock(metarouter: string, deposit: DepositoryTypes.DepositStruct, condition: BytesLike$1, solution: BytesLike$1, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare const getThreshold: (syBtcAmount: TokenAmount, synthesis: Synthesis, cache: Cache) => Promise<TokenAmount>;
declare const getToBtcFee: (syBtcAmount: TokenAmount, synthesis: Synthesis, cache: Cache) => Promise<TokenAmount>;
declare function isBtcChainId(chainId: ChainId | undefined): boolean;
declare const BTC_NETWORKS: Partial<Record<ChainId, Network>>;
declare function getPkScriptForChain(addr: string, btcChain: Network): Buffer;
declare function getPkScript(addr: string, btcChainId: ChainId): Buffer;
declare function getAddress(pkScript: string, btcChain: Network): string;
declare function getBtcPortalFee(forwarderUrl: string, cache: Cache): Promise<string>;
declare function getUnwrapDustLimit(forwarderUrl: string, cache: Cache): Promise<string>;

declare const TON_TOKEN_DECIMALS = 9;
declare const TON_REFERRAL_ADDRESS: Address;
declare const TON_STONFI_PROXY_ADDRESS = "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c";
declare function isTonChainId(chainId: ChainId | undefined): boolean;
declare function callDataToCell(finalCallData: Buffer): Cell;
type BridgeConfig = {
    isPaused: boolean;
    owner: Address;
    admin: Address;
    mpcAddress: Buffer;
    externalIdContractCode: Cell;
    tonAddress: Address;
};
declare const Opcodes: {
    EpSynthesize: number;
    EpMetaSynthesize: number;
};
declare const EventIds: {
    MPCChanged: bigint;
    BurnCompleted: bigint;
    SetJettonThreshold: bigint;
    OracleRequest: bigint;
};
declare class Bridge implements Contract {
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    } | undefined;
    constructor(address: Address, init?: {
        code: Cell;
        data: Cell;
    } | undefined);
    static synthesizeMessage({ stableBridgingFee, token, amount, chain2Address, receiveSide, oppositeBridge, revertableAddress, chainId, }: {
        stableBridgingFee: bigint;
        token: Address;
        amount: bigint;
        chain2Address: Buffer;
        receiveSide: Buffer;
        oppositeBridge: Buffer;
        revertableAddress: Buffer;
        chainId: bigint;
    }): Cell;
    static metaSynthesizeMessage({ stableBridgingFee, token, amount, chain2Address, receiveSide, oppositeBridge, chainId, finalReceiveSide, finalOffset, revertableAddress, swapTokens, secondDexRouter, secondSwapCallData, finalCallData, }: {
        stableBridgingFee: bigint;
        token: Address;
        amount: bigint;
        chain2Address: Buffer;
        receiveSide: Buffer;
        oppositeBridge: Buffer;
        chainId: bigint;
        finalReceiveSide: Buffer;
        finalOffset: bigint;
        revertableAddress: Buffer;
        swapTokens: Buffer[];
        secondDexRouter: Buffer;
        secondSwapCallData: Buffer;
        finalCallData: Buffer;
    }): Cell;
}
declare const MIN_META_SYNTH_TONS: bigint;
declare const MIN_META_SYNTH_JETTONS: bigint;
declare const MIN_SYNTH_TONS: bigint;
declare const MIN_SYNTH_JETTONS: bigint;
declare const NOTIFICATION_PAYMENT: bigint;
interface MetaSynthesizeParams {
    symbiosis: Symbiosis;
    fee: TokenAmount;
    from: string;
    to: string;
    revertableAddress: string;
    amountIn: TokenAmount;
    chainIdOut: ChainId;
    swapTokens: string[];
    secondSwapCallData: string;
    secondDexRouter: string;
    finalCallData: string;
    finalReceiveSide: string;
    finalOffset: number;
    validUntil: number;
}
declare function isWTon(symbiosis: Symbiosis, token: Token): boolean;
declare function buildMetaSynthesize(params: MetaSynthesizeParams): Promise<TonTransactionData>;
interface SynthesizeParams {
    symbiosis: Symbiosis;
    fee: TokenAmount;
    amountIn: TokenAmount;
    chainIdOut: ChainId;
    from: string;
    to: string;
    revertableAddress: string;
    validUntil: number;
}
declare function buildSynthesize(params: SynthesizeParams): Promise<TonTransactionData>;
declare function tonAdvisorMock(feeToken: Token): {
    fee: TokenAmount;
    save: TokenAmount;
};

interface TronTransactionData {
    chain_id: number;
    call_value: number | string;
    contract_address: string;
    fee_limit: number;
    function_selector: string;
    owner_address: string;
    raw_parameter: string;
}
interface Params {
    chainId: ChainId;
    tronWeb: TronWeb;
    abi: ReadonlyArray<JsonFragment>;
    contractAddress: string;
    functionName: string;
    params: any[];
    ownerAddress: string;
    value?: string | number | BNJS;
}
declare function prepareTronTransaction({ chainId, tronWeb, abi, contractAddress, functionName, params, value, ownerAddress, }: Params): TronTransactionData;
declare function tronAddressToEvm(address: string): string;
declare function isTronChainId(chainId: ChainId): boolean;
declare function isTronChain(chain: Chain): boolean;
declare function isTronToken(token: Token): boolean;

interface GetInternalIdParams {
    contractAddress: string;
    requestCount: BigNumber;
    chainId: ChainId;
}
interface GetExternalIdParams {
    internalId: string;
    contractAddress: string;
    revertableAddress: string;
    chainId: ChainId;
}
declare function isEvmChainId(chainId: ChainId | undefined): boolean;
declare function getInternalId({ contractAddress, requestCount, chainId }: GetInternalIdParams): string;
declare function getExternalId({ internalId, contractAddress, revertableAddress, chainId, }: GetExternalIdParams): string;
declare function calculateGasMargin(value: BigNumber): BigNumber;
declare function computeTradePriceBreakdown(trade?: Trade$1, dexFee?: number): {
    priceImpactWithoutFee?: Percent;
    realizedLPFee?: TokenAmount;
};
declare function basisPointsToPercent(num: number): Percent;
declare function getMinAmount(slippage: number, amount: BigintIsh): JSBI;
declare function computeSlippageAdjustedAmounts(trade: Trade$1 | undefined, allowedSlippage: number): {
    [field in Field]?: TokenAmount;
};
declare function calculatePriceImpact(tokenAmountIn: TokenAmount, tokenAmountOut: TokenAmount): Percent;
declare class GetLogTimeoutExceededError extends Error {
    readonly filter: Filter;
    constructor(filter: Filter);
}
declare const DEFAULT_EXCEED_DELAY: number;
interface GetLogsWithTimeoutParams {
    symbiosis: Symbiosis;
    chainId: ChainId;
    filter: Filter;
    exceedDelay?: number;
}
declare function getLogWithTimeout({ symbiosis, chainId, filter, exceedDelay: exceedTimeout, }: GetLogsWithTimeoutParams): Promise<Log>;
declare function getAllPairCombinations(tokenIn: Token, tokenOut: Token): [Token, Token][];
interface DetailedSlippage {
    A: number;
    B: number;
    C: number;
}
declare function splitSlippage(totalSlippage: number, hasTradeA: boolean, hasTradeC: boolean): DetailedSlippage;

declare function isSolanaChainId(chainId: ChainId | undefined): boolean;
declare const SOL_USDC: Token;
declare function getSolanaConnection(): Connection;
declare function addSolanaFee(from: string, instructions?: string): Promise<{
    instructions: string;
    fee: TokenAmount;
}>;

type Id = number;
type TokenInfo = TokenConstructor & {
    id: Id;
    originalId?: Id;
};
type OmniPoolToken = {
    index: number;
    tokenId: Id;
};
type OmniPoolInfo = OmniPoolConfig & {
    id: Id;
    tokens: OmniPoolToken[];
};
type ConfigCacheData = {
    tokens: TokenInfo[];
    omniPools: OmniPoolInfo[];
};
declare class Builder {
    private readonly configName;
    readonly config: Config;
    private providers;
    constructor(configName: ConfigName);
    build(): Promise<void>;
    private checkTransmitters;
    private checkPortalTokensWhitelisted;
    private checkMetarouters;
    private buildOmniPools;
    private buildTokensList;
    private chainConfig;
    private getProvider;
    private stables;
    private fabric;
    private synthesis;
    private portal;
    private bridge;
    private metaRouter;
    omniPool(config: OmniPoolConfig): OmniPool;
}

declare enum Field {
    INPUT = "INPUT",
    OUTPUT = "OUTPUT"
}
interface VolumeFeeCollector {
    chainId: ChainId;
    address: string;
    feeRate: string;
    eligibleChains: ChainId[];
    default?: boolean;
}
type BridgeDirection = 'burn' | 'mint' | 'v2';
type DepositoryConfig = {
    depository: string;
    swapUnlocker: string;
    withdrawUnlocker: string;
    branchedUnlocker: string;
    btcRefundUnlocker?: string;
};
type ChainConfig = {
    id: ChainId;
    rpc: string;
    headers?: Record<string, string>;
    spareRpcs?: string[];
    dexFee: number;
    filterBlockOffset: number;
    stables: TokenConstructor[];
    metaRouter: string;
    metaRouterGateway: string;
    multicallRouter: string;
    router: string;
    bridge: string;
    synthesis: string;
    portal: string;
    fabric: string;
    tonPortal?: string;
    partnerFeeCollector?: string;
    depository?: DepositoryConfig;
};
type AdvisorConfig = {
    url: string;
};
type OmniPoolConfig = {
    chainId: ChainId;
    address: string;
    oracle: string;
    generalPurpose: boolean;
    coinGeckoId: string;
};
type SwapLimit = {
    chainId: ChainId;
    address: string;
    min: string;
    max: string;
};
type BtcConfig = {
    btc: Token;
    symBtc: {
        address: string;
        chainId: ChainId;
    };
    forwarderUrl: string;
};
type Config = {
    advisor: AdvisorConfig;
    omniPools: OmniPoolConfig[];
    revertableAddress: Partial<Record<ChainId, string>> & {
        default: string;
    };
    limits: SwapLimit[];
    chains: ChainConfig[];
    refundAddress: string;
    btcConfigs: BtcConfig[];
};
type OverrideChainConfig = {
    id: ChainId;
    rpc: string;
    headers?: Record<string, string>;
};
type FeeConfig = {
    token: Token;
    value: string;
};
type SelectMode = 'fastest' | 'best_return';
type OneInchConfig = {
    apiUrl: string;
    apiKeys: string[];
};
type OpenOceanConfig = {
    apiUrl: string;
    apiKeys: string[];
};

type OverrideConfig = {
    btcConfigs?: BtcConfig[];
    chains?: OverrideChainConfig[];
    limits?: SwapLimit[];
    fetch?: typeof fetch;
    advisor?: AdvisorConfig;
    oneInchConfig?: OneInchConfig;
    openOceanConfig?: OpenOceanConfig;
    volumeFeeCollectors?: VolumeFeeCollector[];
    cache?: Cache;
    config?: Config;
    configCache?: ConfigCacheData;
};
interface MiddlewareCall {
    address: string;
    data: string;
    offset: number;
}
interface RevertableAddress {
    chainId: ChainId;
    address: string;
}
type TradeAContext = 'metaRouter' | 'multicallRouter';
interface SwapExactInParams {
    symbiosis: Symbiosis;
    tokenAmountIn: TokenAmount;
    tokenOut: Token;
    from: string;
    to: string;
    slippage: number;
    deadline: number;
    transitTokenIn?: Token;
    transitTokenOut?: Token;
    oneInchProtocols?: OneInchProtocols;
    middlewareCall?: MiddlewareCall;
    revertableAddresses?: RevertableAddress[];
    selectMode?: SelectMode;
    tradeAContext?: TradeAContext;
    partnerAddress?: string;
    refundAddress?: string;
    generateBtcDepositAddress?: boolean;
    disableSrcChainRouting?: boolean;
    disableDstChainRouting?: boolean;
}
type BtcTransactionData = {
    depositAddress: string;
    validUntil: string;
    tokenAmountOut: TokenAmount;
};
type TonTransactionData = {
    validUntil: number;
    messages: {
        address: string;
        amount: string;
        payload: string;
    }[];
};
type SolanaTransactionData = {
    instructions: string;
};
type SwapExactInTransactionPayload = {
    transactionType: 'evm';
    transactionRequest: TransactionRequest;
} | {
    transactionType: 'tron';
    transactionRequest: TronTransactionData;
} | {
    transactionType: 'btc';
    transactionRequest: BtcTransactionData;
} | {
    transactionType: 'ton';
    transactionRequest: TonTransactionData;
} | {
    transactionType: 'solana';
    transactionRequest: SolanaTransactionData;
};
type RouteItem = {
    provider: SymbiosisTradeType;
    tokens: Token[];
};
type FeeItem = {
    provider: SymbiosisTradeType;
    value: TokenAmount;
    save?: TokenAmount;
    description?: string;
};
type SwapExactInResult = {
    kind: SymbiosisKind;
    tokenAmountOut: TokenAmount;
    tokenAmountOutMin: TokenAmount;
    priceImpact: Percent;
    approveTo: string;
    routes: RouteItem[];
    fees: FeeItem[];
    amountInUsd?: TokenAmount;
    timeLog?: ProfilerItem[];
    routeType?: string;
    poolAddress?: string;
    tradeA?: SymbiosisTrade;
    tradeC?: SymbiosisTrade;
} & SwapExactInTransactionPayload;
type MultiCallItem = {
    to: string;
    data: BytesLike$1;
    offset: number;
    value: string;
    amountIn: TokenAmount;
    amountOut: TokenAmount;
    amountOutMin: TokenAmount;
    priceImpact: Percent;
    fees: FeeItem[];
    routes: RouteItem[];
};
type PartnerFeeCallParams = {
    partnerAddress: string;
    partnerFeeCollector: PartnerFeeCollector;
    feeRate: BigNumber;
    fixedFee: BigNumber;
};
type MetricParams = {
    operation: string;
    kind: string;
    tokenIn?: Token;
    tokenOut?: Token;
};
type CounterParams = {
    provider: string;
    reason: string;
    chain_id: string;
};
type PriceImpactMetricParams = {
    name_from: string;
    name_to: string;
    token_amount: number;
    price_impact: number;
};

type BridgeRequestType = 'SynthesizeRequest' | 'BurnRequest' | 'RevertSynthesizeRequest' | 'RevertSynthesizeCompleted' | 'RevertBurnCompleted';
interface BridgeTxInfo {
    internalId: string;
    externalId: string;
    externalChainId: ChainId;
    requestType: BridgeRequestType;
}
interface BtcDepositAcceptedResult {
    commitTx: string;
    btcConfig: BtcConfig;
}

declare function waitForBtcDepositAccepted(btcConfig: BtcConfig, depositAddress: string): Promise<BtcDepositAcceptedResult | undefined>;

interface WaitForBtcCommitTxMinedParams {
    btcConfig: BtcConfig;
    commitTx: string;
}
declare function waitForBtcCommitTxMined({ btcConfig, commitTx, }: WaitForBtcCommitTxMinedParams): Promise<{
    blockHeight: number;
    revealTx: string;
} | undefined>;

declare function waitForBtcEvmTxIssued(symbiosis: Symbiosis, revealTx: string, btcConfig: BtcConfig): Promise<string>;

interface WaitFromTonTxMinedParams {
    symbiosis: Symbiosis;
    address: string;
    contractAddress: string;
}
declare function waitFromTonTxMined({ symbiosis, address, contractAddress, }: WaitFromTonTxMinedParams): Promise<Transaction | undefined>;

type InitProps = {
    validateState: boolean;
    synthesizeRequestFinder?: SynthesizeRequestFinder;
};
declare enum PendingRequestState {
    Default = 0,
    Sent = 1,
    Reverted = 2
}
type PendingRequestType = 'burn' | 'synthesize' | 'burn-v2' | 'burn-v2-revert' | 'synthesize-v2';
interface PendingRequest {
    originalFromTokenAmount: TokenAmount;
    fromTokenAmount: TokenAmount;
    transactionHash: string;
    state: PendingRequestState;
    internalId: string;
    externalId: string;
    type: PendingRequestType;
    from: string;
    to: string;
    revertableAddress: string;
    chainIdFrom: ChainId;
    chainIdTo: ChainId;
    revertChainId: ChainId;
}
interface SourceChainData {
    fromAddress: string;
    sourceChainId: ChainId;
}
type SynthesizeRequestFinder = (externalId: string) => Promise<SourceChainData | undefined>;
declare const findSourceChainData: (symbiosis: Symbiosis, chainIdFrom: ChainId, chainIdTo: ChainId, txHash: string, revertableAddress: string, omniPoolConfig: OmniPoolConfig, synthesizeRequestFinder?: SynthesizeRequestFinder) => Promise<SourceChainData | undefined>;
declare const isSynthesizeV2: (symbiosis: Symbiosis, chainId: ChainId, txHash: string) => Promise<boolean>;
declare class RevertRequest {
    private symbiosis;
    private chainId;
    private transactionHash;
    constructor(symbiosis: Symbiosis, chainId: ChainId, transactionHash: string);
    init({ validateState, synthesizeRequestFinder }: InitProps): Promise<PendingRequest | null>;
    private findSynthesizeRequest;
    private findBurnRequest;
}

type RevertBase = {
    type: 'tron' | 'evm';
    fee: TokenAmount;
};
type EvmRevertResponse = RevertBase & {
    transactionRequest: TransactionRequest;
};
type TronRevertResponse = RevertBase & {
    transactionRequest: TronTransactionData;
};
type RevertResponse = TronRevertResponse | EvmRevertResponse;
declare class RevertPending {
    private symbiosis;
    private request;
    protected multicallRouter: MulticallRouter;
    private deadline;
    private slippage;
    private transitTokenFrom;
    private transitTokenTo;
    private omniPoolConfig;
    constructor(symbiosis: Symbiosis, request: PendingRequest);
    revert(slippage: number, deadline: number): Promise<RevertResponse>;
    protected getFeeV2(): Promise<TokenAmount>;
    protected feeBurnCallDataV2(): Promise<[string, string]>;
    private buildMetaBurnCalldata;
    private getFee;
    private getTransactionRequest;
    private getRevertSynthesizeTransactionRequestV2;
    private getRevertSynthesizeTransactionRequest;
    private getRevertBurnTransactionRequest;
    private getSyntheticToken;
    private buildSwapCalldata;
    private getRevertBurnTransactionRequestV2;
    private getRevertBurnTransactionRequestV2Revert;
    private getExternalId;
}

type ZappingExactInParams = {
    tokenAmountIn: TokenAmount;
    from: string;
    to: string;
    slippage: number;
    deadline: number;
};
declare class Zapping {
    private readonly symbiosis;
    private readonly omniPoolConfig;
    protected multicallRouter: MulticallRouter;
    private from;
    private to;
    private revertableAddress;
    private tokenAmountIn;
    private slippage;
    private deadline;
    private tradeA;
    private synthToken;
    private transitTokenIn;
    private omniLiquidity;
    private readonly pool;
    private readonly poolOracle;
    constructor(symbiosis: Symbiosis, omniPoolConfig: OmniPoolConfig);
    exactIn({ tokenAmountIn, from, to, slippage, deadline, }: ZappingExactInParams): Promise<SwapExactInResult>;
    private getTonTransactionRequest;
    private getEvmTransactionRequest;
    private getTronTransactionRequest;
    private calculatePriceImpact;
    private getPortalTokenAmountIn;
    private getSynthAmount;
    private buildTradeA;
    private buildOmniLiquidity;
    private getMulticallData;
    private otherSideSynthCallData;
    private getSynthToken;
    protected getFee(): Promise<TokenAmount>;
}

interface CreateOctoPoolTradeParams {
    tokenAmountIn: TokenAmount;
    tokenAmountInMin: TokenAmount;
    tokenOut: Token;
    to: string;
}
interface TransitOutResult {
    trade: OctoPoolTrade;
    amountOut: TokenAmount;
    amountOutMin: TokenAmount;
    volumeFeeCall?: MultiCallItem;
    partnerFeeCall?: MultiCallItem;
}
type TransitParams = {
    symbiosis: Symbiosis;
    amountIn: TokenAmount;
    amountInMin: TokenAmount;
    tokenOut: Token;
    slippage: number;
    deadline: number;
    omniPoolConfig: OmniPoolConfig;
    fee1?: TokenAmount;
    fee2?: TokenAmount;
    partnerAddress?: string;
};
declare class Transit {
    symbiosis: Symbiosis;
    amountIn: TokenAmount;
    amountInMin: TokenAmount;
    tokenOut: Token;
    slippage: number;
    deadline: number;
    omniPoolConfig: OmniPoolConfig;
    fee1?: TokenAmount;
    fee2?: TokenAmount;
    partnerAddress?: string;
    direction: BridgeDirection;
    feeToken1: Token;
    feeToken2: Token | undefined;
    protected out?: TransitOutResult;
    constructor({ symbiosis, amountIn, amountInMin, tokenOut, slippage, deadline, omniPoolConfig, fee1, fee2, partnerAddress, }: TransitParams);
    get amountOut(): TokenAmount;
    get amountOutMin(): TokenAmount;
    get trade(): OctoPoolTrade;
    get volumeFeeCall(): MultiCallItem | undefined;
    get partnerFeeCall(): MultiCallItem | undefined;
    init(): Promise<Transit>;
    isV2(): boolean;
    calls(): {
        calldatas: (string | ethers.Bytes)[];
        receiveSides: string[];
        paths: string[];
        offsets: number[];
    };
    getBridgeAmountIn(): TokenAmount;
    applyFees(fee1: TokenAmount, fee2?: TokenAmount): Promise<void>;
    createOctoPoolTrade(params: CreateOctoPoolTradeParams): Promise<OctoPoolTrade>;
    private getFeeToken1;
    private getFeeToken2;
    private getAmountsOut;
    private getTradeAmountsIn;
    private getTradeTokenOut;
    private static getDirection;
    private assertOutInitialized;
}

type MetaRouteParams = {
    amount: string;
    nativeIn: boolean;
    approvedTokens: string[];
    firstDexRouter: string;
    firstSwapCalldata: string | [];
    secondDexRouter: string;
    secondSwapCalldata: string | [];
    relayRecipient: string;
    otherSideCalldata: string;
};
declare abstract class BaseSwapping {
    amountInUsd: TokenAmount | undefined;
    protected from: string;
    protected to: string;
    protected tokenAmountIn: TokenAmount;
    protected tokenOut: Token;
    protected slippage: DetailedSlippage;
    protected deadline: number;
    protected revertableAddresses: {
        AB: string;
        BC: string;
    };
    protected tradeA: SymbiosisTrade | undefined;
    protected transit: Transit;
    protected tradeC: SymbiosisTrade | undefined;
    protected readonly symbiosis: Symbiosis;
    protected synthesisV2: Synthesis;
    protected transitTokenIn: Token;
    protected transitTokenOut: Token;
    protected omniPoolConfig: OmniPoolConfig;
    protected oneInchProtocols?: OneInchProtocols;
    protected partnerAddress?: string;
    private profiler;
    constructor(symbiosis: Symbiosis, omniPoolConfig: OmniPoolConfig);
    doExactIn({ tokenAmountIn, tokenOut, from, to, slippage, deadline, oneInchProtocols, transitTokenIn, transitTokenOut, revertableAddresses, tradeAContext, partnerAddress, }: Omit<SwapExactInParams, 'symbiosis'>): Promise<SwapExactInResult>;
    protected getAdvisorFees(): Promise<{
        fee1Raw: {
            fee: TokenAmount;
            save: TokenAmount;
        } | {
            fee: TokenAmount;
            save: TokenAmount;
        } | undefined;
        fee2Raw: {
            fee: TokenAmount;
            save: TokenAmount;
        } | {
            fee: TokenAmount;
            save: TokenAmount;
        } | undefined;
    }>;
    protected getRevertableAddress(side: 'AB' | 'BC'): string;
    protected doPostTransitAction(): Promise<void>;
    protected buildDetailedSlippage(totalSlippage: number): DetailedSlippage;
    protected approveTo(): string;
    protected getValue(): string;
    protected getMetaRouteParams(fee: TokenAmount, feeV2: TokenAmount | undefined): MetaRouteParams;
    protected getEvmTransactionRequest(params: MetaRouteParams): TransactionRequest;
    protected getTronTransactionRequest(params: MetaRouteParams): TronTransactionData;
    protected getTonTransactionRequest(fee: TokenAmount, feeV2: TokenAmount | undefined): Promise<TonTransactionData>;
    protected calculatePriceImpact(): Percent;
    protected buildTradeA(tradeAContext?: TradeAContext): SymbiosisTrade;
    protected buildTransit(amountIn: TokenAmount, amountInMin: TokenAmount): Transit;
    protected tradeCTo(): string;
    protected buildTradeC(amountIn: TokenAmount, amountInMin: TokenAmount): AggregatorTrade | WrapTrade;
    protected metaBurnSyntheticToken(fee1: TokenAmount): [string, string];
    protected metaSynthesize(fee1: TokenAmount, fee2: TokenAmount | undefined): [string, string];
    protected otherSideData(fee1: TokenAmount, fee2: TokenAmount | undefined): [string, string];
    protected feeMintCallData(): [string, string];
    protected feeBurnCallData(): [string, string];
    protected feeBurnCallDataV2(): [string, string];
    protected getFee(feeToken: Token): Promise<{
        fee: TokenAmount;
        save: TokenAmount;
    }>;
    protected getFeeV2(feeToken: Token): Promise<{
        fee: TokenAmount;
        save: TokenAmount;
    }>;
    protected approvedTokens(): string[];
    protected firstDexRouter(): string;
    protected firstSwapCalldata(): string | [];
    protected secondDexRouter(): string;
    protected secondSwapCalldata(): string | [];
    protected finalReceiveSide(): string;
    protected finalCalldata(): string | [];
    protected finalOffset(): number;
    protected finalReceiveSideV2(): string;
    protected finalCalldataV2(fee2?: TokenAmount | undefined): string;
    protected finalOffsetV2(): number;
    protected swapTokens(): string[];
    protected extraSwapTokens(): string[];
}

declare class Swapping extends BaseSwapping {
    exactIn(params: Omit<SwapExactInParams, 'symbiosis'>): Promise<SwapExactInResult>;
}

declare class SwappingToTon extends BaseSwapping {
    protected userAddress: string;
    exactIn(params: Omit<SwapExactInParams, 'symbiosis'>): Promise<SwapExactInResult>;
    protected getFee(feeToken: Token): Promise<{
        fee: TokenAmount;
        save: TokenAmount;
    }>;
    protected getFeeV2(feeToken: Token): Promise<{
        fee: TokenAmount;
        save: TokenAmount;
    }>;
    protected metaBurnSyntheticToken(fee: TokenAmount): [string, string];
    protected finalOffsetV2(): number;
    protected finalCalldataV2(feeV2?: TokenAmount | undefined): string;
}

declare class SwappingMiddleware extends BaseSwapping {
    protected middlewareAddress: string;
    protected middlewareData: string;
    protected middlewareOffset: number;
    exactIn(params: Omit<SwapExactInParams, 'symbiosis'>): Promise<SwapExactInResult>;
    protected finalReceiveSide(): string;
    protected finalCalldata(): string | [];
    protected finalOffset(): number;
}

interface ZappingBtcExactInParams {
    tokenAmountIn: TokenAmount;
    syBtc: Token;
    from: string;
    to: string;
    slippage: number;
    deadline: number;
    oneInchProtocols?: OneInchProtocols;
    transitTokenIn: Token;
    transitTokenOut: Token;
    partnerAddress?: string;
}
declare class ZappingBtc extends BaseSwapping {
    protected multicallRouter: MulticallRouter;
    protected bitcoinAddress: Buffer;
    protected syBtc: Token;
    protected minBtcFee: TokenAmount;
    protected threshold: TokenAmount;
    protected synthesis: Synthesis;
    protected evmTo: string;
    protected partnerFeeCall?: MultiCallItem;
    protected volumeFeeCall?: MultiCallItem;
    protected doPostTransitAction(): Promise<void>;
    exactIn({ tokenAmountIn, syBtc, from, to, slippage, deadline, transitTokenIn, transitTokenOut, partnerAddress, }: ZappingBtcExactInParams): Promise<SwapExactInResult>;
    protected tradeCTo(): string;
    protected finalReceiveSide(): string;
    protected finalCalldata(): string | [];
    protected finalOffset(): number;
    private buildMulticall;
}

interface ZappingThorExactInParams {
    tokenAmountIn: TokenAmount;
    thorTokenIn: Token;
    from: string;
    to: string;
    slippage: number;
    deadline: number;
    partnerAddress?: string;
    oneInchProtocols?: OneInchProtocols;
}
type ThorQuote = {
    memo: string;
    amountOut: TokenAmount;
    amountOutMin: TokenAmount;
    router: string;
    expiry: string;
    fees: {
        asset: string;
        total: string;
    };
};
type ThorPool = {
    asset: string;
    status: 'Available' | 'Staged';
    pending_inbound_asset: string;
    pending_inbound_rune: string;
    balance_asset: string;
    balance_rune: string;
    pool_units: string;
    LP_units: string;
    synth_units: string;
    synth_supply: string;
    savers_depth: string;
    savers_units: string;
    synth_mint_paused: false;
    synth_supply_remaining: string;
    loan_collateral: string;
    loan_cr: string;
    derived_depth_bps: string;
};
declare class ZappingThor extends BaseSwapping {
    protected multicallRouter: MulticallRouter;
    protected bitcoinAddress: string;
    protected thorTokenIn: Token;
    protected thorTokenOut: string;
    protected thorVault: string;
    protected thorQuote: ThorQuote;
    protected evmTo: string;
    protected doPostTransitAction(): Promise<void>;
    exactIn({ tokenAmountIn, thorTokenIn, from, to, slippage, deadline, partnerAddress, }: ZappingThorExactInParams): Promise<SwapExactInResult>;
    protected static getThorPools(token: Token): Promise<ThorPool>;
    protected static getThorVault(token: Token): Promise<string>;
    protected getThorQuote(amount: TokenAmount): Promise<ThorQuote>;
    protected tradeCTo(): string;
    protected finalReceiveSide(): string;
    protected finalCalldata(): string | [];
    protected finalOffset(): number;
    private buildMulticall;
}

type ConfigName = 'dev' | 'testnet' | 'mainnet';
type DiscountTier = {
    amount: string;
    discount: number;
};
type DepositoryContracts = {
    depository: Depository;
    branchedUnlocker: BranchedUnlocker;
    swapUnlocker: SwapUnlocker;
    withdrawUnlocker: WithdrawUnlocker;
    btcRefundUnlocker?: BtcRefundUnlocker;
};
declare class Symbiosis {
    providers: Map<ChainId, Provider>;
    readonly cache: Cache;
    readonly config: Config;
    readonly configName: ConfigName;
    private readonly configCache;
    clientId: string;
    private signature;
    sdkDurationMetric?: Histogram<string>;
    priceImpactSwapMetric?: Histogram<string>;
    counter?: Counter<string>;
    feesConfig?: FeeConfig[];
    readonly oneInchConfig: OneInchConfig;
    readonly volumeFeeCollectors: VolumeFeeCollector[];
    readonly openOceanConfig: OpenOceanConfig;
    readonly fetch: typeof fetch;
    setMetrics({ symbiosisSdkDuration, priceImpactSwap, }: {
        symbiosisSdkDuration: Histogram<string>;
        priceImpactSwap: Histogram<string>;
    }): void;
    setErrorCounter(counter: Counter<string>): void;
    setSignature(signature: string | undefined): void;
    setFeesConfig(feesConfig: FeeConfig[]): void;
    setClientId(clientId: string): void;
    getBtcConfig(btc: Token): BtcConfig;
    getDiscountTiers(): Promise<DiscountTier[]>;
    getDiscountChains(): Promise<ChainId[]>;
    getDiscount(signature: string): Promise<number>;
    checkDustLimit(amount: TokenAmount): Promise<void>;
    constructor(configName: ConfigName, clientId: string, overrideConfig?: OverrideConfig);
    createMetricTimer(): (({ tokenIn, tokenOut, operation, kind }: MetricParams) => number) | undefined;
    trackAggregatorError({ provider, reason, chain_id }: CounterParams): void;
    trackPriceImpactSwap({ name_from, name_to, token_amount, price_impact }: PriceImpactMetricParams): void;
    getVolumeFeeCollector(chainId: ChainId, involvedChainIds: ChainId[]): VolumeFeeCollector | undefined;
    getTonClient(): Promise<TonClient4>;
    chains(): Chain[];
    swapExactIn(params: Omit<SwapExactInParams, 'symbiosis'>): Promise<SwapExactInResult>;
    newSwapping(omniPoolConfig: OmniPoolConfig): SwappingMiddleware;
    newRevertPending(request: PendingRequest): RevertPending;
    newZapping(omniPoolConfig: OmniPoolConfig): Zapping;
    getProvider(chainId: ChainId, rpc?: string): Provider;
    tonBridge(chainId: ChainId, address: string, signer?: Signer): TonBridge;
    portal(chainId: ChainId, signer?: Signer): Portal;
    synthesis(chainId: ChainId, signer?: Signer): Synthesis;
    bridge(chainId: ChainId, signer?: Signer): Bridge$1;
    fabric(chainId: ChainId, signer?: Signer): Fabric;
    multicallRouter(chainId: ChainId, signer?: Signer): MulticallRouter;
    metaRouter(chainId: ChainId, signer?: Signer): MetaRouter;
    depository(chainId: ChainId, signer?: Signer): DepositoryContracts | null;
    omniPool(config: OmniPoolConfig, signer?: Signer): OmniPool;
    omniPoolOracle(config: OmniPoolConfig, signer?: Signer): OmniPoolOracle;
    getRepresentation(token: Token, chainId: ChainId): Token | undefined;
    getOmniPoolTokenIndex(omniPoolConfig: OmniPoolConfig, token: Token): number;
    getBridgeFee({ calldata, receiveSide, chainIdFrom, chainIdTo, }: {
        calldata: string;
        receiveSide: string;
        chainIdFrom: ChainId;
        chainIdTo: ChainId;
    }): Promise<{
        price: JSBI;
        save: JSBI;
    }>;
    filterBlockOffset(chainId: ChainId): number;
    getFromBlockWithOffset(chainId: ChainId): Promise<number>;
    dexFee(chainId: ChainId): number;
    chainConfig(chainId: ChainId): ChainConfig;
    tokens(): Token[];
    findToken(address: string, chainId: ChainId, chainFromId?: ChainId): Token | undefined;
    transitTokens(chainId: ChainId, omniPoolConfig: OmniPoolConfig): Token[];
    transitToken(chainId: ChainId, omniPoolConfig: OmniPoolConfig): Token;
    getTransitCombinations({ poolConfig, tokenIn, tokenOut, disableSrcChainRouting, disableDstChainRouting, }: {
        poolConfig: OmniPoolConfig;
        tokenIn: Token;
        tokenOut: Token;
        disableSrcChainRouting?: boolean;
        disableDstChainRouting?: boolean;
    }): {
        transitTokenIn: Token;
        transitTokenOut: Token;
    }[];
    getOmniPoolByConfig(config: OmniPoolConfig): OmniPoolInfo | undefined;
    getOmniPoolByToken(token: Token): OmniPoolInfo | undefined;
    getOmniPoolTokens(omniPoolConfig: OmniPoolConfig): Token[];
    getTokenInfoById(tokenId: Id): TokenInfo;
    tronWeb(chainId: ChainId): TronWeb;
    waitForComplete({ chainId, txId, txTon, }: Omit<WaitForCompleteParams, 'symbiosis'>): Promise<string | undefined>;
    waitForBtcDepositAccepted(depositAddress: string): Promise<BtcDepositAcceptedResult | undefined>;
    waitForBtcCommitTxMined(btcConfig: BtcConfig, commitTx: string): Promise<{
        blockHeight: number;
        revealTx: string;
    } | undefined>;
    waitForBtcEvmTxIssued(btcConfig: BtcConfig, revealTx: string): Promise<string>;
    waitFromTonTxMined(address: string, contractAddress: string): Promise<_ton_ton.Transaction | undefined>;
    findTransitTokenSent(chainId: ChainId, transactionHash: string): Promise<TokenAmount | undefined>;
    tronWaitForMined(chainId: ChainId, txId: string): Promise<TransactionInfo>;
    getRevertableAddress(chainId: ChainId): string;
    validateLimits(amount: TokenAmount): void;
}

declare class SdkError extends Error {
    constructor(message: string, cause?: unknown);
    private unwrapCause;
}
declare class RoutingError extends SdkError {
}
declare class NoTransitTokenError extends RoutingError {
}
declare class NoRepresentationFoundError extends RoutingError {
}
declare class LimitError extends SdkError {
}
declare class AmountTooLowError extends LimitError {
}
declare class AmountTooHighError extends LimitError {
}
declare class AmountLessThanFeeError extends LimitError {
}
declare class AdvisorError extends SdkError {
}
declare class ChainFlipError extends SdkError {
}
declare class ThorChainError extends SdkError {
}
declare class TradeError extends SdkError {
}
declare class WrapTradeError extends TradeError {
}
declare class UniV2TradeError extends TradeError {
}
declare class UniV3TradeError extends TradeError {
}
declare class IzumiTradeError extends TradeError {
}
declare class OpenOceanTradeError extends TradeError {
}
declare class OneInchTradeError extends TradeError {
}
declare class DedustTradeError extends TradeError {
}
declare class StonFiTradeError extends TradeError {
}
declare class RaydiumTradeError extends TradeError {
}
declare class JupiterTradeError extends TradeError {
}
declare enum SwapAggregatorErrorCategory {
    RateLimit = "rate_limit",
    SwapAggregatorError = "swap_aggregator_error",
    LiquidityError = "liquidity_error",
    TokenError = "token_error",
    BigIntError = "bigint_error",
    ExceedPlan = "exceed_plan",
    OracleError = "oracle_error",
    Unknown = "unknown"
}
declare function aggregatorErrorToText(reason: string): SwapAggregatorErrorCategory;

declare const CROSS_CHAIN_ID = "0x0000000000000000000000000000000000000000000000000000000000000000";
type ChainTokensList = {
    readonly [chainId in ChainId]?: Token[];
};
declare const WETH_ONLY: ChainTokensList;
declare const DEX_TOKENS_TO_CHECK_TRADES_AGAINST: {
    1: Token[];
    56: Token[];
    43114: Token[];
    137: Token[];
    43288: never[];
    719095483: never[];
    13863860: never[];
    288: Token[];
    2001: Token[];
    1313161554: Token[];
    2222: Token[];
    534351: never[];
    324: Token[];
    42161: Token[];
    42170: Token[];
    10: Token[];
    7001: never[];
    1101: never[];
    2494104990: Token[];
    728126428: Token[];
    59140: never[];
    59144: never[];
    5000: never[];
    5001: never[];
    8453: never[];
    534352: never[];
    169: never[];
    1088: never[];
    195: never[];
    5165: never[];
    34443: never[];
    30: never[];
    81457: never[];
    4200: never[];
    810180: never[];
    1116: never[];
    167000: never[];
    1329: never[];
    7000: never[];
    25: never[];
    252: never[];
    1625: never[];
    223: never[];
    388: Token[];
    2818: Token[];
    5426: never[];
    2345: never[];
    146: never[];
    2741: never[];
    100: never[];
    80094: never[];
    130: never[];
    1868: never[];
    204: never[];
    999: never[];
    747474: never[];
    33139: never[];
    9745: never[];
};
declare const BASES_TO_CHECK_TRADES_AGAINST: ChainTokensList;
/**
 * Some tokens can only be swapped via certain pairs, so we override the list of bases that are considered for these
 * tokens.
 */
declare const CUSTOM_BASES: {
    [chainId in ChainId]?: {
        [tokenAddress: string]: Token[];
    };
};
declare const ONE_BIPS: Percent;
declare const BIPS_BASE: JSBI;
declare const MULTICALL_ADDRESSES: {
    [chainId in ChainId]?: string;
};
declare const MULTICALL_ROUTER_V2: Partial<Record<ChainId, string>>;

declare class NoMulticallAddressError extends Error {
    constructor(chainId: ChainId);
}
declare function getMulticall(provider: Provider): Promise<Multicall>;

declare class OmniLiquidity {
    readonly tokenAmountIn: TokenAmount;
    private readonly to;
    private readonly slippage;
    private readonly deadline;
    private readonly pool;
    private readonly poolOracle;
    amountOut: TokenAmount;
    callData: string;
    priceImpact: Percent;
    callDataOffset: number;
    constructor(tokenAmountIn: TokenAmount, to: string, slippage: number, deadline: number, pool: OmniPool, poolOracle: OmniPoolOracle);
    init(): Promise<this>;
}

declare const COINGECKO_PLATFORMS: {
    [chainId in ChainId]?: string;
};
declare const COINGECKO_GAS_TOKEN_IDS: {
    [chainId in ChainId]?: string;
};

declare const getTokenPriceUsd: (token: Token, map?: Map<string, string>) => Promise<number>;
declare const getTokenAmountUsd: (tokenAmount: TokenAmount, price: number) => number;

declare const config$2: Config;

declare const config$1: Config;

declare const config: Config;

declare const TRON_PORTAL_ABI: readonly [{
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_bridge";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_wrapper";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_whitelistedToken";
        readonly type: "address";
    }, {
        readonly internalType: "contract IMetaRouter";
        readonly name: "_metaRouter";
        readonly type: "address";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "crossChainID";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "bridgingFee";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }];
    readonly name: "BurnCompleted";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bytes32";
        readonly name: "requestId";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "clientId";
        readonly type: "bytes32";
    }];
    readonly name: "ClientIdLog";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }];
    readonly name: "MetaRevertRequest";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "previousOwner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "OwnershipTransferStarted";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "previousOwner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "OwnershipTransferred";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "Paused";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }];
    readonly name: "RevertBurnRequest";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "bytes32";
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "bridgingFee";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }];
    readonly name: "RevertSynthesizeCompleted";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address[]";
        readonly name: "tokens";
        readonly type: "address[]";
    }];
    readonly name: "SetBalanceOf";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "metaRouter";
        readonly type: "address";
    }];
    readonly name: "SetMetaRouter";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "timelock";
        readonly type: "address";
    }];
    readonly name: "SetTimelock";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "threshold";
        readonly type: "uint256";
    }];
    readonly name: "SetTokenThreshold";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "activate";
        readonly type: "bool";
    }];
    readonly name: "SetWhitelistToken";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bytes32";
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "chainID";
        readonly type: "uint256";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "revertableAddress";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }];
    readonly name: "SynthesizeRequest";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "portal";
        readonly type: "address";
    }];
    readonly name: "TokenTransferred";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "Unpaused";
    readonly type: "event";
}, {
    readonly inputs: readonly [];
    readonly name: "acceptOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "bridge";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getChainID";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "pure";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly components: readonly [{
            readonly internalType: "uint256";
            readonly name: "stableBridgingFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "internalID";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "receiveSide";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "managerChainBridge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sourceChainBridge";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "managerChainId";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "sourceChainId";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "router";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "swapCalldata";
            readonly type: "bytes";
        }, {
            readonly internalType: "address";
            readonly name: "sourceChainSynthesis";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "burnToken";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "burnCalldata";
            readonly type: "bytes";
        }, {
            readonly internalType: "bytes32";
            readonly name: "clientID";
            readonly type: "bytes32";
        }];
        readonly internalType: "struct MetaRouteStructs.MetaRevertTransaction";
        readonly name: "_metaRevertTransaction";
        readonly type: "tuple";
    }];
    readonly name: "metaRevertRequest";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "metaRouter";
    readonly outputs: readonly [{
        readonly internalType: "contract IMetaRouter";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly components: readonly [{
            readonly internalType: "uint256";
            readonly name: "stableBridgingFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "rtoken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "chain2address";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "receiveSide";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "oppositeBridge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "syntCaller";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "chainID";
            readonly type: "uint256";
        }, {
            readonly internalType: "address[]";
            readonly name: "swapTokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "address";
            readonly name: "secondDexRouter";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "secondSwapCalldata";
            readonly type: "bytes";
        }, {
            readonly internalType: "address";
            readonly name: "finalReceiveSide";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "finalCalldata";
            readonly type: "bytes";
        }, {
            readonly internalType: "uint256";
            readonly name: "finalOffset";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "revertableAddress";
            readonly type: "address";
        }, {
            readonly internalType: "bytes32";
            readonly name: "clientID";
            readonly type: "bytes32";
        }];
        readonly internalType: "struct MetaRouteStructs.MetaSynthesizeTransaction";
        readonly name: "_metaSynthesizeTransaction";
        readonly type: "tuple";
    }];
    readonly name: "metaSynthesize";
    readonly outputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_crossChainID";
        readonly type: "bytes32";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_externalID";
        readonly type: "bytes32";
    }, {
        readonly internalType: "address";
        readonly name: "_to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "_rToken";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_finalReceiveSide";
        readonly type: "address";
    }, {
        readonly internalType: "bytes";
        readonly name: "_finalCalldata";
        readonly type: "bytes";
    }, {
        readonly internalType: "uint256";
        readonly name: "_finalOffset";
        readonly type: "uint256";
    }];
    readonly name: "metaUnsynthesize";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "owner";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pause";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "paused";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pendingOwner";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "renounceOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "requestCount";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly name: "requests";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "recipient";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "chain2address";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "rtoken";
        readonly type: "address";
    }, {
        readonly internalType: "enum Portal.RequestState";
        readonly name: "state";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_internalID";
        readonly type: "bytes32";
    }, {
        readonly internalType: "address";
        readonly name: "_receiveSide";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_oppositeBridge";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_chainId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_clientID";
        readonly type: "bytes32";
    }];
    readonly name: "revertBurnRequest";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_externalID";
        readonly type: "bytes32";
    }];
    readonly name: "revertSynthesize";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address[]";
        readonly name: "_tokens";
        readonly type: "address[]";
    }];
    readonly name: "setBalanceOf";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "contract IMetaRouter";
        readonly name: "_metaRouter";
        readonly type: "address";
    }];
    readonly name: "setMetaRouter";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_timelock";
        readonly type: "address";
    }];
    readonly name: "setTimelock";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_threshold";
        readonly type: "uint256";
    }];
    readonly name: "setTokenThreshold";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "_activate";
        readonly type: "bool";
    }];
    readonly name: "setWhitelistToken";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "_chain2address";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_receiveSide";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_oppositeBridge";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_revertableAddress";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_chainID";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_clientID";
        readonly type: "bytes32";
    }];
    readonly name: "synthesize";
    readonly outputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "_chain2address";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_receiveSide";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_oppositeBridge";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_revertableAddress";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_chainID";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_clientID";
        readonly type: "bytes32";
    }];
    readonly name: "synthesizeNative";
    readonly outputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly components: readonly [{
            readonly internalType: "uint256";
            readonly name: "stableBridgingFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "approvalData";
            readonly type: "bytes";
        }, {
            readonly internalType: "address";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "chain2address";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "receiveSide";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "oppositeBridge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "revertableAddress";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "chainID";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "clientID";
            readonly type: "bytes32";
        }];
        readonly internalType: "struct Portal.SynthesizeWithPermitTransaction";
        readonly name: "_syntWithPermitTx";
        readonly type: "tuple";
    }];
    readonly name: "synthesizeWithPermit";
    readonly outputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "timelock";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly name: "tokenThreshold";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly name: "tokenWhitelist";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_portal";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "transferOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "unpause";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_stableBridgingFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_externalID";
        readonly type: "bytes32";
    }, {
        readonly internalType: "bytes32";
        readonly name: "_crossChainID";
        readonly type: "bytes32";
    }, {
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "_amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "_to";
        readonly type: "address";
    }];
    readonly name: "unsynthesize";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes32";
        readonly name: "";
        readonly type: "bytes32";
    }];
    readonly name: "unsynthesizeStates";
    readonly outputs: readonly [{
        readonly internalType: "enum Portal.UnsynthesizeState";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "versionRecipient";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "pure";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "wrapper";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

declare const TRON_TRC20_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly outputs: readonly [{
        readonly type: "uint256";
    }];
    readonly constant: true;
    readonly inputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "bool";
    }];
    readonly inputs: readonly [{
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "uint256";
    }];
    readonly constant: true;
    readonly inputs: readonly [{
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "uint8";
    }];
    readonly inputs: readonly [];
    readonly constant: true;
    readonly name: "decimals";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "bool";
    }];
    readonly inputs: readonly [{
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "subtractedValue";
        readonly type: "uint256";
    }];
    readonly name: "decreaseAllowance";
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "bool";
    }];
    readonly inputs: readonly [{
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "addedValue";
        readonly type: "uint256";
    }];
    readonly name: "increaseAllowance";
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly type: "string";
    }];
    readonly constant: true;
    readonly name: "name";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly type: "string";
    }];
    readonly constant: true;
    readonly name: "symbol";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly type: "uint256";
    }];
    readonly constant: true;
    readonly name: "totalSupply";
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "bool";
    }];
    readonly inputs: readonly [{
        readonly name: "recipient";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly outputs: readonly [{
        readonly type: "bool";
    }];
    readonly inputs: readonly [{
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly name: "recipient";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];

declare function isFromBtcSwapSupported(context: SwapExactInParams): boolean;
declare function fromBtcSwap(context: SwapExactInParams): Promise<SwapExactInResult>;
type EstimateWrapBodyParams = {
    amount: number;
    info: {
        portalFee: number;
        op: number;
        stableBridgingFee: number;
        tail: string;
        to: string;
    };
    refundAddress?: string;
    clientId?: string;
};
type WrapBodyParams = EstimateWrapBodyParams & {
    feeLimit: number;
};

declare function swapExactIn(params: SwapExactInParams): Promise<SwapExactInResult>;

declare const ZERO_FEE_COLLECTOR_ADDRESSES: Partial<Record<ChainId, string>>;
declare const FEE_COLLECTOR_ADDRESSES: Partial<Record<ChainId, string>>;

declare const THOR_TOKENS: Token[];

declare const CHAIN_FLIP_SOL_TOKENS: Token[];

declare const CHAIN_FLIP_BTC_TOKENS: Token[];

export { AdvisorConfig, AdvisorError, AmountLessThanFeeError, AmountTooHighError, AmountTooLowError, BASES_TO_CHECK_TRADES_AGAINST, BIPS_BASE, BTC_NETWORKS, BaseSwapping, BestTradeOptions, BigintIsh, Bridge, BridgeConfig, BridgeDirection, BridgeTxInfo, BtcConfig, BtcDepositAcceptedResult, BtcTransactionData, Builder, CHAIN_FLIP_BTC_TOKENS, CHAIN_FLIP_SOL_TOKENS, COINGECKO_GAS_TOKEN_IDS, COINGECKO_PLATFORMS, CROSS_CHAIN_ID, CUSTOM_BASES, Cache, Chain, ChainConfig, ChainFlipError, ChainId, Config, ConfigCacheData, ConfigName, CounterParams, DEFAULT_EXCEED_DELAY, DEX_TOKENS_TO_CHECK_TRADES_AGAINST, DedustTradeError, DepositoryConfig, DepositoryContracts, DetailedSlippage, DiscountTier, EstimateWrapBodyParams, EventIds, EvmRevertResponse, FACTORY_ADDRESS, FEE_COLLECTOR_ADDRESSES, FeeConfig, FeeItem, Field, Fraction, GAS_TOKEN, GetLogTimeoutExceededError, INIT_CODE_HASH, Icons, Id, InsufficientInputAmountError, InsufficientReservesError, IzumiTrade, IzumiTradeError, JupiterTradeError, LimitError, MINIMUM_LIQUIDITY, MIN_META_SYNTH_JETTONS, MIN_META_SYNTH_TONS, MIN_SYNTH_JETTONS, MIN_SYNTH_TONS, MULTICALL_ADDRESSES, MULTICALL_ROUTER_V2, MetricParams, MiddlewareCall, MultiCallItem, Multicall, MulticallRouter, NOTIFICATION_PAYMENT, NoMulticallAddressError, NoRepresentationFoundError, NoTransitTokenError, ONE_BIPS, OmniLiquidity, OmniPoolConfig, OmniPoolInfo, OmniPoolToken, OneInchConfig, OneInchTradeError, Opcodes, OpenOceanConfig, OpenOceanTradeError, OverrideChainConfig, OverrideConfig, PAIR_ADDRESS_CACHE, Pair, PartnerFeeCallParams, PendingRequest, PendingRequestState, PendingRequestType, Percent, Price, PriceImpactMetricParams, Profiler, ProfilerItem, RaydiumTradeError, RevertPending, RevertRequest, RevertResponse, RevertableAddress, Rounding, Route$1 as Route, RouteItem, Router, RoutingError, SOL_USDC, SdkError, SelectMode, SolanaTransactionData, SourceChainData, StonFiTradeError, SwapExactInParams, SwapExactInResult, SwapExactInTransactionPayload, SwapLimit, SwapParameters, Swapping, SwappingMiddleware, SwappingToTon, Symbiosis, SymbiosisTradeType, SynthesizeRequestFinder, THOR_TOKENS, TON_REFERRAL_ADDRESS, TON_STONFI_PROXY_ADDRESS, TON_TOKEN_DECIMALS, TRON_PORTAL_ABI, TRON_TRC20_ABI, ThorChainError, Token, TokenAmount, TokenInfo, TonTransactionData, Trade$1 as Trade, TradeAContext, TradeError, TradeOptions, TradeType, TronRevertResponse, TronTransactionData, UniV2TradeError, UniV3TradeError, VolumeFeeCollector, WETH, WETH_ONLY, WrapBodyParams, WrapTradeError, ZERO, ZERO_FEE_COLLECTOR_ADDRESSES, Zapping, ZappingBtc, ZappingThor, addSolanaFee, aggregatorErrorToText, basisPointsToPercent, buildMetaSynthesize, buildSynthesize, calculateGasMargin, calculatePriceImpact, callDataToCell, chains, computeSlippageAdjustedAmounts, computeTradePriceBreakdown, config as dev, findSourceChainData, fromBtcSwap, getAddress, getAllPairCombinations, getBtcPortalFee, getChainById, getExternalId, getInternalId, getLogWithTimeout, getMinAmount, getMulticall, getPkScript, getPkScriptForChain, getSolanaConnection, getThreshold, getToBtcFee, getTokenAmountUsd, getTokenPriceUsd, getUnwrapDustLimit, getZkCreate2Address, inputOutputComparator, isBtcChainId, isEvmChainId, isFromBtcSwapSupported, isSolanaChainId, isSynthesizeV2, isTonChainId, isTronChain, isTronChainId, isTronToken, isWTon, config$2 as mainnet, prepareTronTransaction, splitSlippage, swapExactIn, config$1 as testnet, tokenEquals, tonAdvisorMock, tradeComparator, tronAddressToEvm, waitForBtcCommitTxMined, waitForBtcDepositAccepted, waitForBtcEvmTxIssued, waitForComplete, waitFromTonTxMined, wrappedAmount, wrappedToken };
