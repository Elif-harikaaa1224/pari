"use strict";Object.defineProperty(exports, "__esModule", {value: true}); var _class;// src/Client.ts
var _async = require('@chainflip/utils/async');


var _commoncjs = require('./common.cjs');
var Client = (_class = class {
  constructor(url, opts = {}) {;_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);
    this.url = url;
    this.archiveNodeUrl = opts.archiveNodeUrl;
  }
  __init() {this.lastRequestId = 0}
  __init2() {this.timer = null}
  __init3() {this.requestMap = /* @__PURE__ */ new Map()}
  
  __init4() {this.eventTarget = new EventTarget()}
  getRequestId() {
    try {
      return crypto.randomUUID();
    } catch (e) {
      return String(++this.lastRequestId);
    }
  }
  formatRequest(method, params) {
    return { jsonrpc: "2.0", id: this.getRequestId(), method, params };
  }
  handleResponse(response, clonedMap) {
    const clonedItem = clonedMap.get(response.id);
    if (!clonedItem) return;
    clonedMap.delete(response.id);
    if (!response.success) {
      return clonedItem.deferred.reject(response.error);
    }
    const rpcResponse = response.result;
    if ("error" in rpcResponse) {
      return clonedItem.deferred.reject(
        new Error(`RPC error [${rpcResponse.error.code}]: ${rpcResponse.error.message}`)
      );
    }
    const parseResult = _commoncjs.rpcResult[clonedItem.method].safeParse(rpcResponse.result);
    if (parseResult.error) {
      return clonedItem.deferred.reject(parseResult.error);
    }
    clonedItem.deferred.resolve(parseResult.data);
  }
  handleErrorResponse(error, clonedMap) {
    for (const [id] of clonedMap) {
      this.handleResponse({ id, success: false, error }, clonedMap);
    }
  }
  async handleBatch() {
    const clonedMap = new Map(this.requestMap);
    this.requestMap.clear();
    const requests = [...clonedMap.values()].map((item) => item.body);
    await this.send(requests, clonedMap);
    clonedMap.forEach((item) => {
      item.deferred.reject(new Error("Could not find the result for the request"));
    });
  }
  sendRequest(method, ...params) {
    if (!_commoncjs.rpcResult[method]) {
      return Promise.reject(new Error(`Unknown method: ${method}`));
    }
    const deferred = _async.deferredPromise.call(void 0, );
    const body = this.formatRequest(method, params);
    this.requestMap.set(body.id, { deferred, body, method });
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.timer = null;
        void this.handleBatch();
      }, 0);
    }
    return deferred.promise.catch((error) => {
      if (error instanceof Error) {
        if (this.archiveNodeUrl && error.message.includes("Unknown block: State already discarded")) {
          this.eventTarget.dispatchEvent(
            new CustomEvent("archiveNodeFallback", { detail: { method, params } })
          );
          return new this.constructor(
            this.archiveNodeUrl
          ).sendRequest(method, ...params);
        }
        Error.captureStackTrace(error);
      }
      throw error;
    });
  }
  methods() {
    return Object.keys(_commoncjs.rpcResult).sort();
  }
}, _class);


exports.default = Client;
