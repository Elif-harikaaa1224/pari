// src/Client.ts
import { deferredPromise } from "@chainflip/utils/async";
import {
  rpcResult
} from "./common.mjs";
var Client = class {
  constructor(url, opts = {}) {
    this.url = url;
    this.archiveNodeUrl = opts.archiveNodeUrl;
  }
  lastRequestId = 0;
  timer = null;
  requestMap = /* @__PURE__ */ new Map();
  archiveNodeUrl;
  eventTarget = new EventTarget();
  getRequestId() {
    try {
      return crypto.randomUUID();
    } catch {
      return String(++this.lastRequestId);
    }
  }
  formatRequest(method, params) {
    return { jsonrpc: "2.0", id: this.getRequestId(), method, params };
  }
  handleResponse(response, clonedMap) {
    const clonedItem = clonedMap.get(response.id);
    if (!clonedItem) return;
    clonedMap.delete(response.id);
    if (!response.success) {
      return clonedItem.deferred.reject(response.error);
    }
    const rpcResponse = response.result;
    if ("error" in rpcResponse) {
      return clonedItem.deferred.reject(
        new Error(`RPC error [${rpcResponse.error.code}]: ${rpcResponse.error.message}`)
      );
    }
    const parseResult = rpcResult[clonedItem.method].safeParse(rpcResponse.result);
    if (parseResult.error) {
      return clonedItem.deferred.reject(parseResult.error);
    }
    clonedItem.deferred.resolve(parseResult.data);
  }
  handleErrorResponse(error, clonedMap) {
    for (const [id] of clonedMap) {
      this.handleResponse({ id, success: false, error }, clonedMap);
    }
  }
  async handleBatch() {
    const clonedMap = new Map(this.requestMap);
    this.requestMap.clear();
    const requests = [...clonedMap.values()].map((item) => item.body);
    await this.send(requests, clonedMap);
    clonedMap.forEach((item) => {
      item.deferred.reject(new Error("Could not find the result for the request"));
    });
  }
  sendRequest(method, ...params) {
    if (!rpcResult[method]) {
      return Promise.reject(new Error(`Unknown method: ${method}`));
    }
    const deferred = deferredPromise();
    const body = this.formatRequest(method, params);
    this.requestMap.set(body.id, { deferred, body, method });
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.timer = null;
        void this.handleBatch();
      }, 0);
    }
    return deferred.promise.catch((error) => {
      if (error instanceof Error) {
        if (this.archiveNodeUrl && error.message.includes("Unknown block: State already discarded")) {
          this.eventTarget.dispatchEvent(
            new CustomEvent("archiveNodeFallback", { detail: { method, params } })
          );
          return new this.constructor(
            this.archiveNodeUrl
          ).sendRequest(method, ...params);
        }
        Error.captureStackTrace(error);
      }
      throw error;
    });
  }
  methods() {
    return Object.keys(rpcResult).sort();
  }
};
export {
  Client as default
};
