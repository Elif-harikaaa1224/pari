"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;// src/WsClient.ts
var _async = require('@chainflip/utils/async');
var _zod = require('zod');
var _Clientcjs = require('./Client.cjs'); var _Clientcjs2 = _interopRequireDefault(_Clientcjs);
var _commoncjs = require('./common.cjs');
var CONNECTING = "CONNECTING";
var READY = "READY";
var DISCONNECT = "DISCONNECT";
var WsClient = (_class = class extends _Clientcjs2.default {
  
  __init() {this.reconnectAttempts = 0}
  __init2() {this.emitter = new EventTarget()}
  __init3() {this.inFlightRequestMap = /* @__PURE__ */ new Map()}
  
  __init4() {this.shouldConnect = true}
  constructor(url, { timeout = 3e4, ...opts } = {}) {
    super(url, opts);_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);_class.prototype.__init6.call(this);;
    this.timeout = timeout;
  }
  async close() {
    this.shouldConnect = false;
    if (!this.ws) return;
    await this.handleDisconnect();
    const waitForClose = this.ws.readyState === WebSocket.OPEN;
    this.ws.close();
    if (waitForClose) await _async.once.call(void 0, this.ws, "close");
    this.ws = void 0;
  }
  async connectionReady() {
    if (!this.ws) {
      return this.connect();
    }
    if (this.ws.readyState !== WebSocket.OPEN) {
      await _async.once.call(void 0, this.emitter, READY, { timeout: 3e4 });
    }
    return this.ws;
  }
  __init5() {this.handleDisconnect = async () => {
    this.emitter.dispatchEvent(new Event(DISCONNECT));
    this.inFlightRequestMap.forEach((request) => {
      request.reject(new Error("disconnected"));
    });
    this.inFlightRequestMap.clear();
    if (!this.shouldConnect) return;
    const backoff = 250 * 2 ** this.reconnectAttempts;
    await _async.sleep.call(void 0, backoff);
    await this.connect().catch(() => {
      this.reconnectAttempts = Math.min(this.reconnectAttempts + 1, 6);
    });
  }}
  __init6() {this.handleMessage = (data) => {
    const parsedData = JSON.parse(data.data);
    const responses = _zod.z.array(_commoncjs.rpcResponse).safeParse(parsedData);
    if (!responses.success) return;
    for (const response of responses.data) {
      const { id } = response;
      _optionalChain([this, 'access', _6 => _6.inFlightRequestMap, 'access', _7 => _7.get, 'call', _8 => _8(id), 'optionalAccess', _9 => _9.resolve, 'call', _10 => _10(response)]);
    }
  }}
  async connect() {
    this.shouldConnect = true;
    this.emitter.dispatchEvent(new Event(CONNECTING));
    const socket = new WebSocket(this.url);
    this.ws = socket;
    this.ws.addEventListener("message", this.handleMessage);
    let connected = false;
    const handleConnectionError = () => {
      if (!connected) {
        void this.handleDisconnect();
      }
    };
    this.ws.addEventListener("close", this.handleDisconnect, { once: true });
    this.ws.addEventListener("error", handleConnectionError, { once: true });
    await _async.once.call(void 0, this.ws, "open", { timeout: this.timeout });
    connected = true;
    this.ws.addEventListener("error", () => {
      socket.close();
    });
    this.emitter.dispatchEvent(new Event(READY));
    this.ws.removeEventListener("error", handleConnectionError);
    this.reconnectAttempts = 0;
    return socket;
  }
  async send(requests, requestMap) {
    const MAX_RETRIES = 5;
    let socket;
    for (let i = 0; i < MAX_RETRIES; i += 1) {
      try {
        socket = await this.connectionReady();
      } catch (e) {
        continue;
      }
    }
    if (!socket) {
      this.handleErrorResponse(new Error("failed to connect"), requestMap);
      return;
    }
    socket.send(JSON.stringify(requests));
    const promises = [];
    for (const [id] of requestMap) {
      const result = _async.deferredPromise.call(void 0, );
      const controller = new AbortController();
      this.inFlightRequestMap.set(id, result);
      promises.push(
        Promise.race([
          _async.sleep.call(void 0, this.timeout, { signal: controller.signal }).then(
            () => ({ id, success: false, error: new Error("timeout") })
          ),
          result.promise.then(
            (r) => ({ id, success: true, result: r }),
            (error) => ({ id, success: false, error })
          )
        ]).then((response) => {
          this.handleResponse(response, requestMap);
        }).finally(() => {
          this.inFlightRequestMap.delete(id);
          controller.abort();
        })
      );
    }
    await Promise.all(promises);
  }
}, _class);


exports.default = WsClient;
