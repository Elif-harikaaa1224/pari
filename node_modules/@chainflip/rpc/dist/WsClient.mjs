// src/WsClient.ts
import { deferredPromise, once, sleep } from "@chainflip/utils/async";
import { z } from "zod";
import Client from "./Client.mjs";
import { rpcResponse } from "./common.mjs";
var CONNECTING = "CONNECTING";
var READY = "READY";
var DISCONNECT = "DISCONNECT";
var WsClient = class extends Client {
  ws;
  reconnectAttempts = 0;
  emitter = new EventTarget();
  inFlightRequestMap = /* @__PURE__ */ new Map();
  timeout;
  shouldConnect = true;
  constructor(url, { timeout = 3e4, ...opts } = {}) {
    super(url, opts);
    this.timeout = timeout;
  }
  async close() {
    this.shouldConnect = false;
    if (!this.ws) return;
    await this.handleDisconnect();
    const waitForClose = this.ws.readyState === WebSocket.OPEN;
    this.ws.close();
    if (waitForClose) await once(this.ws, "close");
    this.ws = void 0;
  }
  async connectionReady() {
    if (!this.ws) {
      return this.connect();
    }
    if (this.ws.readyState !== WebSocket.OPEN) {
      await once(this.emitter, READY, { timeout: 3e4 });
    }
    return this.ws;
  }
  handleDisconnect = async () => {
    this.emitter.dispatchEvent(new Event(DISCONNECT));
    this.inFlightRequestMap.forEach((request) => {
      request.reject(new Error("disconnected"));
    });
    this.inFlightRequestMap.clear();
    if (!this.shouldConnect) return;
    const backoff = 250 * 2 ** this.reconnectAttempts;
    await sleep(backoff);
    await this.connect().catch(() => {
      this.reconnectAttempts = Math.min(this.reconnectAttempts + 1, 6);
    });
  };
  handleMessage = (data) => {
    const parsedData = JSON.parse(data.data);
    const responses = z.array(rpcResponse).safeParse(parsedData);
    if (!responses.success) return;
    for (const response of responses.data) {
      const { id } = response;
      this.inFlightRequestMap.get(id)?.resolve(response);
    }
  };
  async connect() {
    this.shouldConnect = true;
    this.emitter.dispatchEvent(new Event(CONNECTING));
    const socket = new WebSocket(this.url);
    this.ws = socket;
    this.ws.addEventListener("message", this.handleMessage);
    let connected = false;
    const handleConnectionError = () => {
      if (!connected) {
        void this.handleDisconnect();
      }
    };
    this.ws.addEventListener("close", this.handleDisconnect, { once: true });
    this.ws.addEventListener("error", handleConnectionError, { once: true });
    await once(this.ws, "open", { timeout: this.timeout });
    connected = true;
    this.ws.addEventListener("error", () => {
      socket.close();
    });
    this.emitter.dispatchEvent(new Event(READY));
    this.ws.removeEventListener("error", handleConnectionError);
    this.reconnectAttempts = 0;
    return socket;
  }
  async send(requests, requestMap) {
    const MAX_RETRIES = 5;
    let socket;
    for (let i = 0; i < MAX_RETRIES; i += 1) {
      try {
        socket = await this.connectionReady();
      } catch {
        continue;
      }
    }
    if (!socket) {
      this.handleErrorResponse(new Error("failed to connect"), requestMap);
      return;
    }
    socket.send(JSON.stringify(requests));
    const promises = [];
    for (const [id] of requestMap) {
      const result = deferredPromise();
      const controller = new AbortController();
      this.inFlightRequestMap.set(id, result);
      promises.push(
        Promise.race([
          sleep(this.timeout, { signal: controller.signal }).then(
            () => ({ id, success: false, error: new Error("timeout") })
          ),
          result.promise.then(
            (r) => ({ id, success: true, result: r }),
            (error) => ({ id, success: false, error })
          )
        ]).then((response) => {
          this.handleResponse(response, requestMap);
        }).finally(() => {
          this.inFlightRequestMap.delete(id);
          controller.abort();
        })
      );
    }
    await Promise.all(promises);
  }
};
export {
  WsClient as default
};
