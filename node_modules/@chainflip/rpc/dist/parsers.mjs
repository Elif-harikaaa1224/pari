// src/parsers.ts
import { priceAssets } from "@chainflip/utils/chainflip";
import { isUndefined } from "@chainflip/utils/guard";
import { isHex } from "@chainflip/utils/string";
import { z } from "zod";
var hexString = z.string().refine(isHex, { message: "Invalid hex string" });
var u256 = hexString.transform((value) => BigInt(value));
var numericString = z.string().regex(/^[0-9]+$/);
var numberOrHex = z.union([z.number(), u256, numericString]).transform((n) => BigInt(n));
var chainAssetMapFactory = (parser, _defaultValue) => z.object({
  Bitcoin: z.object({ BTC: parser }),
  Ethereum: z.object({ ETH: parser, USDC: parser, FLIP: parser, USDT: parser }),
  Polkadot: z.object({ DOT: parser }),
  Arbitrum: z.object({ ETH: parser, USDC: parser }),
  Solana: z.object({ SOL: parser, USDC: parser }),
  Assethub: z.object({ DOT: parser, USDC: parser, USDT: parser })
}).omit({ Polkadot: true });
var chainBaseAssetMapFactory = (parser, _defaultValue) => z.object({
  Bitcoin: z.object({ BTC: parser }),
  Ethereum: z.object({ ETH: parser, FLIP: parser, USDT: parser }),
  Polkadot: z.object({ DOT: parser }),
  Arbitrum: z.object({ ETH: parser, USDC: parser }),
  Solana: z.object({ SOL: parser, USDC: parser }),
  Assethub: z.object({ DOT: parser, USDC: parser, USDT: parser })
}).omit({ Polkadot: true });
var chainMapFactory = (parser, _defaultValue) => z.object({
  Bitcoin: parser,
  Ethereum: parser,
  Polkadot: parser,
  Arbitrum: parser,
  Solana: parser,
  Assethub: parser
}).omit({ Polkadot: true });
var rpcAssetSchema = z.union([
  z.object({ chain: z.literal("Bitcoin"), asset: z.literal("BTC") }),
  z.object({ chain: z.literal("Polkadot"), asset: z.literal("DOT") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("FLIP") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("ETH") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDC") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDT") }),
  z.object({ chain: z.literal("Arbitrum"), asset: z.literal("ETH") }),
  z.object({ chain: z.literal("Arbitrum"), asset: z.literal("USDC") }),
  z.object({ chain: z.literal("Solana"), asset: z.literal("SOL") }),
  z.object({ chain: z.literal("Solana"), asset: z.literal("USDC") }),
  z.object({ chain: z.literal("Assethub"), asset: z.literal("DOT") }),
  z.object({ chain: z.literal("Assethub"), asset: z.literal("USDC") }),
  z.object({ chain: z.literal("Assethub"), asset: z.literal("USDT") })
]);
var networkFee = z.object({
  standard_rate_and_minimum: z.object({
    rate: numberOrHex,
    minimum: numberOrHex
  }),
  rates: chainAssetMapFactory(numberOrHex, 0)
});
var networkFees = z.object({
  regular_network_fee: networkFee,
  internal_swap_network_fee: networkFee
});
var rename = (mapping) => (obj) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [
    key in mapping ? mapping[key] : key,
    value
  ])
);
var rpcBaseResponse = z.object({
  id: z.string(),
  jsonrpc: z.literal("2.0")
});
var notUndefined = z.any().refine((v) => !isUndefined(v), { message: "Value must not be undefined" });
var rpcSuccessResponse = rpcBaseResponse.extend({ result: notUndefined });
var rpcErrorResponse = rpcBaseResponse.extend({
  error: z.object({ code: z.number(), message: z.string() })
});
var rpcResponse = z.union([rpcSuccessResponse, rpcErrorResponse]);
var cfSwapRate = z.object({
  intermediary: numberOrHex.nullable(),
  output: numberOrHex
});
var fee = z.intersection(rpcAssetSchema, z.object({ amount: numberOrHex }));
var cfSwapRateV2 = z.object({
  egress_fee: fee,
  ingress_fee: fee,
  intermediary: u256.nullable(),
  network_fee: fee,
  output: u256
});
var cfSwapRateV3 = cfSwapRateV2.extend({
  broker_commission: fee
});
var chainGetBlockHash = hexString;
var stateGetMetadata = hexString;
var stateGetRuntimeVersion = z.object({
  specName: z.string(),
  implName: z.string(),
  authoringVersion: z.number(),
  specVersion: z.number(),
  implVersion: z.number(),
  apis: z.array(z.tuple([hexString, z.number()])),
  transactionVersion: z.number(),
  stateVersion: z.number()
});
var cfIngressEgressEnvironment = z.object({
  minimum_deposit_amounts: chainAssetMapFactory(numberOrHex, 0),
  ingress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  egress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  witness_safety_margins: chainMapFactory(z.number().nullable(), null),
  egress_dust_limits: chainAssetMapFactory(numberOrHex, 0),
  channel_opening_fees: chainMapFactory(numberOrHex, 0)
}).transform(rename({ egress_dust_limits: "minimum_egress_amounts" }));
var cfSwappingEnvironment = z.object({
  maximum_swap_amounts: chainAssetMapFactory(numberOrHex.nullable(), null),
  network_fee_hundredth_pips: z.number(),
  swap_retry_delay_blocks: z.number().optional(),
  max_swap_retry_duration_blocks: z.number().optional(),
  max_swap_request_duration_blocks: z.number().optional(),
  minimum_chunk_size: chainAssetMapFactory(numberOrHex.nullable(), null).optional(),
  network_fees: networkFees
});
var cfFundingEnvironment = z.object({
  redemption_tax: numberOrHex,
  minimum_funding_amount: numberOrHex
});
var defaultFeeInfo = () => ({
  limit_order_fee_hundredth_pips: 0,
  range_order_fee_hundredth_pips: 0,
  range_order_total_fees_earned: { base: "0x0", quote: "0x0" },
  limit_order_total_fees_earned: { base: "0x0", quote: "0x0" },
  range_total_swap_inputs: { base: "0x0", quote: "0x0" },
  limit_total_swap_inputs: { base: "0x0", quote: "0x0" },
  quote_asset: { chain: "Ethereum", asset: "USDC" }
});
var cfPoolsEnvironment = z.object({
  fees: chainBaseAssetMapFactory(
    z.object({
      limit_order_fee_hundredth_pips: z.number(),
      range_order_fee_hundredth_pips: z.number(),
      range_order_total_fees_earned: z.object({ base: u256, quote: u256 }),
      limit_order_total_fees_earned: z.object({ base: u256, quote: u256 }),
      range_total_swap_inputs: z.object({ base: u256, quote: u256 }),
      limit_total_swap_inputs: z.object({ base: u256, quote: u256 }),
      quote_asset: z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDC") })
    }).nullable().transform((info) => info ?? defaultFeeInfo()),
    defaultFeeInfo()
  )
});
var cfEnvironment = z.object({
  ingress_egress: cfIngressEgressEnvironment,
  swapping: cfSwappingEnvironment,
  funding: cfFundingEnvironment,
  pools: cfPoolsEnvironment
});
var cfBoostPoolsDepth = z.array(
  z.intersection(rpcAssetSchema, z.object({ tier: z.number(), available_amount: u256 }))
);
var orderInfoSchema = z.object({
  depth: numberOrHex,
  price: numberOrHex.nullable()
});
var assetInfoSchema = z.object({
  limit_orders: orderInfoSchema,
  range_orders: orderInfoSchema
});
var cfPoolDepth = z.object({
  asks: assetInfoSchema,
  bids: assetInfoSchema
}).nullable();
var cfSupportedAssets = z.array(z.object({ chain: z.string(), asset: z.string() })).transform(
  (assets) => assets.filter((asset) => rpcAssetSchema.safeParse(asset).success)
);
var brokerRequestSwapDepositAddress = z.object({
  address: z.string(),
  issued_block: z.number(),
  channel_id: z.number(),
  source_chain_expiry_block: numberOrHex,
  channel_opening_fee: u256
});
var evmBrokerRequestSwapParameterEncoding = z.object({
  to: hexString,
  calldata: hexString,
  value: numberOrHex,
  source_token_address: hexString.optional()
});
var requestSwapParameterEncoding = z.discriminatedUnion("chain", [
  z.object({
    chain: z.literal("Bitcoin"),
    nulldata_payload: hexString,
    deposit_address: z.string()
  }),
  evmBrokerRequestSwapParameterEncoding.extend({
    chain: z.literal("Ethereum")
  }),
  evmBrokerRequestSwapParameterEncoding.extend({
    chain: z.literal("Arbitrum")
  }),
  z.object({
    chain: z.literal("Solana"),
    program_id: z.string(),
    data: hexString,
    accounts: z.array(
      z.object({
        pubkey: z.string(),
        is_signer: z.boolean(),
        is_writable: z.boolean()
      })
    )
  })
]);
var accountId = z.string().refine((val) => val.startsWith("cF"));
var delegationStatus = z.object({
  operator: accountId,
  bid: numberOrHex
});
var accountInfoCommon = {
  vanity_name: z.string().optional(),
  flip_balance: numberOrHex,
  asset_balances: chainAssetMapFactory(numberOrHex, 0),
  bond: numberOrHex,
  estimated_redeemable_balance: numberOrHex,
  bound_redeem_address: hexString.optional(),
  restricted_balances: z.record(hexString, numberOrHex).optional(),
  current_delegation_status: delegationStatus.optional(),
  upcoming_delegation_status: delegationStatus.optional()
};
var unregistered = z.object({
  role: z.literal("unregistered"),
  ...accountInfoCommon
});
var broker = z.object({
  role: z.literal("broker"),
  ...accountInfoCommon,
  earned_fees: chainAssetMapFactory(numberOrHex, 0),
  btc_vault_deposit_address: z.string().nullable().optional(),
  affiliates: z.array(z.object({ account_id: accountId, short_id: z.number(), withdrawal_address: hexString })).optional().default([])
});
var operator = z.object({
  role: z.literal("operator"),
  ...accountInfoCommon,
  managed_validators: z.record(accountId, numberOrHex),
  delegators: z.record(accountId, numberOrHex),
  settings: z.object({
    fee_bps: z.number(),
    delegation_acceptance: z.enum(["Allow", "Deny"])
  }),
  allowed: z.array(accountId).optional().default([]),
  blocked: z.array(accountId).optional().default([]),
  active_delegation: z.object({
    operator: accountId,
    validators: z.record(accountId, numberOrHex),
    delegators: z.record(accountId, numberOrHex),
    delegation_fee_bps: z.number()
  }).optional()
});
var boostBalances = z.array(
  z.object({
    fee_tier: z.number(),
    total_balance: u256,
    available_balance: u256,
    in_use_balance: u256,
    is_withdrawing: z.boolean()
  })
);
var liquidityProvider = z.object({
  role: z.literal("liquidity_provider"),
  ...accountInfoCommon,
  refund_addresses: chainMapFactory(z.string().nullable(), null),
  earned_fees: chainAssetMapFactory(numberOrHex, 0),
  boost_balances: chainAssetMapFactory(boostBalances, []),
  lending_positions: z.array(
    z.intersection(
      rpcAssetSchema,
      z.object({
        total_amount: numberOrHex,
        available_amount: numberOrHex
      })
    )
  ).optional(),
  collateral_balances: z.array(
    z.intersection(
      rpcAssetSchema,
      z.object({
        amount: numberOrHex
      })
    )
  ).optional()
});
var validator = z.object({
  role: z.literal("validator"),
  ...accountInfoCommon,
  last_heartbeat: z.number(),
  reputation_points: z.number(),
  keyholder_epochs: z.array(z.number()),
  is_current_authority: z.boolean(),
  is_current_backup: z.boolean(),
  is_qualified: z.boolean(),
  is_online: z.boolean(),
  is_bidding: z.boolean(),
  apy_bp: z.number().nullable(),
  operator: accountId.optional()
});
var cfAccountInfo = z.discriminatedUnion("role", [unregistered, broker, operator, liquidityProvider, validator]).transform((account) => {
  switch (account.role) {
    case "broker":
    case "validator":
    case "unregistered":
    case "liquidity_provider":
      return account;
    case "operator": {
      const { managed_validators, delegators, settings, ...rest } = account;
      return {
        ...rest,
        upcoming_delegation: {
          validators: managed_validators,
          delegators,
          delegation_fee_bps: settings.fee_bps,
          delegation_acceptance: settings.delegation_acceptance
        }
      };
    }
  }
});
var cfAccounts = z.array(z.tuple([z.string(), z.string()]));
var cfPoolPriceV2 = z.object({
  sell: numberOrHex.nullable(),
  buy: numberOrHex.nullable(),
  range_order: numberOrHex,
  base_asset: rpcAssetSchema,
  quote_asset: rpcAssetSchema
});
var orderId = numberOrHex.transform((n) => String(n));
var limitOrder = z.object({
  id: orderId,
  tick: z.number(),
  sell_amount: numberOrHex,
  fees_earned: numberOrHex,
  original_sell_amount: numberOrHex,
  lp: z.string()
});
var ask = limitOrder.transform((order) => ({
  ...order,
  type: "ask"
}));
var bid = limitOrder.transform((order) => ({
  ...order,
  type: "bid"
}));
var rangeOrder = z.object({
  id: orderId,
  range: z.object({ start: z.number(), end: z.number() }),
  liquidity: numberOrHex,
  fees_earned: z.object({ base: numberOrHex, quote: numberOrHex }),
  lp: z.string()
}).transform((order) => ({ ...order, type: "range" }));
var cfPoolOrders = z.object({
  limit_orders: z.object({
    asks: z.array(ask),
    bids: z.array(bid)
  }),
  range_orders: z.array(rangeOrder)
});
var boostPoolAmount = z.object({
  account_id: z.string(),
  amount: u256
});
var cfBoostPoolDetails = z.array(
  z.intersection(
    rpcAssetSchema,
    z.object({
      fee_tier: z.number(),
      available_amounts: z.array(boostPoolAmount),
      deposits_pending_finalization: z.array(
        z.object({
          deposit_id: numberOrHex,
          owed_amounts: z.array(boostPoolAmount)
        })
      ),
      pending_withdrawals: z.array(
        z.object({
          account_id: z.string(),
          pending_deposits: z.array(numberOrHex)
        })
      ),
      network_fee_deduction_percent: z.number().optional()
    })
  )
);
var cfBoostPoolPendingFees = z.array(
  z.intersection(
    rpcAssetSchema,
    z.object({
      fee_tier: z.number(),
      pending_fees: z.array(
        z.object({
          deposit_id: z.number().transform(BigInt),
          fees: z.array(boostPoolAmount)
        })
      )
    })
  )
);
var lpTotalBalances = chainAssetMapFactory(numberOrHex, 0);
var cfFailedCallEvm = z.object({
  contract: hexString,
  data: z.string()
});
var range = (parser) => z.tuple([parser, parser]);
var cfAuctionState = z.object({
  epoch_duration: z.number(),
  current_epoch_started_at: z.number(),
  redemption_period_as_percentage: z.number(),
  min_funding: numberOrHex,
  auction_size_range: range(z.number()),
  min_active_bid: numberOrHex.nullable(),
  min_bid: numberOrHex
}).transform(rename({ epoch_duration: "epoch_duration_blocks" }));
var cfMonitoringSimulateAuction = z.object({
  auction_outcome: z.object({
    winners: z.array(accountId),
    bond: numberOrHex
  }),
  operators_info: z.record(
    accountId,
    z.object({
      operator: accountId,
      validators: z.record(accountId, numberOrHex),
      delegators: z.record(accountId, numberOrHex),
      delegation_fee_bps: z.number()
    })
  ),
  new_validators: z.array(accountId),
  current_mab: numberOrHex
});
var cfFlipSuppy = range(numberOrHex).transform(([totalIssuance, offchainFunds]) => ({
  totalIssuance,
  offchainFunds
}));
var ethereumAddress = z.string().transform((address) => `0x${address}`);
var cfPoolOrderbook = z.object({
  bids: z.array(z.object({ amount: u256, sqrt_price: u256 })),
  asks: z.array(z.object({ amount: u256, sqrt_price: u256 }))
});
var cfTradingStrategy = z.object({
  lp_id: z.string(),
  strategy_id: z.string(),
  strategy: z.union([
    z.object({
      TickZeroCentered: z.object({
        spread_tick: z.number(),
        base_asset: rpcAssetSchema
      })
    }),
    z.object({
      SimpleBuySell: z.object({
        buy_tick: z.number(),
        sell_tick: z.number(),
        base_asset: rpcAssetSchema
      })
    }),
    z.object({
      InventoryBased: z.object({
        min_buy_tick: z.number(),
        max_buy_tick: z.number(),
        min_sell_tick: z.number(),
        max_sell_tick: z.number(),
        base_asset: rpcAssetSchema
      })
    })
  ]),
  balance: z.array(z.tuple([rpcAssetSchema, numberOrHex]))
});
var cfGetTradingStrategies = z.array(cfTradingStrategy).default([]);
var cfGetTradingStrategyLimits = z.object({
  minimum_deployment_amount: chainAssetMapFactory(z.number().nullable(), null),
  minimum_added_funds_amount: chainAssetMapFactory(z.number().nullable(), null)
});
var cfAvailablePools = z.array(
  z.object({
    base: rpcAssetSchema.refine(
      (a) => a.chain !== "Ethereum" || a.asset !== "USDC"
    ),
    quote: z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDC") })
  })
);
var cfOraclePrices = z.array(
  z.object({
    price: numberOrHex,
    updated_at_oracle_timestamp: z.number(),
    updated_at_statechain_block: z.number(),
    base_asset: z.enum(priceAssets),
    quote_asset: z.enum(priceAssets)
  })
);
var broadcastPalletSafeModeStatuses = z.object({
  retry_enabled: z.boolean(),
  egress_witnessing_enabled: z.boolean()
});
var ingressEgressPalletSafeModeStatuses = z.object({
  boost_deposits_enabled: z.boolean(),
  deposit_channel_creation_enabled: z.boolean(),
  deposit_channel_witnessing_enabled: z.boolean(),
  vault_deposit_witnessing_enabled: z.boolean()
});
var cfSafeModeStatuses = z.object({
  emissions: z.object({
    emissions_sync_enabled: z.boolean()
  }),
  funding: z.object({
    redeem_enabled: z.boolean()
  }),
  swapping: z.object({
    swaps_enabled: z.boolean(),
    withdrawals_enabled: z.boolean(),
    broker_registration_enabled: z.boolean()
  }),
  liquidity_provider: z.object({
    deposit_enabled: z.boolean(),
    withdrawal_enabled: z.boolean(),
    internal_swaps_enabled: z.boolean()
  }),
  validator: z.object({
    authority_rotation_enabled: z.boolean(),
    start_bidding_enabled: z.boolean(),
    stop_bidding_enabled: z.boolean()
  }),
  pools: z.object({
    range_order_update_enabled: z.boolean(),
    limit_order_update_enabled: z.boolean()
  }),
  trading_strategies: z.object({
    strategy_updates_enabled: z.boolean(),
    strategy_closure_enabled: z.boolean(),
    strategy_execution_enabled: z.boolean()
  }),
  reputation: z.object({
    reporting_enabled: z.boolean()
  }),
  asset_balances: z.object({
    reconciliation_enabled: z.boolean()
  }),
  threshold_signature_evm: z.object({
    slashing_enabled: z.boolean()
  }),
  threshold_signature_bitcoin: z.object({
    slashing_enabled: z.boolean()
  }),
  threshold_signature_polkadot: z.object({
    slashing_enabled: z.boolean()
  }),
  threshold_signature_solana: z.object({
    slashing_enabled: z.boolean()
  }),
  lending_pools: z.object({
    add_boost_funds_enabled: z.boolean(),
    stop_boosting_enabled: z.boolean(),
    // TODO(1.12): remove `optional` after all networks upgraded
    borrowing_enabled: z.array(rpcAssetSchema).optional(),
    add_lender_funds_enabled: z.array(rpcAssetSchema).optional(),
    withdraw_lender_funds_enabled: z.array(rpcAssetSchema).optional(),
    add_collateral_enabled: z.array(rpcAssetSchema).optional(),
    remove_collateral_enabled: z.array(rpcAssetSchema).optional()
  }),
  broadcast_ethereum: broadcastPalletSafeModeStatuses,
  broadcast_bitcoin: broadcastPalletSafeModeStatuses,
  broadcast_polkadot: broadcastPalletSafeModeStatuses,
  broadcast_arbitrum: broadcastPalletSafeModeStatuses,
  broadcast_solana: broadcastPalletSafeModeStatuses,
  broadcast_assethub: broadcastPalletSafeModeStatuses,
  ingress_egress_ethereum: ingressEgressPalletSafeModeStatuses,
  ingress_egress_bitcoin: ingressEgressPalletSafeModeStatuses,
  ingress_egress_polkadot: ingressEgressPalletSafeModeStatuses,
  ingress_egress_arbitrum: ingressEgressPalletSafeModeStatuses,
  ingress_egress_solana: ingressEgressPalletSafeModeStatuses,
  ingress_egress_assethub: ingressEgressPalletSafeModeStatuses,
  witnesser: z.enum(["CodeRed", "CodeGreen", "CodeAmber"]),
  elections_generic: z.object({
    oracle_price_elections: z.boolean()
  })
});
var cfLendingPools = z.array(
  z.object({
    asset: rpcAssetSchema,
    total_amount: numberOrHex,
    available_amount: numberOrHex,
    utilisation_rate: z.number(),
    current_interest_rate: z.number(),
    origination_fee: z.number(),
    liquidation_fee: z.number(),
    interest_rate_curve: z.object({
      interest_at_zero_utilisation: z.number(),
      junction_utilisation: z.number(),
      interest_at_junction_utilisation: z.number(),
      interest_at_max_utilisation: z.number()
    })
  })
);
var cfLendingConfig = z.object({
  ltv_thresholds: z.object({
    target: z.number(),
    topup: z.number(),
    soft_liquidation: z.number(),
    soft_liquidation_abort: z.number(),
    hard_liquidation: z.number(),
    hard_liquidation_abort: z.number(),
    low_ltv: z.number()
  }),
  network_fee_contributions: z.object({
    extra_interest: z.number(),
    interest_on_collateral_max: z.number(),
    from_origination_fee: z.number(),
    from_liquidation_fee: z.number()
  }),
  fee_swap_interval_blocks: z.number(),
  interest_payment_interval_blocks: z.number(),
  fee_swap_threshold_usd: numberOrHex,
  interest_collection_threshold_usd: numberOrHex,
  liquidation_swap_chunk_size_usd: numberOrHex,
  soft_liquidation_max_oracle_slippage: z.number(),
  hard_liquidation_max_oracle_slippage: z.number(),
  fee_swap_max_oracle_slippage: z.number()
});
var cfLoanAccount = z.object({
  account: accountId,
  primary_collateral_asset: rpcAssetSchema,
  ltv_ratio: numberOrHex,
  collateral: z.array(
    z.intersection(
      rpcAssetSchema,
      z.object({
        amount: numberOrHex
      })
    )
  ),
  loans: z.array(
    z.object({
      loan_id: z.number(),
      asset: rpcAssetSchema,
      created_at: z.number(),
      principal_amount: numberOrHex
    })
  ),
  liquidation_status: z.object({
    liquidation_swaps: z.array(
      z.object({
        swap_request_id: z.number(),
        loan_id: z.number()
      })
    ),
    is_hard: z.boolean()
  }).nullable()
});
var cfLoanAccounts = z.array(cfLoanAccount);
export {
  accountInfoCommon,
  broker,
  brokerRequestSwapDepositAddress,
  cfAccountInfo,
  cfAccounts,
  cfAuctionState,
  cfAvailablePools,
  cfBoostPoolDetails,
  cfBoostPoolPendingFees,
  cfBoostPoolsDepth,
  cfEnvironment,
  cfFailedCallEvm,
  cfFlipSuppy,
  cfFundingEnvironment,
  cfGetTradingStrategies,
  cfGetTradingStrategyLimits,
  cfIngressEgressEnvironment,
  cfLendingConfig,
  cfLendingPools,
  cfLoanAccount,
  cfLoanAccounts,
  cfMonitoringSimulateAuction,
  cfOraclePrices,
  cfPoolDepth,
  cfPoolOrderbook,
  cfPoolOrders,
  cfPoolPriceV2,
  cfPoolsEnvironment,
  cfSafeModeStatuses,
  cfSupportedAssets,
  cfSwapRate,
  cfSwapRateV2,
  cfSwapRateV3,
  cfSwappingEnvironment,
  cfTradingStrategy,
  chainGetBlockHash,
  ethereumAddress,
  hexString,
  liquidityProvider,
  lpTotalBalances,
  numberOrHex,
  numericString,
  operator,
  requestSwapParameterEncoding,
  rpcResponse,
  stateGetMetadata,
  stateGetRuntimeVersion,
  u256,
  unregistered,
  validator
};
