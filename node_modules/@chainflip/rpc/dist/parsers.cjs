"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/parsers.ts
var _chainflip = require('@chainflip/utils/chainflip');
var _guard = require('@chainflip/utils/guard');
var _string = require('@chainflip/utils/string');
var _zod = require('zod');
var hexString = _zod.z.string().refine(_string.isHex, { message: "Invalid hex string" });
var u256 = hexString.transform((value) => BigInt(value));
var numericString = _zod.z.string().regex(/^[0-9]+$/);
var numberOrHex = _zod.z.union([_zod.z.number(), u256, numericString]).transform((n) => BigInt(n));
var chainAssetMapFactory = (parser, _defaultValue) => _zod.z.object({
  Bitcoin: _zod.z.object({ BTC: parser }),
  Ethereum: _zod.z.object({ ETH: parser, USDC: parser, FLIP: parser, USDT: parser }),
  Polkadot: _zod.z.object({ DOT: parser }),
  Arbitrum: _zod.z.object({ ETH: parser, USDC: parser }),
  Solana: _zod.z.object({ SOL: parser, USDC: parser }),
  Assethub: _zod.z.object({ DOT: parser, USDC: parser, USDT: parser })
}).omit({ Polkadot: true });
var chainBaseAssetMapFactory = (parser, _defaultValue) => _zod.z.object({
  Bitcoin: _zod.z.object({ BTC: parser }),
  Ethereum: _zod.z.object({ ETH: parser, FLIP: parser, USDT: parser }),
  Polkadot: _zod.z.object({ DOT: parser }),
  Arbitrum: _zod.z.object({ ETH: parser, USDC: parser }),
  Solana: _zod.z.object({ SOL: parser, USDC: parser }),
  Assethub: _zod.z.object({ DOT: parser, USDC: parser, USDT: parser })
}).omit({ Polkadot: true });
var chainMapFactory = (parser, _defaultValue) => _zod.z.object({
  Bitcoin: parser,
  Ethereum: parser,
  Polkadot: parser,
  Arbitrum: parser,
  Solana: parser,
  Assethub: parser
}).omit({ Polkadot: true });
var rpcAssetSchema = _zod.z.union([
  _zod.z.object({ chain: _zod.z.literal("Bitcoin"), asset: _zod.z.literal("BTC") }),
  _zod.z.object({ chain: _zod.z.literal("Polkadot"), asset: _zod.z.literal("DOT") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("FLIP") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("ETH") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDC") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDT") }),
  _zod.z.object({ chain: _zod.z.literal("Arbitrum"), asset: _zod.z.literal("ETH") }),
  _zod.z.object({ chain: _zod.z.literal("Arbitrum"), asset: _zod.z.literal("USDC") }),
  _zod.z.object({ chain: _zod.z.literal("Solana"), asset: _zod.z.literal("SOL") }),
  _zod.z.object({ chain: _zod.z.literal("Solana"), asset: _zod.z.literal("USDC") }),
  _zod.z.object({ chain: _zod.z.literal("Assethub"), asset: _zod.z.literal("DOT") }),
  _zod.z.object({ chain: _zod.z.literal("Assethub"), asset: _zod.z.literal("USDC") }),
  _zod.z.object({ chain: _zod.z.literal("Assethub"), asset: _zod.z.literal("USDT") })
]);
var networkFee = _zod.z.object({
  standard_rate_and_minimum: _zod.z.object({
    rate: numberOrHex,
    minimum: numberOrHex
  }),
  rates: chainAssetMapFactory(numberOrHex, 0)
});
var networkFees = _zod.z.object({
  regular_network_fee: networkFee,
  internal_swap_network_fee: networkFee
});
var rename = (mapping) => (obj) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [
    key in mapping ? mapping[key] : key,
    value
  ])
);
var rpcBaseResponse = _zod.z.object({
  id: _zod.z.string(),
  jsonrpc: _zod.z.literal("2.0")
});
var notUndefined = _zod.z.any().refine((v) => !_guard.isUndefined.call(void 0, v), { message: "Value must not be undefined" });
var rpcSuccessResponse = rpcBaseResponse.extend({ result: notUndefined });
var rpcErrorResponse = rpcBaseResponse.extend({
  error: _zod.z.object({ code: _zod.z.number(), message: _zod.z.string() })
});
var rpcResponse = _zod.z.union([rpcSuccessResponse, rpcErrorResponse]);
var cfSwapRate = _zod.z.object({
  intermediary: numberOrHex.nullable(),
  output: numberOrHex
});
var fee = _zod.z.intersection(rpcAssetSchema, _zod.z.object({ amount: numberOrHex }));
var cfSwapRateV2 = _zod.z.object({
  egress_fee: fee,
  ingress_fee: fee,
  intermediary: u256.nullable(),
  network_fee: fee,
  output: u256
});
var cfSwapRateV3 = cfSwapRateV2.extend({
  broker_commission: fee
});
var chainGetBlockHash = hexString;
var stateGetMetadata = hexString;
var stateGetRuntimeVersion = _zod.z.object({
  specName: _zod.z.string(),
  implName: _zod.z.string(),
  authoringVersion: _zod.z.number(),
  specVersion: _zod.z.number(),
  implVersion: _zod.z.number(),
  apis: _zod.z.array(_zod.z.tuple([hexString, _zod.z.number()])),
  transactionVersion: _zod.z.number(),
  stateVersion: _zod.z.number()
});
var cfIngressEgressEnvironment = _zod.z.object({
  minimum_deposit_amounts: chainAssetMapFactory(numberOrHex, 0),
  ingress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  egress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  witness_safety_margins: chainMapFactory(_zod.z.number().nullable(), null),
  egress_dust_limits: chainAssetMapFactory(numberOrHex, 0),
  channel_opening_fees: chainMapFactory(numberOrHex, 0)
}).transform(rename({ egress_dust_limits: "minimum_egress_amounts" }));
var cfSwappingEnvironment = _zod.z.object({
  maximum_swap_amounts: chainAssetMapFactory(numberOrHex.nullable(), null),
  network_fee_hundredth_pips: _zod.z.number(),
  swap_retry_delay_blocks: _zod.z.number().optional(),
  max_swap_retry_duration_blocks: _zod.z.number().optional(),
  max_swap_request_duration_blocks: _zod.z.number().optional(),
  minimum_chunk_size: chainAssetMapFactory(numberOrHex.nullable(), null).optional(),
  network_fees: networkFees
});
var cfFundingEnvironment = _zod.z.object({
  redemption_tax: numberOrHex,
  minimum_funding_amount: numberOrHex
});
var defaultFeeInfo = () => ({
  limit_order_fee_hundredth_pips: 0,
  range_order_fee_hundredth_pips: 0,
  range_order_total_fees_earned: { base: "0x0", quote: "0x0" },
  limit_order_total_fees_earned: { base: "0x0", quote: "0x0" },
  range_total_swap_inputs: { base: "0x0", quote: "0x0" },
  limit_total_swap_inputs: { base: "0x0", quote: "0x0" },
  quote_asset: { chain: "Ethereum", asset: "USDC" }
});
var cfPoolsEnvironment = _zod.z.object({
  fees: chainBaseAssetMapFactory(
    _zod.z.object({
      limit_order_fee_hundredth_pips: _zod.z.number(),
      range_order_fee_hundredth_pips: _zod.z.number(),
      range_order_total_fees_earned: _zod.z.object({ base: u256, quote: u256 }),
      limit_order_total_fees_earned: _zod.z.object({ base: u256, quote: u256 }),
      range_total_swap_inputs: _zod.z.object({ base: u256, quote: u256 }),
      limit_total_swap_inputs: _zod.z.object({ base: u256, quote: u256 }),
      quote_asset: _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDC") })
    }).nullable().transform((info) => _nullishCoalesce(info, () => ( defaultFeeInfo()))),
    defaultFeeInfo()
  )
});
var cfEnvironment = _zod.z.object({
  ingress_egress: cfIngressEgressEnvironment,
  swapping: cfSwappingEnvironment,
  funding: cfFundingEnvironment,
  pools: cfPoolsEnvironment
});
var cfBoostPoolsDepth = _zod.z.array(
  _zod.z.intersection(rpcAssetSchema, _zod.z.object({ tier: _zod.z.number(), available_amount: u256 }))
);
var orderInfoSchema = _zod.z.object({
  depth: numberOrHex,
  price: numberOrHex.nullable()
});
var assetInfoSchema = _zod.z.object({
  limit_orders: orderInfoSchema,
  range_orders: orderInfoSchema
});
var cfPoolDepth = _zod.z.object({
  asks: assetInfoSchema,
  bids: assetInfoSchema
}).nullable();
var cfSupportedAssets = _zod.z.array(_zod.z.object({ chain: _zod.z.string(), asset: _zod.z.string() })).transform(
  (assets) => assets.filter((asset) => rpcAssetSchema.safeParse(asset).success)
);
var brokerRequestSwapDepositAddress = _zod.z.object({
  address: _zod.z.string(),
  issued_block: _zod.z.number(),
  channel_id: _zod.z.number(),
  source_chain_expiry_block: numberOrHex,
  channel_opening_fee: u256
});
var evmBrokerRequestSwapParameterEncoding = _zod.z.object({
  to: hexString,
  calldata: hexString,
  value: numberOrHex,
  source_token_address: hexString.optional()
});
var requestSwapParameterEncoding = _zod.z.discriminatedUnion("chain", [
  _zod.z.object({
    chain: _zod.z.literal("Bitcoin"),
    nulldata_payload: hexString,
    deposit_address: _zod.z.string()
  }),
  evmBrokerRequestSwapParameterEncoding.extend({
    chain: _zod.z.literal("Ethereum")
  }),
  evmBrokerRequestSwapParameterEncoding.extend({
    chain: _zod.z.literal("Arbitrum")
  }),
  _zod.z.object({
    chain: _zod.z.literal("Solana"),
    program_id: _zod.z.string(),
    data: hexString,
    accounts: _zod.z.array(
      _zod.z.object({
        pubkey: _zod.z.string(),
        is_signer: _zod.z.boolean(),
        is_writable: _zod.z.boolean()
      })
    )
  })
]);
var accountId = _zod.z.string().refine((val) => val.startsWith("cF"));
var delegationStatus = _zod.z.object({
  operator: accountId,
  bid: numberOrHex
});
var accountInfoCommon = {
  vanity_name: _zod.z.string().optional(),
  flip_balance: numberOrHex,
  asset_balances: chainAssetMapFactory(numberOrHex, 0),
  bond: numberOrHex,
  estimated_redeemable_balance: numberOrHex,
  bound_redeem_address: hexString.optional(),
  restricted_balances: _zod.z.record(hexString, numberOrHex).optional(),
  current_delegation_status: delegationStatus.optional(),
  upcoming_delegation_status: delegationStatus.optional()
};
var unregistered = _zod.z.object({
  role: _zod.z.literal("unregistered"),
  ...accountInfoCommon
});
var broker = _zod.z.object({
  role: _zod.z.literal("broker"),
  ...accountInfoCommon,
  earned_fees: chainAssetMapFactory(numberOrHex, 0),
  btc_vault_deposit_address: _zod.z.string().nullable().optional(),
  affiliates: _zod.z.array(_zod.z.object({ account_id: accountId, short_id: _zod.z.number(), withdrawal_address: hexString })).optional().default([])
});
var operator = _zod.z.object({
  role: _zod.z.literal("operator"),
  ...accountInfoCommon,
  managed_validators: _zod.z.record(accountId, numberOrHex),
  delegators: _zod.z.record(accountId, numberOrHex),
  settings: _zod.z.object({
    fee_bps: _zod.z.number(),
    delegation_acceptance: _zod.z.enum(["Allow", "Deny"])
  }),
  allowed: _zod.z.array(accountId).optional().default([]),
  blocked: _zod.z.array(accountId).optional().default([]),
  active_delegation: _zod.z.object({
    operator: accountId,
    validators: _zod.z.record(accountId, numberOrHex),
    delegators: _zod.z.record(accountId, numberOrHex),
    delegation_fee_bps: _zod.z.number()
  }).optional()
});
var boostBalances = _zod.z.array(
  _zod.z.object({
    fee_tier: _zod.z.number(),
    total_balance: u256,
    available_balance: u256,
    in_use_balance: u256,
    is_withdrawing: _zod.z.boolean()
  })
);
var liquidityProvider = _zod.z.object({
  role: _zod.z.literal("liquidity_provider"),
  ...accountInfoCommon,
  refund_addresses: chainMapFactory(_zod.z.string().nullable(), null),
  earned_fees: chainAssetMapFactory(numberOrHex, 0),
  boost_balances: chainAssetMapFactory(boostBalances, []),
  lending_positions: _zod.z.array(
    _zod.z.intersection(
      rpcAssetSchema,
      _zod.z.object({
        total_amount: numberOrHex,
        available_amount: numberOrHex
      })
    )
  ).optional(),
  collateral_balances: _zod.z.array(
    _zod.z.intersection(
      rpcAssetSchema,
      _zod.z.object({
        amount: numberOrHex
      })
    )
  ).optional()
});
var validator = _zod.z.object({
  role: _zod.z.literal("validator"),
  ...accountInfoCommon,
  last_heartbeat: _zod.z.number(),
  reputation_points: _zod.z.number(),
  keyholder_epochs: _zod.z.array(_zod.z.number()),
  is_current_authority: _zod.z.boolean(),
  is_current_backup: _zod.z.boolean(),
  is_qualified: _zod.z.boolean(),
  is_online: _zod.z.boolean(),
  is_bidding: _zod.z.boolean(),
  apy_bp: _zod.z.number().nullable(),
  operator: accountId.optional()
});
var cfAccountInfo = _zod.z.discriminatedUnion("role", [unregistered, broker, operator, liquidityProvider, validator]).transform((account) => {
  switch (account.role) {
    case "broker":
    case "validator":
    case "unregistered":
    case "liquidity_provider":
      return account;
    case "operator": {
      const { managed_validators, delegators, settings, ...rest } = account;
      return {
        ...rest,
        upcoming_delegation: {
          validators: managed_validators,
          delegators,
          delegation_fee_bps: settings.fee_bps,
          delegation_acceptance: settings.delegation_acceptance
        }
      };
    }
  }
});
var cfAccounts = _zod.z.array(_zod.z.tuple([_zod.z.string(), _zod.z.string()]));
var cfPoolPriceV2 = _zod.z.object({
  sell: numberOrHex.nullable(),
  buy: numberOrHex.nullable(),
  range_order: numberOrHex,
  base_asset: rpcAssetSchema,
  quote_asset: rpcAssetSchema
});
var orderId = numberOrHex.transform((n) => String(n));
var limitOrder = _zod.z.object({
  id: orderId,
  tick: _zod.z.number(),
  sell_amount: numberOrHex,
  fees_earned: numberOrHex,
  original_sell_amount: numberOrHex,
  lp: _zod.z.string()
});
var ask = limitOrder.transform((order) => ({
  ...order,
  type: "ask"
}));
var bid = limitOrder.transform((order) => ({
  ...order,
  type: "bid"
}));
var rangeOrder = _zod.z.object({
  id: orderId,
  range: _zod.z.object({ start: _zod.z.number(), end: _zod.z.number() }),
  liquidity: numberOrHex,
  fees_earned: _zod.z.object({ base: numberOrHex, quote: numberOrHex }),
  lp: _zod.z.string()
}).transform((order) => ({ ...order, type: "range" }));
var cfPoolOrders = _zod.z.object({
  limit_orders: _zod.z.object({
    asks: _zod.z.array(ask),
    bids: _zod.z.array(bid)
  }),
  range_orders: _zod.z.array(rangeOrder)
});
var boostPoolAmount = _zod.z.object({
  account_id: _zod.z.string(),
  amount: u256
});
var cfBoostPoolDetails = _zod.z.array(
  _zod.z.intersection(
    rpcAssetSchema,
    _zod.z.object({
      fee_tier: _zod.z.number(),
      available_amounts: _zod.z.array(boostPoolAmount),
      deposits_pending_finalization: _zod.z.array(
        _zod.z.object({
          deposit_id: numberOrHex,
          owed_amounts: _zod.z.array(boostPoolAmount)
        })
      ),
      pending_withdrawals: _zod.z.array(
        _zod.z.object({
          account_id: _zod.z.string(),
          pending_deposits: _zod.z.array(numberOrHex)
        })
      ),
      network_fee_deduction_percent: _zod.z.number().optional()
    })
  )
);
var cfBoostPoolPendingFees = _zod.z.array(
  _zod.z.intersection(
    rpcAssetSchema,
    _zod.z.object({
      fee_tier: _zod.z.number(),
      pending_fees: _zod.z.array(
        _zod.z.object({
          deposit_id: _zod.z.number().transform(BigInt),
          fees: _zod.z.array(boostPoolAmount)
        })
      )
    })
  )
);
var lpTotalBalances = chainAssetMapFactory(numberOrHex, 0);
var cfFailedCallEvm = _zod.z.object({
  contract: hexString,
  data: _zod.z.string()
});
var range = (parser) => _zod.z.tuple([parser, parser]);
var cfAuctionState = _zod.z.object({
  epoch_duration: _zod.z.number(),
  current_epoch_started_at: _zod.z.number(),
  redemption_period_as_percentage: _zod.z.number(),
  min_funding: numberOrHex,
  auction_size_range: range(_zod.z.number()),
  min_active_bid: numberOrHex.nullable(),
  min_bid: numberOrHex
}).transform(rename({ epoch_duration: "epoch_duration_blocks" }));
var cfMonitoringSimulateAuction = _zod.z.object({
  auction_outcome: _zod.z.object({
    winners: _zod.z.array(accountId),
    bond: numberOrHex
  }),
  operators_info: _zod.z.record(
    accountId,
    _zod.z.object({
      operator: accountId,
      validators: _zod.z.record(accountId, numberOrHex),
      delegators: _zod.z.record(accountId, numberOrHex),
      delegation_fee_bps: _zod.z.number()
    })
  ),
  new_validators: _zod.z.array(accountId),
  current_mab: numberOrHex
});
var cfFlipSuppy = range(numberOrHex).transform(([totalIssuance, offchainFunds]) => ({
  totalIssuance,
  offchainFunds
}));
var ethereumAddress = _zod.z.string().transform((address) => `0x${address}`);
var cfPoolOrderbook = _zod.z.object({
  bids: _zod.z.array(_zod.z.object({ amount: u256, sqrt_price: u256 })),
  asks: _zod.z.array(_zod.z.object({ amount: u256, sqrt_price: u256 }))
});
var cfTradingStrategy = _zod.z.object({
  lp_id: _zod.z.string(),
  strategy_id: _zod.z.string(),
  strategy: _zod.z.union([
    _zod.z.object({
      TickZeroCentered: _zod.z.object({
        spread_tick: _zod.z.number(),
        base_asset: rpcAssetSchema
      })
    }),
    _zod.z.object({
      SimpleBuySell: _zod.z.object({
        buy_tick: _zod.z.number(),
        sell_tick: _zod.z.number(),
        base_asset: rpcAssetSchema
      })
    }),
    _zod.z.object({
      InventoryBased: _zod.z.object({
        min_buy_tick: _zod.z.number(),
        max_buy_tick: _zod.z.number(),
        min_sell_tick: _zod.z.number(),
        max_sell_tick: _zod.z.number(),
        base_asset: rpcAssetSchema
      })
    })
  ]),
  balance: _zod.z.array(_zod.z.tuple([rpcAssetSchema, numberOrHex]))
});
var cfGetTradingStrategies = _zod.z.array(cfTradingStrategy).default([]);
var cfGetTradingStrategyLimits = _zod.z.object({
  minimum_deployment_amount: chainAssetMapFactory(_zod.z.number().nullable(), null),
  minimum_added_funds_amount: chainAssetMapFactory(_zod.z.number().nullable(), null)
});
var cfAvailablePools = _zod.z.array(
  _zod.z.object({
    base: rpcAssetSchema.refine(
      (a) => a.chain !== "Ethereum" || a.asset !== "USDC"
    ),
    quote: _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDC") })
  })
);
var cfOraclePrices = _zod.z.array(
  _zod.z.object({
    price: numberOrHex,
    updated_at_oracle_timestamp: _zod.z.number(),
    updated_at_statechain_block: _zod.z.number(),
    base_asset: _zod.z.enum(_chainflip.priceAssets),
    quote_asset: _zod.z.enum(_chainflip.priceAssets)
  })
);
var broadcastPalletSafeModeStatuses = _zod.z.object({
  retry_enabled: _zod.z.boolean(),
  egress_witnessing_enabled: _zod.z.boolean()
});
var ingressEgressPalletSafeModeStatuses = _zod.z.object({
  boost_deposits_enabled: _zod.z.boolean(),
  deposit_channel_creation_enabled: _zod.z.boolean(),
  deposit_channel_witnessing_enabled: _zod.z.boolean(),
  vault_deposit_witnessing_enabled: _zod.z.boolean()
});
var cfSafeModeStatuses = _zod.z.object({
  emissions: _zod.z.object({
    emissions_sync_enabled: _zod.z.boolean()
  }),
  funding: _zod.z.object({
    redeem_enabled: _zod.z.boolean()
  }),
  swapping: _zod.z.object({
    swaps_enabled: _zod.z.boolean(),
    withdrawals_enabled: _zod.z.boolean(),
    broker_registration_enabled: _zod.z.boolean()
  }),
  liquidity_provider: _zod.z.object({
    deposit_enabled: _zod.z.boolean(),
    withdrawal_enabled: _zod.z.boolean(),
    internal_swaps_enabled: _zod.z.boolean()
  }),
  validator: _zod.z.object({
    authority_rotation_enabled: _zod.z.boolean(),
    start_bidding_enabled: _zod.z.boolean(),
    stop_bidding_enabled: _zod.z.boolean()
  }),
  pools: _zod.z.object({
    range_order_update_enabled: _zod.z.boolean(),
    limit_order_update_enabled: _zod.z.boolean()
  }),
  trading_strategies: _zod.z.object({
    strategy_updates_enabled: _zod.z.boolean(),
    strategy_closure_enabled: _zod.z.boolean(),
    strategy_execution_enabled: _zod.z.boolean()
  }),
  reputation: _zod.z.object({
    reporting_enabled: _zod.z.boolean()
  }),
  asset_balances: _zod.z.object({
    reconciliation_enabled: _zod.z.boolean()
  }),
  threshold_signature_evm: _zod.z.object({
    slashing_enabled: _zod.z.boolean()
  }),
  threshold_signature_bitcoin: _zod.z.object({
    slashing_enabled: _zod.z.boolean()
  }),
  threshold_signature_polkadot: _zod.z.object({
    slashing_enabled: _zod.z.boolean()
  }),
  threshold_signature_solana: _zod.z.object({
    slashing_enabled: _zod.z.boolean()
  }),
  lending_pools: _zod.z.object({
    add_boost_funds_enabled: _zod.z.boolean(),
    stop_boosting_enabled: _zod.z.boolean(),
    // TODO(1.12): remove `optional` after all networks upgraded
    borrowing_enabled: _zod.z.array(rpcAssetSchema).optional(),
    add_lender_funds_enabled: _zod.z.array(rpcAssetSchema).optional(),
    withdraw_lender_funds_enabled: _zod.z.array(rpcAssetSchema).optional(),
    add_collateral_enabled: _zod.z.array(rpcAssetSchema).optional(),
    remove_collateral_enabled: _zod.z.array(rpcAssetSchema).optional()
  }),
  broadcast_ethereum: broadcastPalletSafeModeStatuses,
  broadcast_bitcoin: broadcastPalletSafeModeStatuses,
  broadcast_polkadot: broadcastPalletSafeModeStatuses,
  broadcast_arbitrum: broadcastPalletSafeModeStatuses,
  broadcast_solana: broadcastPalletSafeModeStatuses,
  broadcast_assethub: broadcastPalletSafeModeStatuses,
  ingress_egress_ethereum: ingressEgressPalletSafeModeStatuses,
  ingress_egress_bitcoin: ingressEgressPalletSafeModeStatuses,
  ingress_egress_polkadot: ingressEgressPalletSafeModeStatuses,
  ingress_egress_arbitrum: ingressEgressPalletSafeModeStatuses,
  ingress_egress_solana: ingressEgressPalletSafeModeStatuses,
  ingress_egress_assethub: ingressEgressPalletSafeModeStatuses,
  witnesser: _zod.z.enum(["CodeRed", "CodeGreen", "CodeAmber"]),
  elections_generic: _zod.z.object({
    oracle_price_elections: _zod.z.boolean()
  })
});
var cfLendingPools = _zod.z.array(
  _zod.z.object({
    asset: rpcAssetSchema,
    total_amount: numberOrHex,
    available_amount: numberOrHex,
    utilisation_rate: _zod.z.number(),
    current_interest_rate: _zod.z.number(),
    origination_fee: _zod.z.number(),
    liquidation_fee: _zod.z.number(),
    interest_rate_curve: _zod.z.object({
      interest_at_zero_utilisation: _zod.z.number(),
      junction_utilisation: _zod.z.number(),
      interest_at_junction_utilisation: _zod.z.number(),
      interest_at_max_utilisation: _zod.z.number()
    })
  })
);
var cfLendingConfig = _zod.z.object({
  ltv_thresholds: _zod.z.object({
    target: _zod.z.number(),
    topup: _zod.z.number(),
    soft_liquidation: _zod.z.number(),
    soft_liquidation_abort: _zod.z.number(),
    hard_liquidation: _zod.z.number(),
    hard_liquidation_abort: _zod.z.number(),
    low_ltv: _zod.z.number()
  }),
  network_fee_contributions: _zod.z.object({
    extra_interest: _zod.z.number(),
    interest_on_collateral_max: _zod.z.number(),
    from_origination_fee: _zod.z.number(),
    from_liquidation_fee: _zod.z.number()
  }),
  fee_swap_interval_blocks: _zod.z.number(),
  interest_payment_interval_blocks: _zod.z.number(),
  fee_swap_threshold_usd: numberOrHex,
  interest_collection_threshold_usd: numberOrHex,
  liquidation_swap_chunk_size_usd: numberOrHex,
  soft_liquidation_max_oracle_slippage: _zod.z.number(),
  hard_liquidation_max_oracle_slippage: _zod.z.number(),
  fee_swap_max_oracle_slippage: _zod.z.number()
});
var cfLoanAccount = _zod.z.object({
  account: accountId,
  primary_collateral_asset: rpcAssetSchema,
  ltv_ratio: numberOrHex,
  collateral: _zod.z.array(
    _zod.z.intersection(
      rpcAssetSchema,
      _zod.z.object({
        amount: numberOrHex
      })
    )
  ),
  loans: _zod.z.array(
    _zod.z.object({
      loan_id: _zod.z.number(),
      asset: rpcAssetSchema,
      created_at: _zod.z.number(),
      principal_amount: numberOrHex
    })
  ),
  liquidation_status: _zod.z.object({
    liquidation_swaps: _zod.z.array(
      _zod.z.object({
        swap_request_id: _zod.z.number(),
        loan_id: _zod.z.number()
      })
    ),
    is_hard: _zod.z.boolean()
  }).nullable()
});
var cfLoanAccounts = _zod.z.array(cfLoanAccount);



















































exports.accountInfoCommon = accountInfoCommon; exports.broker = broker; exports.brokerRequestSwapDepositAddress = brokerRequestSwapDepositAddress; exports.cfAccountInfo = cfAccountInfo; exports.cfAccounts = cfAccounts; exports.cfAuctionState = cfAuctionState; exports.cfAvailablePools = cfAvailablePools; exports.cfBoostPoolDetails = cfBoostPoolDetails; exports.cfBoostPoolPendingFees = cfBoostPoolPendingFees; exports.cfBoostPoolsDepth = cfBoostPoolsDepth; exports.cfEnvironment = cfEnvironment; exports.cfFailedCallEvm = cfFailedCallEvm; exports.cfFlipSuppy = cfFlipSuppy; exports.cfFundingEnvironment = cfFundingEnvironment; exports.cfGetTradingStrategies = cfGetTradingStrategies; exports.cfGetTradingStrategyLimits = cfGetTradingStrategyLimits; exports.cfIngressEgressEnvironment = cfIngressEgressEnvironment; exports.cfLendingConfig = cfLendingConfig; exports.cfLendingPools = cfLendingPools; exports.cfLoanAccount = cfLoanAccount; exports.cfLoanAccounts = cfLoanAccounts; exports.cfMonitoringSimulateAuction = cfMonitoringSimulateAuction; exports.cfOraclePrices = cfOraclePrices; exports.cfPoolDepth = cfPoolDepth; exports.cfPoolOrderbook = cfPoolOrderbook; exports.cfPoolOrders = cfPoolOrders; exports.cfPoolPriceV2 = cfPoolPriceV2; exports.cfPoolsEnvironment = cfPoolsEnvironment; exports.cfSafeModeStatuses = cfSafeModeStatuses; exports.cfSupportedAssets = cfSupportedAssets; exports.cfSwapRate = cfSwapRate; exports.cfSwapRateV2 = cfSwapRateV2; exports.cfSwapRateV3 = cfSwapRateV3; exports.cfSwappingEnvironment = cfSwappingEnvironment; exports.cfTradingStrategy = cfTradingStrategy; exports.chainGetBlockHash = chainGetBlockHash; exports.ethereumAddress = ethereumAddress; exports.hexString = hexString; exports.liquidityProvider = liquidityProvider; exports.lpTotalBalances = lpTotalBalances; exports.numberOrHex = numberOrHex; exports.numericString = numericString; exports.operator = operator; exports.requestSwapParameterEncoding = requestSwapParameterEncoding; exports.rpcResponse = rpcResponse; exports.stateGetMetadata = stateGetMetadata; exports.stateGetRuntimeVersion = stateGetRuntimeVersion; exports.u256 = u256; exports.unregistered = unregistered; exports.validator = validator;
