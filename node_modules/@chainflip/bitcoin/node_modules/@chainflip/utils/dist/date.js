import {
  isNullish
} from "./chunk-HBIFE4XN.js";

// src/date.ts
import { utc } from "@date-fns/utc";
import {
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  differenceInSeconds,
  intervalToDuration,
  eachDayOfInterval,
  endOfDay,
  startOfDay,
  subDays,
  addDays
} from "date-fns";
var pluralize = (word, numb) => numb !== 1 ? `${word}s` : word;
var pad = (number) => String(number).padStart(2, "0");
var toISODateString = (date) => date.toISOString().slice(0, 10);
var fromUnixTime = (time) => {
  const date = new Date(Number(time) * 1e3);
  if (Number.isNaN(date.valueOf())) {
    throw new Error("date is invalid");
  }
  return date;
};
var formatTimestamp = (timestamp, locale = void 0, timeZone = void 0) => new Date(timestamp).toLocaleString(locale, {
  timeZone,
  weekday: "short",
  month: "short",
  day: "numeric",
  year: "numeric",
  timeZoneName: "short",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
var formatTimestampShort = (timestamp, locale = void 0, timeZone = void 0) => new Date(timestamp).toLocaleString(locale, {
  timeZone,
  month: "numeric",
  day: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
var differenceInTimeAgo = (time, ago = true, endTime = (/* @__PURE__ */ new Date()).toISOString()) => {
  const end = new Date(endTime);
  const timeNumber = Date.parse(time);
  const seconds = differenceInSeconds(end, timeNumber);
  if (seconds < 60) return `${seconds} sec${ago ? " ago" : ""}`;
  const minutes = differenceInMinutes(end, timeNumber);
  if (minutes < 60) return `${minutes} min${ago ? " ago" : ""}`;
  const hours = differenceInHours(end, timeNumber);
  if (hours < 48) return `${hours} ${pluralize("hour", hours)}${ago ? " ago" : ""}`;
  const days = differenceInDays(end, timeNumber);
  return `${days} days${ago ? " ago" : ""}`;
};
var intervalToDurationWords = (interval) => {
  if (isNullish(interval.start) || isNullish(interval.end)) return "??";
  if (interval.end === 0) return "??";
  const duration = intervalToDuration(interval);
  if (duration.months) return ">1 month";
  if (duration.days) {
    return `${pad(duration.days)}${duration.days === 1 ? "day" : "days"} ${pad(
      duration.hours ?? 0
    )}h ${pad(duration.minutes ?? 0)}min ${pad(duration.seconds ?? 0)}s`;
  }
  if (duration.hours) {
    return `${pad(duration.hours)}h ${pad(duration.minutes ?? 0)}min ${pad(duration.seconds ?? 0)}s`;
  }
  if (duration.minutes) return `${pad(duration.minutes)}min ${pad(duration.seconds ?? 0)}s`;
  if (duration.seconds) return `${pad(duration.seconds)}s`;
  return "A few seconds";
};
var subUtcDays = (date, days) => subDays(date, days, { in: utc });
var addUtcDays = (date, days) => addDays(date, days, { in: utc });
var toStartOfUtcDay = (date) => startOfDay(date, { in: utc });
var toStartOfUtcDayString = (date) => toStartOfUtcDay(date).toISOString();
var toEndOfUtcDay = (date) => endOfDay(date, { in: utc });
var toEndOfUtcDayString = (date) => toEndOfUtcDay(date).toISOString();
var differenceInUtcDays = (interval) => differenceInDays(interval.end, interval.start, { in: utc });
var eachUtcDayOfInterval = (interval) => eachDayOfInterval(interval, { in: utc });
export {
  addUtcDays,
  differenceInTimeAgo,
  differenceInUtcDays,
  eachUtcDayOfInterval,
  formatTimestamp,
  formatTimestampShort,
  fromUnixTime,
  intervalToDurationWords,
  subUtcDays,
  toEndOfUtcDay,
  toEndOfUtcDayString,
  toISODateString,
  toStartOfUtcDay,
  toStartOfUtcDayString
};
