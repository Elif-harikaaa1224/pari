'use strict';

var assertion = require('@chainflip/utils/assertion');
var bytes = require('@chainflip/utils/bytes');
var bitcoin = require('bitcoinjs-lib');
var base58 = require('@chainflip/utils/base58');
var chainflip = require('@chainflip/utils/chainflip');
var consts = require('@chainflip/utils/consts');
var ss58 = require('@chainflip/utils/ss58');
var BigNumber2 = require('bignumber.js');
var url = require('@chainflip/utils/url');
var zod = require('zod');
var scaleTs = require('scale-ts');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var bitcoin__namespace = /*#__PURE__*/_interopNamespace(bitcoin);
var base58__namespace = /*#__PURE__*/_interopNamespace(base58);
var ss58__namespace = /*#__PURE__*/_interopNamespace(ss58);
var BigNumber2__default = /*#__PURE__*/_interopDefault(BigNumber2);

// src/address.ts

// src/consts.ts
var networkMap = {
  mainnet: "mainnet",
  perseverance: "testnet",
  sisyphos: "testnet",
  testnet: "testnet",
  backspin: "regtest",
  regtest: "regtest"
};

// src/address.ts
var p2pkhAddressVersion = {
  mainnet: 0,
  testnet: 111,
  regtest: 111
};
var p2shAddressVersion = {
  mainnet: 5,
  testnet: 196,
  regtest: 196
};
var networkHrp = {
  mainnet: "bc",
  testnet: "tb",
  regtest: "bcrt"
};
var segwitVersions = {
  P2WPKH: 0,
  P2WSH: 0,
  Taproot: 1
};
var byteLikeToUint8Array = (data) => typeof data === "string" ? bytes.hexToBytes(data) : new Uint8Array(data);
var encodeAddress = (data, kind, cfOrBtcnetwork) => {
  const btcNetwork = networkMap[cfOrBtcnetwork];
  assertion.assert(btcNetwork, `Invalid network: ${cfOrBtcnetwork}`);
  assertion.assert(data.length % 2 === 0, "bytes must have an even number of characters");
  assertion.assert(
    typeof data !== "string" || /^(0x)?[0-9a-f]*$/.test(data),
    "bytes are not a valid hex string"
  );
  const bytes = byteLikeToUint8Array(data);
  switch (kind) {
    case "P2PKH":
    case "P2SH": {
      const version = (kind === "P2SH" ? p2shAddressVersion : p2pkhAddressVersion)[btcNetwork];
      return bitcoin__namespace.address.toBase58Check(bytes, version);
    }
    case "P2WPKH":
    case "P2WSH":
    case "Taproot":
      return bitcoin__namespace.address.toBech32(bytes, segwitVersions[kind], networkHrp[btcNetwork]);
    default:
      throw new Error(`Invalid address type: ${kind}`);
  }
};
var decodeAddress = (address2, cfOrBtcNetwork) => {
  const network = networkMap[cfOrBtcNetwork];
  if (/^[13mn2]/.test(address2)) {
    const { hash, version } = bitcoin__namespace.address.fromBase58Check(address2);
    if (version === p2pkhAddressVersion[network]) {
      return { type: "P2PKH", data: hash, version };
    }
    if (version === p2shAddressVersion[network]) {
      return { type: "P2SH", data: hash, version };
    }
    throw new TypeError(`Invalid version: ${version}`);
  }
  if (/^(bc|tb|bcrt)1/.test(address2)) {
    const { data, prefix, version } = bitcoin__namespace.address.fromBech32(address2);
    assertion.assert(prefix === networkHrp[network], `Invalid prefix: ${prefix}`);
    let type;
    if (version === 0 && data.length === 20) {
      type = "P2WPKH";
    } else if (version === 0) {
      type = "P2WSH";
    } else if (version === 1) {
      type = "Taproot";
    } else {
      throw new TypeError(`Invalid version: ${version}`);
    }
    return { hrp: prefix, data, type, version };
  }
  throw new TypeError(`Invalid address "${address2}" for network "${network}"`);
};
var isValidAddressForNetwork = (address2, cfOrBtcNetwork) => {
  try {
    decodeAddress(address2, cfOrBtcNetwork);
    return true;
  } catch {
    return false;
  }
};
var hexString = zod.z.string().regex(/^([0-9a-f]{2})+$/, { message: "expected hex string" });
var vout = zod.z.object({
  value: zod.z.number().transform((n) => BigInt(new BigNumber2__default.default(n).shiftedBy(8).toFixed(0))),
  n: zod.z.number()
});
var nulldataVout = zod.z.object({
  scriptPubKey: zod.z.object({
    type: zod.z.literal("nulldata"),
    // remove OP_RETURN and PUSH_BYTES_XX
    hex: hexString.transform((x) => bytes.hexToBytes(`0x${x.slice(4)}`))
  })
}).and(vout);
var addressVout = zod.z.object({
  scriptPubKey: zod.z.object({
    type: zod.z.enum([
      "witness_v1_taproot",
      "witness_v0_scripthash",
      "witness_v0_keyhash",
      "pubkeyhash",
      "scripthash"
    ]),
    address: zod.z.string()
  })
}).and(vout);
var txSchema = zod.z.object({
  vout: zod.z.tuple([addressVout, nulldataVout, addressVout]),
  blockhash: hexString.nullish()
});
var blockSchema = zod.z.object({
  height: zod.z.number()
});
var responseSchemas = {
  getrawtransaction: txSchema,
  getblock: blockSchema
};
var rpcResponse = zod.z.union([
  zod.z.object({ result: zod.z.null(), error: zod.z.object({ code: zod.z.number(), message: zod.z.string() }) }),
  zod.z.object({ result: zod.z.unknown(), error: zod.z.null() })
]);
var makeRequest = async (rpcUrl, method, params) => {
  const { url: url$1, headers } = url.parseUrlWithBasicAuth(rpcUrl);
  const res = await fetch(url$1, {
    method: "POST",
    headers: {
      ...headers,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method,
      params
    })
  });
  const text = await res.text();
  let json;
  try {
    json = JSON.parse(text);
  } catch {
    if (res.status !== 200) {
      throw new Error(`HTTP error [${res.status}]: ${text || res.statusText}`);
    }
    throw new Error(`Invalid JSON response: ${text}`);
  }
  const result = rpcResponse.parse(json);
  if (result.error) {
    if (result.error.code === -5) return null;
    throw new Error(`RPC error [${result.error.code}]: ${result.error.message}`);
  }
  const parseResult = responseSchemas[method].safeParse(result.result);
  if (!parseResult.success) {
    if (method === "getrawtransaction") return null;
    throw parseResult.error;
  }
  return parseResult.data;
};
var addressByteLengths = {
  Bitcoin: void 0,
  Arbitrum: 20,
  Ethereum: 20,
  Solana: 32,
  Polkadot: 32,
  Assethub: 32
};
var createSwapDataCodecV0 = (asset) => scaleTs.Struct({
  version: scaleTs.u8,
  destinationAsset: scaleTs.u8,
  destinationAddress: scaleTs.Bytes(addressByteLengths[chainflip.assetConstants[asset].chain]),
  parameters: scaleTs.Struct({
    retryDuration: scaleTs.u16,
    minOutputAmount: scaleTs.u128,
    numberOfChunks: scaleTs.u16,
    chunkInterval: scaleTs.u16,
    boostFee: scaleTs.u8,
    brokerFee: scaleTs.u8,
    affiliates: scaleTs.Vector(scaleTs.Struct({ accountIndex: scaleTs.u8, commissionBps: scaleTs.u8 }))
  })
});
var createSwapDataCodecV1 = (asset) => scaleTs.Struct({
  version: scaleTs.u8,
  destinationAsset: scaleTs.u8,
  destinationAddress: scaleTs.Bytes(addressByteLengths[chainflip.assetConstants[asset].chain]),
  parameters: scaleTs.Struct({
    retryDuration: scaleTs.u16,
    minOutputAmount: scaleTs.u128,
    maxOraclePriceSlippage: scaleTs.u8,
    numberOfChunks: scaleTs.u16,
    chunkInterval: scaleTs.u16,
    boostFee: scaleTs.u8,
    brokerFee: scaleTs.u8,
    affiliates: scaleTs.Vector(scaleTs.Struct({ accountIndex: scaleTs.u8, commissionBps: scaleTs.u8 }))
  })
});

// src/deposit.ts
var encodeChainAddress = (data, asset) => {
  switch (chainflip.assetConstants[asset].chain) {
    case "Solana":
      return base58__namespace.encode(data);
    case "Assethub":
    case "Polkadot":
      return ss58__namespace.encode({ data, ss58Format: consts.POLKADOT_SS58_PREFIX });
    case "Ethereum":
    case "Arbitrum":
      return bytes.bytesToHex(data);
    case "Bitcoin":
      return new TextDecoder().decode(data);
  }
};
var contractIdToInternalAsset = Object.fromEntries(
  Object.entries(chainflip.assetContractId).map(([asset, id]) => [id, asset])
);
var parseVaultSwapData = (data) => {
  const version = data[0];
  const contractId = data[1];
  const outputAsset = contractIdToInternalAsset[contractId];
  let destinationAddress;
  let parameters;
  if (version === 1) {
    ({ destinationAddress, parameters } = createSwapDataCodecV1(outputAsset).dec(data));
  } else if (version === 0) {
    ({ destinationAddress, parameters } = createSwapDataCodecV0(outputAsset).dec(data));
  } else {
    throw new Error("unsupported version");
  }
  assertion.assert(outputAsset, "unknown asset contract id");
  return {
    ...parameters,
    outputAsset,
    destinationAddress: encodeChainAddress(destinationAddress, outputAsset)
  };
};
var getX128PriceFromAmounts = (depositAmount, minOutputAmount) => BigInt(
  new BigNumber2__default.default(minOutputAmount.toString()).div(depositAmount.toString()).multipliedBy(new BigNumber2__default.default(2).pow(128)).toFixed(0, BigNumber2__default.default.ROUND_FLOOR)
);
var findVaultSwapData = async (url, txId) => {
  const tx = await makeRequest(url, "getrawtransaction", [txId, true]);
  if (!tx) return null;
  const data = parseVaultSwapData(tx.vout[1].scriptPubKey.hex);
  const amount = tx.vout[0].value;
  const block = tx.blockhash ? await makeRequest(url, "getblock", [tx.blockhash, true]).catch(() => null) : null;
  return {
    inputAsset: "Btc",
    amount,
    depositAddress: tx.vout[0].scriptPubKey.address,
    refundParams: {
      refundAddress: tx.vout[2].scriptPubKey.address,
      retryDuration: data.retryDuration,
      minPrice: getX128PriceFromAmounts(amount, data.minOutputAmount),
      maxOraclePriceSlippage: "maxOraclePriceSlippage" in data ? data.maxOraclePriceSlippage : null
    },
    destinationAddress: data.destinationAddress,
    outputAsset: data.outputAsset,
    brokerFee: { account: null, commissionBps: data.brokerFee },
    affiliateFees: data.affiliates,
    ccmDepositMetadata: null,
    maxBoostFee: data.boostFee,
    dcaParams: data.numberOfChunks === 1 && data.chunkInterval === 2 ? null : { chunkInterval: data.chunkInterval, numberOfChunks: data.numberOfChunks },
    depositChainBlockHeight: block && block.height
  };
};

exports.decodeAddress = decodeAddress;
exports.encodeAddress = encodeAddress;
exports.findVaultSwapData = findVaultSwapData;
exports.isValidAddressForNetwork = isValidAddressForNetwork;
