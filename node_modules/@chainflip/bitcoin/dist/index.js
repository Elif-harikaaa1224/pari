import { assert } from '@chainflip/utils/assertion';
import { hexToBytes, bytesToHex } from '@chainflip/utils/bytes';
import * as bitcoin from 'bitcoinjs-lib';
import * as base58 from '@chainflip/utils/base58';
import { assetContractId, assetConstants } from '@chainflip/utils/chainflip';
import { POLKADOT_SS58_PREFIX } from '@chainflip/utils/consts';
import * as ss58 from '@chainflip/utils/ss58';
import BigNumber2 from 'bignumber.js';
import { parseUrlWithBasicAuth } from '@chainflip/utils/url';
import { z } from 'zod';
import { Struct, Bytes, u8, Vector, u16, u128 } from 'scale-ts';

// src/address.ts

// src/consts.ts
var networkMap = {
  mainnet: "mainnet",
  perseverance: "testnet",
  sisyphos: "testnet",
  testnet: "testnet",
  backspin: "regtest",
  regtest: "regtest"
};

// src/address.ts
var p2pkhAddressVersion = {
  mainnet: 0,
  testnet: 111,
  regtest: 111
};
var p2shAddressVersion = {
  mainnet: 5,
  testnet: 196,
  regtest: 196
};
var networkHrp = {
  mainnet: "bc",
  testnet: "tb",
  regtest: "bcrt"
};
var segwitVersions = {
  P2WPKH: 0,
  P2WSH: 0,
  Taproot: 1
};
var byteLikeToUint8Array = (data) => typeof data === "string" ? hexToBytes(data) : new Uint8Array(data);
var encodeAddress = (data, kind, cfOrBtcnetwork) => {
  const btcNetwork = networkMap[cfOrBtcnetwork];
  assert(btcNetwork, `Invalid network: ${cfOrBtcnetwork}`);
  assert(data.length % 2 === 0, "bytes must have an even number of characters");
  assert(
    typeof data !== "string" || /^(0x)?[0-9a-f]*$/.test(data),
    "bytes are not a valid hex string"
  );
  const bytes = byteLikeToUint8Array(data);
  switch (kind) {
    case "P2PKH":
    case "P2SH": {
      const version = (kind === "P2SH" ? p2shAddressVersion : p2pkhAddressVersion)[btcNetwork];
      return bitcoin.address.toBase58Check(bytes, version);
    }
    case "P2WPKH":
    case "P2WSH":
    case "Taproot":
      return bitcoin.address.toBech32(bytes, segwitVersions[kind], networkHrp[btcNetwork]);
    default:
      throw new Error(`Invalid address type: ${kind}`);
  }
};
var decodeAddress = (address2, cfOrBtcNetwork) => {
  const network = networkMap[cfOrBtcNetwork];
  if (/^[13mn2]/.test(address2)) {
    const { hash, version } = bitcoin.address.fromBase58Check(address2);
    if (version === p2pkhAddressVersion[network]) {
      return { type: "P2PKH", data: hash, version };
    }
    if (version === p2shAddressVersion[network]) {
      return { type: "P2SH", data: hash, version };
    }
    throw new TypeError(`Invalid version: ${version}`);
  }
  if (/^(bc|tb|bcrt)1/.test(address2)) {
    const { data, prefix, version } = bitcoin.address.fromBech32(address2);
    assert(prefix === networkHrp[network], `Invalid prefix: ${prefix}`);
    let type;
    if (version === 0 && data.length === 20) {
      type = "P2WPKH";
    } else if (version === 0) {
      type = "P2WSH";
    } else if (version === 1) {
      type = "Taproot";
    } else {
      throw new TypeError(`Invalid version: ${version}`);
    }
    return { hrp: prefix, data, type, version };
  }
  throw new TypeError(`Invalid address "${address2}" for network "${network}"`);
};
var isValidAddressForNetwork = (address2, cfOrBtcNetwork) => {
  try {
    decodeAddress(address2, cfOrBtcNetwork);
    return true;
  } catch {
    return false;
  }
};
var hexString = z.string().regex(/^([0-9a-f]{2})+$/, { message: "expected hex string" });
var vout = z.object({
  value: z.number().transform((n) => BigInt(new BigNumber2(n).shiftedBy(8).toFixed(0))),
  n: z.number()
});
var nulldataVout = z.object({
  scriptPubKey: z.object({
    type: z.literal("nulldata"),
    // remove OP_RETURN and PUSH_BYTES_XX
    hex: hexString.transform((x) => hexToBytes(`0x${x.slice(4)}`))
  })
}).and(vout);
var addressVout = z.object({
  scriptPubKey: z.object({
    type: z.enum([
      "witness_v1_taproot",
      "witness_v0_scripthash",
      "witness_v0_keyhash",
      "pubkeyhash",
      "scripthash"
    ]),
    address: z.string()
  })
}).and(vout);
var txSchema = z.object({
  vout: z.tuple([addressVout, nulldataVout, addressVout]),
  blockhash: hexString.nullish()
});
var blockSchema = z.object({
  height: z.number()
});
var responseSchemas = {
  getrawtransaction: txSchema,
  getblock: blockSchema
};
var rpcResponse = z.union([
  z.object({ result: z.null(), error: z.object({ code: z.number(), message: z.string() }) }),
  z.object({ result: z.unknown(), error: z.null() })
]);
var makeRequest = async (rpcUrl, method, params) => {
  const { url, headers } = parseUrlWithBasicAuth(rpcUrl);
  const res = await fetch(url, {
    method: "POST",
    headers: {
      ...headers,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method,
      params
    })
  });
  const text = await res.text();
  let json;
  try {
    json = JSON.parse(text);
  } catch {
    if (res.status !== 200) {
      throw new Error(`HTTP error [${res.status}]: ${text || res.statusText}`);
    }
    throw new Error(`Invalid JSON response: ${text}`);
  }
  const result = rpcResponse.parse(json);
  if (result.error) {
    if (result.error.code === -5) return null;
    throw new Error(`RPC error [${result.error.code}]: ${result.error.message}`);
  }
  const parseResult = responseSchemas[method].safeParse(result.result);
  if (!parseResult.success) {
    if (method === "getrawtransaction") return null;
    throw parseResult.error;
  }
  return parseResult.data;
};
var addressByteLengths = {
  Bitcoin: void 0,
  Arbitrum: 20,
  Ethereum: 20,
  Solana: 32,
  Polkadot: 32,
  Assethub: 32
};
var createSwapDataCodecV0 = (asset) => Struct({
  version: u8,
  destinationAsset: u8,
  destinationAddress: Bytes(addressByteLengths[assetConstants[asset].chain]),
  parameters: Struct({
    retryDuration: u16,
    minOutputAmount: u128,
    numberOfChunks: u16,
    chunkInterval: u16,
    boostFee: u8,
    brokerFee: u8,
    affiliates: Vector(Struct({ accountIndex: u8, commissionBps: u8 }))
  })
});
var createSwapDataCodecV1 = (asset) => Struct({
  version: u8,
  destinationAsset: u8,
  destinationAddress: Bytes(addressByteLengths[assetConstants[asset].chain]),
  parameters: Struct({
    retryDuration: u16,
    minOutputAmount: u128,
    maxOraclePriceSlippage: u8,
    numberOfChunks: u16,
    chunkInterval: u16,
    boostFee: u8,
    brokerFee: u8,
    affiliates: Vector(Struct({ accountIndex: u8, commissionBps: u8 }))
  })
});

// src/deposit.ts
var encodeChainAddress = (data, asset) => {
  switch (assetConstants[asset].chain) {
    case "Solana":
      return base58.encode(data);
    case "Assethub":
    case "Polkadot":
      return ss58.encode({ data, ss58Format: POLKADOT_SS58_PREFIX });
    case "Ethereum":
    case "Arbitrum":
      return bytesToHex(data);
    case "Bitcoin":
      return new TextDecoder().decode(data);
  }
};
var contractIdToInternalAsset = Object.fromEntries(
  Object.entries(assetContractId).map(([asset, id]) => [id, asset])
);
var parseVaultSwapData = (data) => {
  const version = data[0];
  const contractId = data[1];
  const outputAsset = contractIdToInternalAsset[contractId];
  let destinationAddress;
  let parameters;
  if (version === 1) {
    ({ destinationAddress, parameters } = createSwapDataCodecV1(outputAsset).dec(data));
  } else if (version === 0) {
    ({ destinationAddress, parameters } = createSwapDataCodecV0(outputAsset).dec(data));
  } else {
    throw new Error("unsupported version");
  }
  assert(outputAsset, "unknown asset contract id");
  return {
    ...parameters,
    outputAsset,
    destinationAddress: encodeChainAddress(destinationAddress, outputAsset)
  };
};
var getX128PriceFromAmounts = (depositAmount, minOutputAmount) => BigInt(
  new BigNumber2(minOutputAmount.toString()).div(depositAmount.toString()).multipliedBy(new BigNumber2(2).pow(128)).toFixed(0, BigNumber2.ROUND_FLOOR)
);
var findVaultSwapData = async (url, txId) => {
  const tx = await makeRequest(url, "getrawtransaction", [txId, true]);
  if (!tx) return null;
  const data = parseVaultSwapData(tx.vout[1].scriptPubKey.hex);
  const amount = tx.vout[0].value;
  const block = tx.blockhash ? await makeRequest(url, "getblock", [tx.blockhash, true]).catch(() => null) : null;
  return {
    inputAsset: "Btc",
    amount,
    depositAddress: tx.vout[0].scriptPubKey.address,
    refundParams: {
      refundAddress: tx.vout[2].scriptPubKey.address,
      retryDuration: data.retryDuration,
      minPrice: getX128PriceFromAmounts(amount, data.minOutputAmount),
      maxOraclePriceSlippage: "maxOraclePriceSlippage" in data ? data.maxOraclePriceSlippage : null
    },
    destinationAddress: data.destinationAddress,
    outputAsset: data.outputAsset,
    brokerFee: { account: null, commissionBps: data.brokerFee },
    affiliateFees: data.affiliates,
    ccmDepositMetadata: null,
    maxBoostFee: data.boostFee,
    dcaParams: data.numberOfChunks === 1 && data.chunkInterval === 2 ? null : { chunkInterval: data.chunkInterval, numberOfChunks: data.numberOfChunks },
    depositChainBlockHeight: block && block.height
  };
};

export { decodeAddress, encodeAddress, findVaultSwapData, isValidAddressForNetwork };
