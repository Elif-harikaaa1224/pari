import { assert, getEnvironment, envSafeAssetBlacklist, getEvmChainId, getAllBoostPoolsDepth, parseFoKParams, isNotNullish, isTestnet, ADDRESSES } from './chunk-7L3ZOIWM.js';
import { unreachable } from '@chainflip/utils/assertion';
import { chainflipChains, assetSymbols, isValidAssetAndChain, getInternalAssets, chainflipNetworks, chainflipAssets, assetConstants, getInternalAsset, internalAssetToRpcAsset, readAssetValue } from '@chainflip/utils/chainflip';
export { getInternalAsset as getChainflipId } from '@chainflip/utils/chainflip';
import { initContract, initClient } from '@ts-rest/core';
import z6, { z } from 'zod';
import { HttpClient } from '@chainflip/rpc';
import { bytesToHex } from '@chainflip/utils/bytes';
import * as ss58 from '@chainflip/utils/ss58';
import { isHex, toUpperCase } from '@chainflip/utils/string';
import { priceX128ToPrice } from '@chainflip/utils/tickMath';
import BigNumber$1, { BigNumber } from 'bignumber.js';
import { isValidSolanaAddress } from '@chainflip/solana';
import { hexEncodeNumber } from '@chainflip/utils/number';
import * as bitcoin from '@chainflip/bitcoin';
import * as ethers from 'ethers';
import axios from 'axios';

// ../shared/src/strings.ts
var toCamelCase = (str) => str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());

// ../shared/src/objects.ts
var transformKeysToCamelCase = (obj) => {
  if (Array.isArray(obj)) {
    return obj.map(transformKeysToCamelCase);
  }
  if (obj !== null && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [
        toCamelCase(key),
        transformKeysToCamelCase(value)
      ])
    );
  }
  return obj;
};
var booleanString = z.string().regex(/^(true|false)$/i).transform((v) => v.toLowerCase() === "true");
var numericString = z.string().regex(/^[0-9]+$/);
var numericOrEmptyString = z.string().regex(/^[0-9]*$/);
var hexString = z.string().refine((v) => /^0x[0-9a-f]*$/i.test(v));
var hexStringWithMaxByteSize = (maxByteSize) => hexString.refine((val) => val.length / 2 <= maxByteSize + 1, {
  message: `String must be less than or equal to ${maxByteSize} bytes`
});
var basisPoints = z.number().int({ message: "must be in basis points" });
var DOT_PREFIX = 0;
var chainflipAddress = z.string().refine(
  (address) => address.startsWith("cF") && ss58.decode(address),
  (address) => ({ message: `${address} is not a valid Chainflip address` })
);
z.string().refine(isValidSolanaAddress, (address) => ({
  message: `${address} is not a valid Solana address`
}));
var u128 = z.union([z.number(), numericString, hexString]).transform((arg) => BigInt(arg));
var unsignedInteger = z.union([u128, z.number().transform((n) => BigInt(n))]);
var chain = z.enum(chainflipChains);
var asset = z.enum(assetSymbols);
var uncheckedAssetAndChain = z.object({
  asset: z.string(),
  chain: z.string()
});
var assetAndChain = uncheckedAssetAndChain.refine(
  (value) => isValidAssetAndChain(value)
);
z.object({
  srcChain: chain,
  srcAsset: asset,
  destChain: chain,
  destAsset: asset,
  amount: numericString.transform((v) => BigInt(v)).refine((v) => v > 0n, { message: "swap input amount must be greater than 0" }).refine((v) => v < 2n ** 128n, { message: "swap input amount must be less than 2^128" }),
  brokerCommissionBps: numericOrEmptyString.transform((v) => Number(v)).optional(),
  ccmGasBudget: z.union([
    numericString.transform((v) => BigInt(v)),
    z.literal("undefined").transform(() => void 0)
    // sdk version 1.8.2 sends undefined string if not set
  ]).optional(),
  ccmMessageLengthBytes: z.union([
    numericString.transform((v) => Number(v)),
    z.literal("undefined").transform(() => void 0)
    // sdk version 1.8.2 sends undefined string if not set
  ]).optional(),
  dcaEnabled: booleanString.default("false"),
  isVaultSwap: booleanString.optional(),
  isOnChain: booleanString.optional()
}).transform((args, ctx) => {
  const { srcAsset, destAsset } = getInternalAssets(args, false);
  let hadError = false;
  if (srcAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({ asset: args.srcAsset, chain: args.srcChain })}`,
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (destAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({ asset: args.destAsset, chain: args.destChain })}`,
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (srcAsset === "Dot" || destAsset === "Dot") {
    ctx.addIssue({
      message: "Dot is not supported",
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.ccmGasBudget !== void 0 && args.ccmMessageLengthBytes === void 0) {
    ctx.addIssue({
      message: `ccmMessageLengthBytes must be set if ccmGasBudget is set`,
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.ccmGasBudget === void 0 && args.ccmMessageLengthBytes !== void 0) {
    ctx.addIssue({
      message: `ccmGasBudget must be set if ccmMessageLengthBytes is set`,
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.isOnChain && args.isVaultSwap) {
    ctx.addIssue({
      message: "isOnChain and isVaultSwap cannot be set at the same time",
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.isOnChain && args.brokerCommissionBps !== void 0 && args.brokerCommissionBps > 0) {
    ctx.addIssue({
      message: "isOnChain cannot be set with a non-zero broker commission",
      code: z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (hadError) return z.NEVER;
  const ccmParams = args.ccmGasBudget !== void 0 && args.ccmMessageLengthBytes !== void 0 ? { gasBudget: args.ccmGasBudget, messageLengthBytes: args.ccmMessageLengthBytes } : void 0;
  return {
    srcAsset,
    destAsset,
    amount: args.amount,
    brokerCommissionBps: args.brokerCommissionBps,
    ccmParams,
    dcaEnabled: args.dcaEnabled,
    isVaultSwap: args.isVaultSwap,
    isOnChain: args.isOnChain
  };
});
var ccmParamsSchema = z.object({
  gasBudget: z.union([numericString, hexString]).transform((n) => hexEncodeNumber(BigInt(n))),
  // https://github.com/chainflip-io/chainflip-backend/blob/415aa9e20ec4046c68892cd34798e5d831c5b83f/state-chain/chains/src/lib.rs#L709
  message: hexStringWithMaxByteSize(15e3),
  // https://github.com/chainflip-io/chainflip-backend/blob/415aa9e20ec4046c68892cd34798e5d831c5b83f/state-chain/chains/src/lib.rs#L710
  ccmAdditionalData: hexStringWithMaxByteSize(3e3).optional(),
  /** @deprecated DEPRECATED(1.10) pass additionalData instead */
  cfParameters: hexStringWithMaxByteSize(3e3).optional()
}).transform(({ gasBudget, message, ccmAdditionalData, cfParameters }) => ({
  gasBudget,
  message,
  ccmAdditionalData: ccmAdditionalData ?? cfParameters ?? "0x"
}));
var affiliateBroker = z.object({
  account: chainflipAddress,
  commissionBps: z.number()
}).transform(({ account, commissionBps: bps }) => ({ account, bps }));
var dcaParams = z.object({
  numberOfChunks: z.number(),
  chunkIntervalBlocks: z.number()
});
var fillOrKillParams = z.object({
  retryDurationBlocks: z.number(),
  refundAddress: z.string(),
  minPriceX128: numericString,
  maxOraclePriceSlippage: basisPoints.nullish().transform((v) => v ?? null),
  refundCcmMetadata: ccmParamsSchema.nullish().optional().default(null).transform(
    (v) => v && {
      ...v,
      cfParameters: v.ccmAdditionalData
      // deprecated
    }
  )
});
var validatePolkadotAddress = (address) => {
  if (isHex(address)) return address.length === 66;
  try {
    ss58.decode(address);
    return true;
  } catch {
    return false;
  }
};
var validateEvmAddress = (address) => ethers.isAddress(address);
var validateBitcoinMainnetAddress = (address) => bitcoin.isValidAddressForNetwork(address, "mainnet");
var validateBitcoinTestnetAddress = (address) => bitcoin.isValidAddressForNetwork(address, "testnet");
var validateBitcoinRegtestAddress = (address) => bitcoin.isValidAddressForNetwork(address, "regtest");
var validateSolanaAddress = isValidSolanaAddress;
var validators = {
  mainnet: {
    Bitcoin: validateBitcoinMainnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  perseverance: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  sisyphos: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  backspin: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  localnet: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  }
};
var validateAddress = (chain2, address, network) => validators[network][chain2](address);

// ../shared/src/broker.ts
var transformedDcaParamsSchema = dcaParams.transform(
  ({ numberOfChunks, chunkIntervalBlocks }) => ({
    number_of_chunks: numberOfChunks,
    chunk_interval: chunkIntervalBlocks
  })
);
var transformedCcmParamsSchema = ccmParamsSchema.transform(
  ({ message, gasBudget, ccmAdditionalData }) => ({
    message,
    gas_budget: gasBudget,
    ccm_additional_data: ccmAdditionalData,
    /** @deprecated DEPRECATED(1.10) we still need to pass cf_parameters until 1.8 is deployed to all networks */
    cf_parameters: ccmAdditionalData
  })
);
var transformedFokSchema = z.object({
  retryDurationBlocks: z.number(),
  refundAddress: z.string(),
  minPriceX128: numericString,
  maxOraclePriceSlippage: basisPoints.nullish().transform((v) => v ?? null),
  refundCcmMetadata: transformedCcmParamsSchema.nullable().optional().default(null)
}).transform(
  ({
    retryDurationBlocks,
    refundAddress,
    minPriceX128,
    maxOraclePriceSlippage,
    refundCcmMetadata
  }) => ({
    retry_duration: retryDurationBlocks,
    refund_address: refundAddress,
    min_price: `0x${BigInt(minPriceX128).toString(16)}`,
    max_oracle_price_slippage: maxOraclePriceSlippage,
    refund_ccm_metadata: refundCcmMetadata
  })
);
var getDepositAddressRequestSchema = (network) => z.object({
  srcAsset: assetAndChain,
  destAsset: assetAndChain,
  destAddress: z.string(),
  commissionBps: z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z.number().optional(),
  affiliates: z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional()
}).superRefine((val, ctx) => {
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
});
var getVaultSwapParameterEncodingRequestSchema = (network) => z.object({
  srcAsset: assetAndChain,
  srcAddress: z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z.string(),
  amount: unsignedInteger,
  commissionBps: z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z.number().optional(),
  affiliates: z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional(),
  extraParams: z.object({ seed: hexString.optional() }).optional(),
  brokerAccount: chainflipAddress.optional()
}).superRefine((val, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (val.extraParams?.seed && val.extraParams.seed.length !== 66) {
    ctx.addIssue({ message: "Seed must be 32 bytes", code: z.ZodIssueCode.custom });
  }
}).transform((data) => {
  let extraParams;
  if (data.srcAsset.chain === "Bitcoin") {
    const minOutputAmount = BigNumber$1(data.amount.toString()).multipliedBy(priceX128ToPrice(data.fillOrKillParams.min_price)).toFixed(0);
    extraParams = {
      chain: "Bitcoin",
      min_output_amount: `0x${BigInt(minOutputAmount).toString(16)}`,
      retry_duration: data.fillOrKillParams.retry_duration,
      max_oracle_price_slippage: data.fillOrKillParams.max_oracle_price_slippage
    };
  } else if (data.srcAsset.chain === "Ethereum" || data.srcAsset.chain === "Arbitrum") {
    extraParams = {
      chain: data.srcAsset.chain,
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else if (data.srcAsset.chain === "Solana") {
    assert(data.srcAddress, "srcAddress is required for Solana");
    extraParams = {
      chain: "Solana",
      from: data.srcAddress,
      seed: data.extraParams?.seed ?? bytesToHex(crypto.getRandomValues(new Uint8Array(32))),
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else {
    throw new Error(`parameter encoding is not supported for ${data.srcAsset.chain}`);
  }
  return { ...data, extraParams };
});
async function requestSwapDepositAddress(request, opts, chainflipNetwork) {
  const client = new HttpClient(opts.url);
  if (request.srcChain && typeof request.srcAsset === "string") {
    request = { ...request, srcAsset: { asset: request.srcAsset, chain: request.srcChain } };
  }
  if (request.destChain && typeof request.destAsset === "string") {
    request = { ...request, destAsset: { asset: request.destAsset, chain: request.destChain } };
  }
  const params = getDepositAddressRequestSchema(chainflipNetwork).parse(request);
  const response = await client.sendRequest(
    "broker_request_swap_deposit_address",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.fillOrKillParams,
    params.dcaParams
  );
  switch (params.srcAsset.chain) {
    case "Assethub":
      if (isHex(response.address)) {
        response.address = ss58.encode({ data: response.address, ss58Format: DOT_PREFIX });
      }
      break;
    case "Ethereum":
    case "Arbitrum":
    case "Bitcoin":
    case "Solana":
      break;
    default:
      return unreachable(params.srcAsset, "unexpected chain");
  }
  return transformKeysToCamelCase(response);
}
async function requestSwapParameterEncoding(request, opts, chainflipNetwork) {
  const client = new HttpClient(opts.url);
  const params = getVaultSwapParameterEncodingRequestSchema(chainflipNetwork).parse(request);
  const response = await client.sendRequest(
    "broker_request_swap_parameter_encoding",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.extraParams,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.dcaParams
  );
  return transformKeysToCamelCase(response);
}
var cfParameterEncodingRequestSchema = z.object({
  srcAsset: assetAndChain,
  srcAddress: z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z.string(),
  amount: unsignedInteger,
  commissionBps: z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z.number().optional(),
  affiliates: z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional(),
  network: z.enum(chainflipNetworks)
}).superRefine(({ network, ...val }, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
}).transform(({ network, ...rest }) => rest);
async function requestCfParametersEncoding(request, opts) {
  const client = new HttpClient(opts.url);
  const params = cfParameterEncodingRequestSchema.parse(request);
  const response = await client.sendRequest(
    "broker_encode_cf_parameters",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.fillOrKillParams,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.dcaParams
  );
  return response;
}

// ../shared/src/api/encodeCfParameters.ts
var CfParameterEncodingRequestWithBroker = cfParameterEncodingRequestSchema.and(
  z.object({
    brokerAccount: chainflipAddress.optional()
  })
);
var TransformedCcmParams = ccmParamsSchema.transform(
  ({ message, gasBudget, ccmAdditionalData }) => ({
    message,
    gas_budget: gasBudget,
    ccm_additional_data: ccmAdditionalData,
    /** @deprecated DEPRECATED(1.10) we still need to pass cf_parameters until 1.8 is deployed to all networks */
    cf_parameters: ccmAdditionalData
  })
);
var FillOrKillParams = fillOrKillParams.transform(
  ({
    retryDurationBlocks,
    refundAddress,
    minPriceX128,
    maxOraclePriceSlippage,
    refundCcmMetadata
  }) => ({
    retry_duration: retryDurationBlocks,
    refund_address: refundAddress,
    min_price: `0x${BigInt(minPriceX128).toString(16)}`,
    max_oracle_price_slippage: maxOraclePriceSlippage,
    refund_ccm_metadata: refundCcmMetadata && {
      gas_budget: refundCcmMetadata.gasBudget,
      message: refundCcmMetadata.message,
      ccm_additional_data: refundCcmMetadata.ccmAdditionalData,
      /** @deprecated DEPRECATED(1.10) */
      cf_parameters: refundCcmMetadata.cfParameters
    }
  })
);
var TransformedDcaParams = dcaParams.transform(
  ({ numberOfChunks, chunkIntervalBlocks }) => ({
    number_of_chunks: numberOfChunks,
    chunk_interval: chunkIntervalBlocks
  })
);
var EncodeVaultSwapBody = z.object({
  srcAsset: assetAndChain,
  srcAddress: z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z.string(),
  amount: unsignedInteger,
  commissionBps: z.number().optional().default(0),
  ccmParams: TransformedCcmParams.optional(),
  maxBoostFeeBps: z.number().optional(),
  affiliates: z.array(affiliateBroker).optional(),
  fillOrKillParams: FillOrKillParams,
  dcaParams: TransformedDcaParams.optional(),
  extraParams: z.object({ seed: hexString.optional() }).optional(),
  network: z.enum(chainflipNetworks),
  brokerAccount: chainflipAddress.optional()
}).superRefine(({ network, ...val }, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z.ZodIssueCode.custom
    });
  }
  if (val.extraParams?.seed && val.extraParams.seed.length !== 66) {
    ctx.addIssue({ message: "Seed must be 32 bytes", code: z.ZodIssueCode.custom });
  }
}).transform(({ network, ...data }) => {
  let extraParams;
  if (data.srcAsset.chain === "Bitcoin") {
    const minOutputAmount = BigNumber(data.amount.toString()).multipliedBy(priceX128ToPrice(data.fillOrKillParams.min_price)).toFixed(0);
    extraParams = {
      chain: "Bitcoin",
      min_output_amount: `0x${BigInt(minOutputAmount).toString(16)}`,
      retry_duration: data.fillOrKillParams.retry_duration,
      max_oracle_price_slippage: data.fillOrKillParams.max_oracle_price_slippage
    };
  } else if (data.srcAsset.chain === "Ethereum" || data.srcAsset.chain === "Arbitrum") {
    extraParams = {
      chain: data.srcAsset.chain,
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else if (data.srcAsset.chain === "Solana") {
    assert(data.srcAddress, "srcAddress is required for Solana");
    extraParams = {
      chain: "Solana",
      from: data.srcAddress,
      seed: data.extraParams?.seed ?? bytesToHex(crypto.getRandomValues(new Uint8Array(32))),
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else {
    throw new Error(`parameter encoding is not supported for ${data.srcAsset.chain}`);
  }
  return { ...data, extraParams };
});
var EncodedVaultSwapData = z.discriminatedUnion("chain", [
  z.object({
    chain: z.literal("Bitcoin"),
    nulldataPayload: hexString,
    depositAddress: z.string()
  }),
  z.object({
    chain: z.enum(["Ethereum", "Arbitrum"]),
    value: z.string(),
    to: hexString,
    calldata: hexString,
    sourceTokenAddress: hexString.optional()
  }),
  z.object({
    chain: z.literal("Solana"),
    programId: z.string(),
    data: hexString,
    accounts: z.array(
      z.object({
        pubkey: z.string(),
        isSigner: z.boolean(),
        isWritable: z.boolean()
      })
    )
  })
]);
var NetworkInfo = z6.object({
  assets: z6.array(
    z6.object({
      asset: z6.enum(chainflipAssets),
      vaultSwapDepositsEnabled: z6.boolean(),
      depositChannelDepositsEnabled: z6.boolean(),
      depositChannelCreationEnabled: z6.boolean(),
      egressEnabled: z6.boolean(),
      boostDepositsEnabled: z6.boolean()
    })
  ),
  cfBrokerCommissionBps: z6.number()
});
var ChainflipAsset = z.enum(chainflipAssets);
var NetworkStatus = z.object({
  assets: z.object({
    deposit: z.array(ChainflipAsset),
    destination: z.array(ChainflipAsset),
    all: z.array(ChainflipAsset)
  }),
  boostDepositsEnabled: z.boolean(),
  cfBrokerCommissionBps: z.number()
});
var OpenSwapDepositChannelBody = z.object({
  srcAsset: asset,
  destAsset: asset,
  srcChain: chain,
  destChain: chain,
  destAddress: z.string(),
  amount: numericString,
  ccmParams: ccmParamsSchema.optional(),
  maxBoostFeeBps: z.number().optional(),
  srcAddress: z.string().optional(),
  fillOrKillParams,
  dcaParams: dcaParams.optional(),
  quote: z.object({
    intermediateAmount: z.string().optional(),
    egressAmount: z.string(),
    estimatedPrice: z.string(),
    recommendedSlippageTolerancePercent: z.number().optional(),
    recommendedLivePriceSlippageTolerancePercent: z.number().optional()
  }).optional(),
  takeCommission: z.boolean().optional()
}).transform(({ amount, ...rest }) => ({
  ...rest,
  expectedDepositAmount: amount
}));
var DepositChannelInfo = z.object({
  id: z.string(),
  depositAddress: z.string(),
  brokerCommissionBps: z.number(),
  maxBoostFeeBps: z.number(),
  issuedBlock: z.number(),
  srcChainExpiryBlock: z.string(),
  estimatedExpiryTime: z.number().optional(),
  channelOpeningFee: z.string()
});

// ../shared/src/api/contract.ts
var c = initContract();
var apiContract = c.router(
  {
    /** @deprecated DEPRECATED(1.10): using `networkInfo` now */
    networkStatus: {
      method: "GET",
      path: "/networkStatus",
      responses: {
        200: NetworkStatus
      },
      summary: "Get information about the Chainflip network"
    },
    networkInfo: {
      method: "GET",
      path: "/networkInfo",
      responses: {
        200: NetworkInfo
      },
      summary: "Get information about the Chainflip network"
    },
    encodeCfParameters: {
      method: "POST",
      path: "/encodeCfParameters",
      body: CfParameterEncodingRequestWithBroker,
      responses: {
        200: hexString
      }
    },
    encodeVaultSwapData: {
      method: "POST",
      path: "/encodeVaultSwapData",
      body: EncodeVaultSwapBody,
      responses: {
        200: EncodedVaultSwapData
      }
    },
    openSwapDepositChannel: {
      method: "POST",
      path: "/openSwapDepositChannel",
      body: OpenSwapDepositChannelBody,
      responses: {
        201: DepositChannelInfo
      }
    }
  },
  {
    pathPrefix: "/api"
  }
);

// ../shared/src/dataStructures.ts
var MultiCache = class {
  constructor(fetchers) {
    this.fetchers = fetchers;
  }
  values = {};
  read(type) {
    const { fetch, ttl } = this.fetchers[type];
    let cached = this.values[type];
    if (!cached || cached.timestamp + ttl < Date.now()) {
      cached = {
        timestamp: Date.now(),
        value: fetch().catch((err) => {
          this.values[type] = void 0;
          throw err;
        })
      };
      this.values[type] = cached;
    }
    return cached.value;
  }
};
var MAX_SWAP_AMOUNT = 2n ** 128n - 1n;
var validateSwapAmount = (env, asset2, amount) => {
  const minimumAmount = readAssetValue(env.ingressEgress.minimumDepositAmounts, asset2);
  if (amount < minimumAmount) {
    return {
      success: false,
      reason: `expected amount is below minimum swap amount (${minimumAmount})`
    };
  }
  const maxAmount = readAssetValue(env.swapping.maximumSwapAmounts, asset2) ?? MAX_SWAP_AMOUNT;
  if (maxAmount != null && amount > maxAmount) {
    return {
      success: false,
      reason: `expected amount is above maximum swap amount (${maxAmount})`
    };
  }
  return { success: true };
};
var getTokenContractAddress = (asset2, network) => {
  switch (asset2) {
    case "Btc":
    case "Dot":
    case "Eth":
    case "ArbEth":
    case "Sol":
    case "HubDot":
    case "HubUsdc":
    case "HubUsdt":
      return void 0;
    default:
      return ADDRESSES[network][`${toUpperCase(asset2)}_CONTRACT_ADDRESS`];
  }
};
var assetNames = {
  Eth: "Ether",
  Flip: "FLIP",
  Usdc: "USDC",
  Usdt: "USDT",
  Dot: "Polkadot",
  Btc: "Bitcoin",
  ArbEth: "Arbitrum Ether",
  ArbUsdc: "Arbitrum USDC",
  Sol: "Solana",
  SolUsdc: "Solana USDC",
  HubDot: "Assethub DOT",
  HubUsdc: "Assethub USDC",
  HubUsdt: "Assethub USDT"
};
var getAssetData = (asset2, network, env) => {
  const assetConstant = assetConstants[asset2];
  return {
    chainflipId: asset2,
    asset: assetConstant.symbol,
    chain: assetConstant.chain,
    contractAddress: getTokenContractAddress(asset2, network),
    decimals: assetConstant.decimals,
    name: assetNames[asset2],
    symbol: assetConstant.symbol,
    isMainnet: !isTestnet(network),
    minimumSwapAmount: readAssetValue(env.ingressEgress.minimumDepositAmounts, asset2).toString(),
    maximumSwapAmount: readAssetValue(env.swapping.maximumSwapAmounts, asset2)?.toString() ?? null,
    minimumEgressAmount: readAssetValue(env.ingressEgress.minimumEgressAmounts, asset2).toString()
  };
};

// src/swap/chains.ts
var getChainData = (chain2, network, env) => ({
  chain: chain2,
  name: chain2,
  evmChainId: getEvmChainId(chain2, network),
  isMainnet: !isTestnet(network),
  requiredBlockConfirmations: isNotNullish(
    env.ingressEgress.witnessSafetyMargins[chain2]
  ) ? Number(env.ingressEgress.witnessSafetyMargins[chain2]) + 1 : void 0,
  maxRetryDurationBlocks: env.swapping.maxSwapRetryDurationBlocks
});

// package.json
var package_default = {
  version: "1.11.1"};

// src/swap/consts.ts
var CF_SDK_VERSION_HEADERS = { "X-Chainflip-Sdk-Version": package_default.version };
var BACKEND_SERVICE_URLS = {
  backspin: "https://chainflip-swap-backspin.staging/",
  sisyphos: "https://chainflip-swap.staging/",
  perseverance: "https://chainflip-swap-perseverance.chainflip.io/",
  mainnet: "https://chainflip-swap.chainflip.io/"
};
var getQuoteV2 = async (baseUrl, quoteRequest, { signal }) => {
  const affiliateCommissionBps = quoteRequest.affiliateBrokers?.reduce((acc, affiliate) => acc + affiliate.commissionBps, 0) ?? 0;
  const totalBrokerCommissionBps = (quoteRequest.brokerCommissionBps ?? 0) + affiliateCommissionBps;
  const params = {
    amount: quoteRequest.amount,
    srcChain: quoteRequest.srcChain,
    srcAsset: quoteRequest.srcAsset,
    destChain: quoteRequest.destChain,
    destAsset: quoteRequest.destAsset,
    isVaultSwap: String(Boolean(quoteRequest.isVaultSwap)),
    isOnChain: String(Boolean(quoteRequest.isOnChain)),
    ...totalBrokerCommissionBps && {
      brokerCommissionBps: String(totalBrokerCommissionBps)
    },
    ...quoteRequest.ccmParams && {
      ccmGasBudget: quoteRequest.ccmParams.gasBudget,
      ccmMessageLengthBytes: String(quoteRequest.ccmParams.messageLengthBytes)
    },
    dcaEnabled: String(Boolean(quoteRequest.dcaEnabled))
  };
  const { data } = await axios.get("/v2/quote", {
    baseURL: baseUrl,
    params,
    signal,
    headers: CF_SDK_VERSION_HEADERS
  });
  return { ...quoteRequest, quotes: data };
};
var getStatusV2 = async (baseUrl, { id }, { signal }) => {
  const { data } = await axios.get(`/v2/swaps/${id}`, {
    baseURL: baseUrl,
    signal,
    headers: CF_SDK_VERSION_HEADERS
  });
  return data;
};

// src/swap/sdk.ts
var assertQuoteValid = (quote) => {
  switch (quote.type) {
    case "REGULAR":
      break;
    case "DCA":
      if (quote.dcaParams == null) throw new Error("Failed to find DCA parameters from quote");
      break;
    default:
      throw new Error("Invalid quote type");
  }
};
var SwapSDK = class {
  options;
  rpcConfig;
  apiClient;
  cache;
  dcaEnabled = false;
  blackListedAssets;
  constructor(options = {}) {
    const network = options.network ?? "perseverance";
    this.options = {
      ...options,
      network,
      backendUrl: options.backendUrl ?? BACKEND_SERVICE_URLS[network]
    };
    this.rpcConfig = options.rpcUrl ? { rpcUrl: options.rpcUrl } : { network };
    this.apiClient = initClient(apiContract, {
      // remove trailing slashes. this bug has been fixed in `@ts-rest/core`
      // but it hasn't been released yet
      baseUrl: this.options.backendUrl.replace(/\/+$/, ""),
      baseHeaders: CF_SDK_VERSION_HEADERS
    });
    this.dcaEnabled = options.enabledFeatures?.dca ?? false;
    this.cache = new MultiCache({
      environment: {
        fetch: () => getEnvironment(this.rpcConfig),
        ttl: 6e4
      },
      networkInfo: {
        fetch: async () => {
          const res = await this.apiClient.networkInfo();
          assert(res.status === 200, "Failed to fetch network info");
          return res.body;
        },
        ttl: 6e4
      }
    });
    this.blackListedAssets = envSafeAssetBlacklist(this.options.network);
  }
  async getChains(sourceChain, type = "all") {
    if (sourceChain && !chainflipChains.includes(sourceChain)) {
      throw new Error(`unsupported source chain "${sourceChain}"`);
    }
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets(type)
    ]);
    const supportedChains = new Set(supportedAssets.map((a) => assetConstants[a].chain));
    if (sourceChain && !supportedChains.has(sourceChain)) return [];
    return [...supportedChains].filter((chain2) => chain2 !== "Polkadot").map((chain2) => getChainData(chain2, this.options.network, env)).filter((chain2) => chain2.chain !== sourceChain);
  }
  async getStateChainEnvironment() {
    return this.cache.read("environment");
  }
  async getSupportedAssets(type) {
    const assets = await this.cache.read("networkInfo");
    return assets.assets.filter((a) => !this.blackListedAssets.includes(a.asset)).filter((a) => {
      switch (type) {
        case "all":
          return true;
        case "deposit":
          return a.depositChannelCreationEnabled && a.depositChannelDepositsEnabled && a.vaultSwapDepositsEnabled;
        case "destination":
          return a.egressEnabled;
        case "depositChannel":
          return a.depositChannelCreationEnabled && a.depositChannelDepositsEnabled;
        case "vaultSwap":
          return a.vaultSwapDepositsEnabled;
        default:
          return unreachable(type, "unexpected type");
      }
    }).map((a) => a.asset);
  }
  async getBoostPoolsDepth() {
    return getAllBoostPoolsDepth(this.rpcConfig);
  }
  async getAssets(chain2, type = "all") {
    if (chain2 && !chainflipChains.includes(chain2)) throw new Error(`unsupported chain "${chain2}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets(type)
    ]);
    return supportedAssets.filter((asset2) => asset2 !== "Dot").map((asset2) => getAssetData(asset2, this.options.network, env)).filter((asset2) => !chain2 || asset2.chain === chain2);
  }
  // eslint-disable-next-line class-methods-use-this
  shouldTakeCommission() {
    return false;
  }
  async getCommissionBps(brokerCommissionBps) {
    if (this.shouldTakeCommission()) {
      return (await this.cache.read("networkInfo")).cfBrokerCommissionBps;
    }
    return brokerCommissionBps ?? this.options.broker?.commissionBps ?? 0;
  }
  async getQuoteV2(quoteRequest, options = {}) {
    const submitterBrokerCommissionBps = await this.getCommissionBps(
      quoteRequest.brokerCommissionBps
    );
    return getQuoteV2(
      this.options.backendUrl,
      {
        ...quoteRequest,
        brokerCommissionBps: submitterBrokerCommissionBps,
        dcaEnabled: this.dcaEnabled
      },
      options
    );
  }
  getStatusV2(swapStatusRequest, options = {}) {
    return getStatusV2(this.options.backendUrl, swapStatusRequest, options);
  }
  async validateSwapAmount(asset2, amount) {
    const stateChainEnv = await this.getStateChainEnvironment();
    const internalAsset = getInternalAsset(asset2);
    const result = validateSwapAmount(stateChainEnv, internalAsset, amount);
    if (!result.success) throw new Error(result.reason);
  }
  async getSwapLimits() {
    const {
      swapping: { maximumSwapAmounts },
      ingressEgress: { minimumDepositAmounts }
    } = await this.getStateChainEnvironment();
    return { minimumSwapAmounts: minimumDepositAmounts, maximumSwapAmounts };
  }
  async getRequiredBlockConfirmations() {
    const {
      ingressEgress: { witnessSafetyMargins }
    } = await this.getStateChainEnvironment();
    return chainflipChains.filter((chain2) => chain2 !== "Polkadot").reduce(
      (acc, chain2) => {
        acc[chain2] = witnessSafetyMargins[chain2] ? Number(witnessSafetyMargins[chain2]) + 1 : null;
        return acc;
      },
      {}
    );
  }
  async getChannelOpeningFees() {
    const {
      ingressEgress: { channelOpeningFees }
    } = await this.getStateChainEnvironment();
    return channelOpeningFees;
  }
  async getBoostLiquidity(params = {}) {
    let poolsDepth = await this.getBoostPoolsDepth();
    if ("chain" in params && "asset" in params) {
      const { chain: chain2, asset: asset2 } = params;
      const internalAsset = getInternalAsset({ chain: chain2, asset: asset2 });
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.asset === internalAsset).sort((a, b) => b.tier - a.tier);
    }
    if ("feeTierBps" in params && params.feeTierBps !== void 0) {
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.tier === params.feeTierBps);
    }
    return poolsDepth.map((depth) => ({
      availableAmount: depth.availableAmount,
      feeTierBps: depth.tier,
      ...internalAssetToRpcAsset[depth.asset]
    }));
  }
  async requestDepositAddressV2({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: inputFoKParams,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerCommissionBps: brokerCommissionBpsParam
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    assert(!quote.isVaultSwap, "Cannot open a deposit channel for a vault swap quote");
    assert(!quote.isOnChain, "Cannot open a deposit channel for an on-chain quote");
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot open CCM channel for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot open regular channel for quote with CCM params");
    }
    const brokerCommissionBps = await this.getCommissionBps(brokerCommissionBpsParam);
    const depositAddressRequest = {
      srcAsset: quote.srcAsset.asset,
      srcChain: quote.srcAsset.chain,
      destAsset: quote.destAsset.asset,
      destChain: quote.destAsset.chain,
      srcAddress,
      destAddress,
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      fillOrKillParams: parseFoKParams(inputFoKParams, quote),
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      ccmParams,
      amount: quote.depositAmount
    };
    let response;
    if (this.options.broker) {
      const result = await requestSwapDepositAddress(
        {
          ...depositAddressRequest,
          commissionBps: brokerCommissionBps,
          affiliates
        },
        { url: this.options.broker.url },
        this.options.network
      );
      response = {
        id: `${result.issuedBlock}-${quote.srcAsset.chain}-${result.channelId}`,
        depositAddress: result.address,
        brokerCommissionBps,
        srcChainExpiryBlock: result.sourceChainExpiryBlock,
        maxBoostFeeBps: depositAddressRequest.maxBoostFeeBps,
        channelOpeningFee: result.channelOpeningFee
      };
    } else {
      assert(
        !brokerCommissionBps || this.shouldTakeCommission(),
        "Broker commission is supported only when initializing the SDK with a brokerUrl"
      );
      assert(
        !affiliates?.length,
        "Affiliate brokers are supported only when initializing the SDK with a brokerUrl"
      );
      const res = await this.apiClient.openSwapDepositChannel({
        body: {
          ...depositAddressRequest,
          quote,
          takeCommission: this.shouldTakeCommission()
        }
      });
      assert(res.status === 201, "Failed to open swap deposit channel");
      response = res.body;
    }
    return {
      ...depositAddressRequest,
      depositChannelId: response.id,
      depositAddress: response.depositAddress,
      brokerCommissionBps: response.brokerCommissionBps,
      affiliateBrokers: affiliates ?? [],
      maxBoostFeeBps: Number(response.maxBoostFeeBps) || 0,
      depositChannelExpiryBlock: BigInt(response.srcChainExpiryBlock),
      estimatedDepositChannelExpiryTime: response.estimatedExpiryTime,
      channelOpeningFee: BigInt(response.channelOpeningFee),
      fillOrKillParams: inputFoKParams
    };
  }
  async encodeVaultSwapData({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: inputFoKParams,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerAccount,
    brokerCommissionBps: brokerCommissionBpsParam,
    extraParams
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    assert(quote.isVaultSwap, "Cannot encode vault swap data for non-vault swap quotes");
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot encode CCM swap for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot encode regular swap for quote with CCM params");
    }
    const brokerCommissionBps = await this.getCommissionBps(brokerCommissionBpsParam);
    const vaultSwapRequest = {
      srcAsset: quote.srcAsset,
      destAsset: quote.destAsset,
      srcAddress,
      destAddress,
      amount: quote.depositAmount,
      ccmParams,
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      fillOrKillParams: parseFoKParams(inputFoKParams, quote),
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      extraParams,
      brokerAccount,
      commissionBps: brokerCommissionBps,
      affiliates
    };
    if (this.options.broker) {
      assert(
        !vaultSwapRequest.brokerAccount,
        "Cannot overwrite broker account when initializing the SDK with a brokerUrl"
      );
      return requestSwapParameterEncoding(
        vaultSwapRequest,
        { url: this.options.broker.url },
        this.options.network
      );
    }
    assert(
      !vaultSwapRequest.commissionBps || vaultSwapRequest.brokerAccount || this.shouldTakeCommission(),
      "Broker commission is supported only when setting a broker account"
    );
    assert(
      !vaultSwapRequest.affiliates?.length || vaultSwapRequest.brokerAccount,
      "Affiliate brokers are supported only when setting a broker account"
    );
    const res = await this.apiClient.encodeVaultSwapData({
      body: { ...vaultSwapRequest, network: this.options.network }
    });
    if (res.status !== 200) {
      throw new Error("Failed to encode vault swap data", { cause: res });
    }
    switch (res.body.chain) {
      case "Arbitrum":
      case "Ethereum":
        return { ...res.body, value: BigInt(res.body.value) };
      default:
        return res.body;
    }
  }
  async encodeCfParameters({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: fillOrKillParams2,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerAccount,
    brokerCommissionBps
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot encode CCM swap for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot encode regular swap for quote with CCM params");
    }
    const requestParams = {
      srcAsset: quote.srcAsset,
      destAsset: quote.destAsset,
      srcAddress,
      destAddress,
      amount: quote.depositAmount,
      ccmParams,
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      fillOrKillParams: parseFoKParams(fillOrKillParams2, quote),
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      commissionBps: await this.getCommissionBps(brokerCommissionBps),
      affiliates,
      network: this.options.network
    };
    if (this.options.broker) {
      assert(
        !brokerAccount,
        "Cannot overwrite broker account when initializing the SDK with a brokerUrl"
      );
      return requestCfParametersEncoding(requestParams, { url: this.options.broker.url });
    }
    assert(
      !requestParams.commissionBps || brokerAccount || this.shouldTakeCommission(),
      "Broker commission is supported only when setting a broker account"
    );
    assert(
      !requestParams.affiliates?.length || brokerAccount,
      "Affiliate brokers are supported only when setting a broker account"
    );
    const res = await this.apiClient.encodeCfParameters({
      body: { ...requestParams, brokerAccount }
    });
    if (res.status !== 200) {
      throw new Error("Failed to encode cf parameters", { cause: res });
    }
    return res.body;
  }
  /** @deprecated DEPRECATED(1.11) removing this method as it appears to not be used */
  // eslint-disable-next-line class-methods-use-this
  getOnChainSwapExtrinsicArgs({
    quote,
    fillOrKillParams: fillOrKillParams2
  }) {
    assert(quote.isOnChain, "Cannot get extrinsic args for non-on-chain quotes");
    const { retryDurationBlocks, minPriceX128 } = parseFoKParams(fillOrKillParams2, quote);
    return [
      quote.depositAmount,
      getInternalAsset(quote.srcAsset),
      getInternalAsset(quote.destAsset),
      retryDurationBlocks,
      minPriceX128,
      quote.type === "DCA" ? {
        number_of_chunks: quote.dcaParams.numberOfChunks,
        chunk_interval: quote.dcaParams.chunkIntervalBlocks
      } : null
    ];
  }
  async checkBoostEnabled() {
    const { assets } = await this.cache.read("networkInfo");
    return assets.find((a) => a.asset === "Btc")?.boostDepositsEnabled ?? true;
  }
};
var arrayToMap = (array) => Object.fromEntries(array.map((item) => [item, item]));
var ChainflipNetworks = arrayToMap(chainflipNetworks);
var InternalAssets = arrayToMap(chainflipAssets.filter((asset2) => asset2 !== "Dot"));
var Chains = arrayToMap(chainflipChains.filter((chain2) => chain2 !== "Polkadot"));
var Assets = arrayToMap(assetSymbols);

export { Assets, InternalAssets as ChainflipIds, ChainflipNetworks, Chains, SwapSDK };
