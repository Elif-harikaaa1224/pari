import { getInternalAsset, assetConstants } from '@chainflip/utils/chainflip';
import { CHAINFLIP_BLOCK_TIME_SECONDS } from '@chainflip/utils/consts';
import BigNumber from 'bignumber.js';
import { HttpClient, constants } from '@chainflip/rpc';

// ../shared/src/guards.ts
var isNotNullish = (value) => value !== null && value !== void 0;
function assert(condition, message, Constructor = Error) {
  if (condition) return;
  const error = new Constructor(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}
var getPriceX128FromPrice = (price, srcAsset, destAsset) => BigNumber(price).multipliedBy(new BigNumber(2).pow(128)).shiftedBy(assetConstants[destAsset].decimals - assetConstants[srcAsset].decimals).toFixed(0);
var blocksPerMinute = 60 / CHAINFLIP_BLOCK_TIME_SECONDS;
function parseFoKParams(params, quote) {
  const srcAsset = getInternalAsset(quote.srcAsset);
  const destAsset = getInternalAsset(quote.destAsset);
  const livePriceProtectionDisabled = params.livePriceSlippageTolerancePercent === false;
  const livePriceProtectionEnabled = typeof params.livePriceSlippageTolerancePercent === "string" || typeof params.livePriceSlippageTolerancePercent === "number";
  const livePriceProtectionAvailable = isNotNullish(
    quote.recommendedLivePriceSlippageTolerancePercent
  );
  if (livePriceProtectionEnabled && !livePriceProtectionAvailable) {
    throw new Error("Live price protection is not available for this asset pair");
  }
  let minPrice;
  let livePriceSlippageTolerancePercent = null;
  if (!livePriceProtectionDisabled) {
    if (isNotNullish(params.livePriceSlippageTolerancePercent) && params.livePriceSlippageTolerancePercent !== false) {
      livePriceSlippageTolerancePercent = new BigNumber(params.livePriceSlippageTolerancePercent);
      assert(!livePriceSlippageTolerancePercent.isNaN(), "Invalid live price slippage tolerance");
      assert(
        livePriceSlippageTolerancePercent.gte(0) && livePriceSlippageTolerancePercent.lte(100),
        "Live price slippage tolerance must be between 0 and 100 inclusive"
      );
    } else if (quote.recommendedLivePriceSlippageTolerancePercent) {
      livePriceSlippageTolerancePercent = new BigNumber(
        quote.recommendedLivePriceSlippageTolerancePercent
      );
      assert(!livePriceSlippageTolerancePercent.isNaN(), "Invalid live price slippage tolerance");
    }
  }
  if ("minPrice" in params) {
    assert(
      !("slippageTolerancePercent" in params),
      "Cannot have both minPrice and slippageTolerancePercent"
    );
    minPrice = params.minPrice;
  } else if ("slippageTolerancePercent" in params) {
    const tolerance = new BigNumber(params.slippageTolerancePercent);
    assert(!tolerance.isNaN(), "Invalid slippage tolerance");
    assert(
      tolerance.gte(0) && tolerance.lte(100),
      "Slippage tolerance must be between 0 and 100 inclusive",
      RangeError
    );
    const estimatedPrice = new BigNumber(quote.estimatedPrice);
    assert(!estimatedPrice.isNaN(), "Invalid estimated price");
    minPrice = estimatedPrice.times(new BigNumber(100).minus(tolerance).dividedBy(100)).toFixed(assetConstants[destAsset].decimals);
  } else {
    throw new Error("Either minPrice or slippageTolerancePercent must be provided");
  }
  const retryDurationBlocks = "retryDurationBlocks" in params ? params.retryDurationBlocks : Math.max(Math.ceil(params.retryDurationMinutes * blocksPerMinute), 0);
  const maxOraclePriceSlippage = livePriceSlippageTolerancePercent?.multipliedBy(100).toNumber() ?? null;
  const parsed = {
    retryDurationBlocks,
    minPriceX128: getPriceX128FromPrice(minPrice, srcAsset, destAsset),
    maxOraclePriceSlippage,
    refundCcmMetadata: params.refundCcmMetadata ?? null
  };
  return "refundAddress" in params ? { ...parsed, refundAddress: params.refundAddress } : parsed;
}
var isTestnet = (network) => network !== "mainnet";

// ../shared/src/consts.ts
var ETHEREUM_EVM_CHAIN_ID = {
  backspin: 10997,
  // backspin ethereum
  sisyphos: 11155111,
  // sepolia
  perseverance: 11155111,
  // sepolia
  mainnet: 1
  // mainnet
};
var ARBITRUM_EVM_CHAIN_ID = {
  backspin: 412346,
  // backspin arbitrum
  sisyphos: 421614,
  // arb-sepolia
  perseverance: 421614,
  // arb-sepolia
  mainnet: 42161
  // mainnet
};
var getEvmChainId = (chain, network) => {
  switch (chain) {
    case "Ethereum":
      return ETHEREUM_EVM_CHAIN_ID[network];
    case "Arbitrum":
      return ARBITRUM_EVM_CHAIN_ID[network];
    default:
      return void 0;
  }
};
var SEPOLIA_USDC_CONTRACT_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
var SEPOLIA_USDT_CONTRACT_ADDRESS = "0x27CEA6Eb8a21Aae05Eb29C91c5CA10592892F584";
var ADDRESSES = {
  backspin: {
    FLIP_CONTRACT_ADDRESS: "0x10C6E9530F1C1AF873a391030a1D9E8ed0630D26",
    USDC_CONTRACT_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    USDT_CONTRACT_ADDRESS: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    ARBUSDC_CONTRACT_ADDRESS: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xeEBe00Ac0756308ac4AaBfD76c05c4F3088B8883",
    SOLUSDC_CONTRACT_ADDRESS: "24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p"
  },
  sisyphos: {
    FLIP_CONTRACT_ADDRESS: "0xcD079EAB6B5443b545788Fd210C8800FEADd87fa",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x1F7fE41C798cc7b1D34BdC8de2dDDA4a4bE744D9",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  perseverance: {
    FLIP_CONTRACT_ADDRESS: "0xdC27c60956cB065D19F08bb69a707E37b36d8086",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xA34a967197Ee90BB7fb28e928388a573c5CFd099",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  mainnet: {
    FLIP_CONTRACT_ADDRESS: "0x826180541412D574cf1336d22c0C0a287822678A",
    USDC_CONTRACT_ADDRESS: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    USDT_CONTRACT_ADDRESS: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    ARBUSDC_CONTRACT_ADDRESS: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x6995Ab7c4D7F4B03f467Cf4c8E920427d9621DBd",
    SOLUSDC_CONTRACT_ADDRESS: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  }
};
var ASSET_BLACKLIST = ["Dot"];
var envSafeAssetBlacklist = (network) => isTestnet(network) ? ASSET_BLACKLIST : ASSET_BLACKLIST;
var camelCase = (str) => str.replace(/_([a-z])/g, (_, char) => char.toUpperCase());
var camelCaseKeys = (obj) => {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map((item) => camelCaseKeys(item));
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [camelCase(key), camelCaseKeys(value)])
  );
};
var createRequest = (method) => async (urlOrNetwork, ...params) => {
  const url = "network" in urlOrNetwork ? constants.PUBLIC_RPC_ENDPOINTS[urlOrNetwork.network] : urlOrNetwork.rpcUrl;
  const result = await new HttpClient(url).sendRequest(method, ...params);
  return camelCaseKeys(result);
};
var transform = (fn, cb) => (...args) => fn(...args).then(cb);
var getFundingEnvironment = createRequest("cf_funding_environment");
var getEnvironment = createRequest("cf_environment");
var getAllBoostPoolsDepth = transform(
  createRequest("cf_boost_pools_depth"),
  (result) => result.filter(({ chain }) => chain !== "Polkadot").map(({ chain, asset, ...rest }) => ({
    asset: getInternalAsset({ chain, asset }),
    ...rest
  }))
);

export { ADDRESSES, assert, envSafeAssetBlacklist, getAllBoostPoolsDepth, getEnvironment, getEvmChainId, getFundingEnvironment, isNotNullish, isTestnet, parseFoKParams };
