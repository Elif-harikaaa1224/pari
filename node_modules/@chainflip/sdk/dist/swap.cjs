'use strict';

var assertion = require('@chainflip/utils/assertion');
var chainflip = require('@chainflip/utils/chainflip');
var core = require('@ts-rest/core');
var z6 = require('zod');
var rpc = require('@chainflip/rpc');
var bytes = require('@chainflip/utils/bytes');
var ss58 = require('@chainflip/utils/ss58');
var string = require('@chainflip/utils/string');
var tickMath = require('@chainflip/utils/tickMath');
var BigNumber3 = require('bignumber.js');
var solana = require('@chainflip/solana');
var number = require('@chainflip/utils/number');
var bitcoin = require('@chainflip/bitcoin');
var ethers = require('ethers');
var consts = require('@chainflip/utils/consts');
var axios = require('axios');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var z6__default = /*#__PURE__*/_interopDefault(z6);
var ss58__namespace = /*#__PURE__*/_interopNamespace(ss58);
var BigNumber3__default = /*#__PURE__*/_interopDefault(BigNumber3);
var bitcoin__namespace = /*#__PURE__*/_interopNamespace(bitcoin);
var ethers__namespace = /*#__PURE__*/_interopNamespace(ethers);
var axios__default = /*#__PURE__*/_interopDefault(axios);

// src/swap/sdk.ts

// ../shared/src/guards.ts
var isNotNullish = (value) => value !== null && value !== void 0;
function assert(condition, message, Constructor = Error) {
  if (condition) return;
  const error = new Constructor(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}

// ../shared/src/strings.ts
var toCamelCase = (str) => str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());

// ../shared/src/objects.ts
var transformKeysToCamelCase = (obj) => {
  if (Array.isArray(obj)) {
    return obj.map(transformKeysToCamelCase);
  }
  if (obj !== null && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [
        toCamelCase(key),
        transformKeysToCamelCase(value)
      ])
    );
  }
  return obj;
};
var booleanString = z6.z.string().regex(/^(true|false)$/i).transform((v) => v.toLowerCase() === "true");
var numericString = z6.z.string().regex(/^[0-9]+$/);
var numericOrEmptyString = z6.z.string().regex(/^[0-9]*$/);
var hexString = z6.z.string().refine((v) => /^0x[0-9a-f]*$/i.test(v));
var hexStringWithMaxByteSize = (maxByteSize) => hexString.refine((val) => val.length / 2 <= maxByteSize + 1, {
  message: `String must be less than or equal to ${maxByteSize} bytes`
});
var basisPoints = z6.z.number().int({ message: "must be in basis points" });
var DOT_PREFIX = 0;
var chainflipAddress = z6.z.string().refine(
  (address) => address.startsWith("cF") && ss58__namespace.decode(address),
  (address) => ({ message: `${address} is not a valid Chainflip address` })
);
z6.z.string().refine(solana.isValidSolanaAddress, (address) => ({
  message: `${address} is not a valid Solana address`
}));
var u128 = z6.z.union([z6.z.number(), numericString, hexString]).transform((arg) => BigInt(arg));
var unsignedInteger = z6.z.union([u128, z6.z.number().transform((n) => BigInt(n))]);
var chain = z6.z.enum(chainflip.chainflipChains);
var asset = z6.z.enum(chainflip.assetSymbols);
var uncheckedAssetAndChain = z6.z.object({
  asset: z6.z.string(),
  chain: z6.z.string()
});
var assetAndChain = uncheckedAssetAndChain.refine(
  (value) => chainflip.isValidAssetAndChain(value)
);
z6.z.object({
  srcChain: chain,
  srcAsset: asset,
  destChain: chain,
  destAsset: asset,
  amount: numericString.transform((v) => BigInt(v)).refine((v) => v > 0n, { message: "swap input amount must be greater than 0" }).refine((v) => v < 2n ** 128n, { message: "swap input amount must be less than 2^128" }),
  brokerCommissionBps: numericOrEmptyString.transform((v) => Number(v)).optional(),
  ccmGasBudget: z6.z.union([
    numericString.transform((v) => BigInt(v)),
    z6.z.literal("undefined").transform(() => void 0)
    // sdk version 1.8.2 sends undefined string if not set
  ]).optional(),
  ccmMessageLengthBytes: z6.z.union([
    numericString.transform((v) => Number(v)),
    z6.z.literal("undefined").transform(() => void 0)
    // sdk version 1.8.2 sends undefined string if not set
  ]).optional(),
  dcaEnabled: booleanString.default("false"),
  isVaultSwap: booleanString.optional(),
  isOnChain: booleanString.optional()
}).transform((args, ctx) => {
  const { srcAsset, destAsset } = chainflip.getInternalAssets(args, false);
  let hadError = false;
  if (srcAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({ asset: args.srcAsset, chain: args.srcChain })}`,
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (destAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({ asset: args.destAsset, chain: args.destChain })}`,
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (srcAsset === "Dot" || destAsset === "Dot") {
    ctx.addIssue({
      message: "Dot is not supported",
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.ccmGasBudget !== void 0 && args.ccmMessageLengthBytes === void 0) {
    ctx.addIssue({
      message: `ccmMessageLengthBytes must be set if ccmGasBudget is set`,
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.ccmGasBudget === void 0 && args.ccmMessageLengthBytes !== void 0) {
    ctx.addIssue({
      message: `ccmGasBudget must be set if ccmMessageLengthBytes is set`,
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.isOnChain && args.isVaultSwap) {
    ctx.addIssue({
      message: "isOnChain and isVaultSwap cannot be set at the same time",
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (args.isOnChain && args.brokerCommissionBps !== void 0 && args.brokerCommissionBps > 0) {
    ctx.addIssue({
      message: "isOnChain cannot be set with a non-zero broker commission",
      code: z6.z.ZodIssueCode.custom
    });
    hadError = true;
  }
  if (hadError) return z6.z.NEVER;
  const ccmParams = args.ccmGasBudget !== void 0 && args.ccmMessageLengthBytes !== void 0 ? { gasBudget: args.ccmGasBudget, messageLengthBytes: args.ccmMessageLengthBytes } : void 0;
  return {
    srcAsset,
    destAsset,
    amount: args.amount,
    brokerCommissionBps: args.brokerCommissionBps,
    ccmParams,
    dcaEnabled: args.dcaEnabled,
    isVaultSwap: args.isVaultSwap,
    isOnChain: args.isOnChain
  };
});
var ccmParamsSchema = z6.z.object({
  gasBudget: z6.z.union([numericString, hexString]).transform((n) => number.hexEncodeNumber(BigInt(n))),
  // https://github.com/chainflip-io/chainflip-backend/blob/415aa9e20ec4046c68892cd34798e5d831c5b83f/state-chain/chains/src/lib.rs#L709
  message: hexStringWithMaxByteSize(15e3),
  // https://github.com/chainflip-io/chainflip-backend/blob/415aa9e20ec4046c68892cd34798e5d831c5b83f/state-chain/chains/src/lib.rs#L710
  ccmAdditionalData: hexStringWithMaxByteSize(3e3).optional(),
  /** @deprecated DEPRECATED(1.10) pass additionalData instead */
  cfParameters: hexStringWithMaxByteSize(3e3).optional()
}).transform(({ gasBudget, message, ccmAdditionalData, cfParameters }) => ({
  gasBudget,
  message,
  ccmAdditionalData: ccmAdditionalData ?? cfParameters ?? "0x"
}));
var affiliateBroker = z6.z.object({
  account: chainflipAddress,
  commissionBps: z6.z.number()
}).transform(({ account, commissionBps: bps }) => ({ account, bps }));
var dcaParams = z6.z.object({
  numberOfChunks: z6.z.number(),
  chunkIntervalBlocks: z6.z.number()
});
var fillOrKillParams = z6.z.object({
  retryDurationBlocks: z6.z.number(),
  refundAddress: z6.z.string(),
  minPriceX128: numericString,
  maxOraclePriceSlippage: basisPoints.nullish().transform((v) => v ?? null),
  refundCcmMetadata: ccmParamsSchema.nullish().optional().default(null).transform(
    (v) => v && {
      ...v,
      cfParameters: v.ccmAdditionalData
      // deprecated
    }
  )
});
var validatePolkadotAddress = (address) => {
  if (string.isHex(address)) return address.length === 66;
  try {
    ss58__namespace.decode(address);
    return true;
  } catch {
    return false;
  }
};
var validateEvmAddress = (address) => ethers__namespace.isAddress(address);
var validateBitcoinMainnetAddress = (address) => bitcoin__namespace.isValidAddressForNetwork(address, "mainnet");
var validateBitcoinTestnetAddress = (address) => bitcoin__namespace.isValidAddressForNetwork(address, "testnet");
var validateBitcoinRegtestAddress = (address) => bitcoin__namespace.isValidAddressForNetwork(address, "regtest");
var validateSolanaAddress = solana.isValidSolanaAddress;
var validators = {
  mainnet: {
    Bitcoin: validateBitcoinMainnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  perseverance: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  sisyphos: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  backspin: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  },
  localnet: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress,
    Solana: validateSolanaAddress,
    Assethub: validatePolkadotAddress
  }
};
var validateAddress = (chain2, address, network) => validators[network][chain2](address);

// ../shared/src/broker.ts
var transformedDcaParamsSchema = dcaParams.transform(
  ({ numberOfChunks, chunkIntervalBlocks }) => ({
    number_of_chunks: numberOfChunks,
    chunk_interval: chunkIntervalBlocks
  })
);
var transformedCcmParamsSchema = ccmParamsSchema.transform(
  ({ message, gasBudget, ccmAdditionalData }) => ({
    message,
    gas_budget: gasBudget,
    ccm_additional_data: ccmAdditionalData,
    /** @deprecated DEPRECATED(1.10) we still need to pass cf_parameters until 1.8 is deployed to all networks */
    cf_parameters: ccmAdditionalData
  })
);
var transformedFokSchema = z6.z.object({
  retryDurationBlocks: z6.z.number(),
  refundAddress: z6.z.string(),
  minPriceX128: numericString,
  maxOraclePriceSlippage: basisPoints.nullish().transform((v) => v ?? null),
  refundCcmMetadata: transformedCcmParamsSchema.nullable().optional().default(null)
}).transform(
  ({
    retryDurationBlocks,
    refundAddress,
    minPriceX128,
    maxOraclePriceSlippage,
    refundCcmMetadata
  }) => ({
    retry_duration: retryDurationBlocks,
    refund_address: refundAddress,
    min_price: `0x${BigInt(minPriceX128).toString(16)}`,
    max_oracle_price_slippage: maxOraclePriceSlippage,
    refund_ccm_metadata: refundCcmMetadata
  })
);
var getDepositAddressRequestSchema = (network) => z6.z.object({
  srcAsset: assetAndChain,
  destAsset: assetAndChain,
  destAddress: z6.z.string(),
  commissionBps: z6.z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z6.z.number().optional(),
  affiliates: z6.z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional()
}).superRefine((val, ctx) => {
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
});
var getVaultSwapParameterEncodingRequestSchema = (network) => z6.z.object({
  srcAsset: assetAndChain,
  srcAddress: z6.z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z6.z.string(),
  amount: unsignedInteger,
  commissionBps: z6.z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z6.z.number().optional(),
  affiliates: z6.z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional(),
  extraParams: z6.z.object({ seed: hexString.optional() }).optional(),
  brokerAccount: chainflipAddress.optional()
}).superRefine((val, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (val.extraParams?.seed && val.extraParams.seed.length !== 66) {
    ctx.addIssue({ message: "Seed must be 32 bytes", code: z6.z.ZodIssueCode.custom });
  }
}).transform((data) => {
  let extraParams;
  if (data.srcAsset.chain === "Bitcoin") {
    const minOutputAmount = BigNumber3__default.default(data.amount.toString()).multipliedBy(tickMath.priceX128ToPrice(data.fillOrKillParams.min_price)).toFixed(0);
    extraParams = {
      chain: "Bitcoin",
      min_output_amount: `0x${BigInt(minOutputAmount).toString(16)}`,
      retry_duration: data.fillOrKillParams.retry_duration,
      max_oracle_price_slippage: data.fillOrKillParams.max_oracle_price_slippage
    };
  } else if (data.srcAsset.chain === "Ethereum" || data.srcAsset.chain === "Arbitrum") {
    extraParams = {
      chain: data.srcAsset.chain,
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else if (data.srcAsset.chain === "Solana") {
    assert(data.srcAddress, "srcAddress is required for Solana");
    extraParams = {
      chain: "Solana",
      from: data.srcAddress,
      seed: data.extraParams?.seed ?? bytes.bytesToHex(crypto.getRandomValues(new Uint8Array(32))),
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else {
    throw new Error(`parameter encoding is not supported for ${data.srcAsset.chain}`);
  }
  return { ...data, extraParams };
});
async function requestSwapDepositAddress(request, opts, chainflipNetwork) {
  const client = new rpc.HttpClient(opts.url);
  if (request.srcChain && typeof request.srcAsset === "string") {
    request = { ...request, srcAsset: { asset: request.srcAsset, chain: request.srcChain } };
  }
  if (request.destChain && typeof request.destAsset === "string") {
    request = { ...request, destAsset: { asset: request.destAsset, chain: request.destChain } };
  }
  const params = getDepositAddressRequestSchema(chainflipNetwork).parse(request);
  const response = await client.sendRequest(
    "broker_request_swap_deposit_address",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.fillOrKillParams,
    params.dcaParams
  );
  switch (params.srcAsset.chain) {
    case "Assethub":
      if (string.isHex(response.address)) {
        response.address = ss58__namespace.encode({ data: response.address, ss58Format: DOT_PREFIX });
      }
      break;
    case "Ethereum":
    case "Arbitrum":
    case "Bitcoin":
    case "Solana":
      break;
    default:
      return assertion.unreachable(params.srcAsset, "unexpected chain");
  }
  return transformKeysToCamelCase(response);
}
async function requestSwapParameterEncoding(request, opts, chainflipNetwork) {
  const client = new rpc.HttpClient(opts.url);
  const params = getVaultSwapParameterEncodingRequestSchema(chainflipNetwork).parse(request);
  const response = await client.sendRequest(
    "broker_request_swap_parameter_encoding",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.extraParams,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.dcaParams
  );
  return transformKeysToCamelCase(response);
}
var cfParameterEncodingRequestSchema = z6.z.object({
  srcAsset: assetAndChain,
  srcAddress: z6.z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z6.z.string(),
  amount: unsignedInteger,
  commissionBps: z6.z.number().optional().default(0),
  ccmParams: transformedCcmParamsSchema.optional(),
  maxBoostFeeBps: z6.z.number().optional(),
  affiliates: z6.z.array(affiliateBroker).optional(),
  fillOrKillParams: transformedFokSchema,
  dcaParams: transformedDcaParamsSchema.optional(),
  network: z6.z.enum(chainflip.chainflipNetworks)
}).superRefine(({ network, ...val }, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
}).transform(({ network, ...rest }) => rest);
async function requestCfParametersEncoding(request, opts) {
  const client = new rpc.HttpClient(opts.url);
  const params = cfParameterEncodingRequestSchema.parse(request);
  const response = await client.sendRequest(
    "broker_encode_cf_parameters",
    params.srcAsset,
    params.destAsset,
    params.destAddress,
    params.commissionBps,
    params.fillOrKillParams,
    params.ccmParams,
    params.maxBoostFeeBps,
    params.affiliates,
    params.dcaParams
  );
  return response;
}

// ../shared/src/api/encodeCfParameters.ts
var CfParameterEncodingRequestWithBroker = cfParameterEncodingRequestSchema.and(
  z6.z.object({
    brokerAccount: chainflipAddress.optional()
  })
);
var TransformedCcmParams = ccmParamsSchema.transform(
  ({ message, gasBudget, ccmAdditionalData }) => ({
    message,
    gas_budget: gasBudget,
    ccm_additional_data: ccmAdditionalData,
    /** @deprecated DEPRECATED(1.10) we still need to pass cf_parameters until 1.8 is deployed to all networks */
    cf_parameters: ccmAdditionalData
  })
);
var FillOrKillParams = fillOrKillParams.transform(
  ({
    retryDurationBlocks,
    refundAddress,
    minPriceX128,
    maxOraclePriceSlippage,
    refundCcmMetadata
  }) => ({
    retry_duration: retryDurationBlocks,
    refund_address: refundAddress,
    min_price: `0x${BigInt(minPriceX128).toString(16)}`,
    max_oracle_price_slippage: maxOraclePriceSlippage,
    refund_ccm_metadata: refundCcmMetadata && {
      gas_budget: refundCcmMetadata.gasBudget,
      message: refundCcmMetadata.message,
      ccm_additional_data: refundCcmMetadata.ccmAdditionalData,
      /** @deprecated DEPRECATED(1.10) */
      cf_parameters: refundCcmMetadata.cfParameters
    }
  })
);
var TransformedDcaParams = dcaParams.transform(
  ({ numberOfChunks, chunkIntervalBlocks }) => ({
    number_of_chunks: numberOfChunks,
    chunk_interval: chunkIntervalBlocks
  })
);
var EncodeVaultSwapBody = z6.z.object({
  srcAsset: assetAndChain,
  srcAddress: z6.z.string().optional(),
  destAsset: assetAndChain,
  destAddress: z6.z.string(),
  amount: unsignedInteger,
  commissionBps: z6.z.number().optional().default(0),
  ccmParams: TransformedCcmParams.optional(),
  maxBoostFeeBps: z6.z.number().optional(),
  affiliates: z6.z.array(affiliateBroker).optional(),
  fillOrKillParams: FillOrKillParams,
  dcaParams: TransformedDcaParams.optional(),
  extraParams: z6.z.object({ seed: hexString.optional() }).optional(),
  network: z6.z.enum(chainflip.chainflipNetworks),
  brokerAccount: chainflipAddress.optional()
}).superRefine(({ network, ...val }, ctx) => {
  if (val.srcAddress && !validateAddress(val.srcAsset.chain, val.srcAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.srcAddress}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.destAsset.chain, val.destAddress, network)) {
    ctx.addIssue({
      message: `Address "${val.destAddress}" is not a valid "${val.destAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (!validateAddress(val.srcAsset.chain, val.fillOrKillParams.refund_address, network)) {
    ctx.addIssue({
      message: `Address "${val.fillOrKillParams.refund_address}" is not a valid "${val.srcAsset.chain}" address for "${network}"`,
      code: z6.z.ZodIssueCode.custom
    });
  }
  if (val.extraParams?.seed && val.extraParams.seed.length !== 66) {
    ctx.addIssue({ message: "Seed must be 32 bytes", code: z6.z.ZodIssueCode.custom });
  }
}).transform(({ network, ...data }) => {
  let extraParams;
  if (data.srcAsset.chain === "Bitcoin") {
    const minOutputAmount = BigNumber3.BigNumber(data.amount.toString()).multipliedBy(tickMath.priceX128ToPrice(data.fillOrKillParams.min_price)).toFixed(0);
    extraParams = {
      chain: "Bitcoin",
      min_output_amount: `0x${BigInt(minOutputAmount).toString(16)}`,
      retry_duration: data.fillOrKillParams.retry_duration,
      max_oracle_price_slippage: data.fillOrKillParams.max_oracle_price_slippage
    };
  } else if (data.srcAsset.chain === "Ethereum" || data.srcAsset.chain === "Arbitrum") {
    extraParams = {
      chain: data.srcAsset.chain,
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else if (data.srcAsset.chain === "Solana") {
    assert(data.srcAddress, "srcAddress is required for Solana");
    extraParams = {
      chain: "Solana",
      from: data.srcAddress,
      seed: data.extraParams?.seed ?? bytes.bytesToHex(crypto.getRandomValues(new Uint8Array(32))),
      input_amount: `0x${data.amount.toString(16)}`,
      refund_parameters: data.fillOrKillParams
    };
  } else {
    throw new Error(`parameter encoding is not supported for ${data.srcAsset.chain}`);
  }
  return { ...data, extraParams };
});
var EncodedVaultSwapData = z6.z.discriminatedUnion("chain", [
  z6.z.object({
    chain: z6.z.literal("Bitcoin"),
    nulldataPayload: hexString,
    depositAddress: z6.z.string()
  }),
  z6.z.object({
    chain: z6.z.enum(["Ethereum", "Arbitrum"]),
    value: z6.z.string(),
    to: hexString,
    calldata: hexString,
    sourceTokenAddress: hexString.optional()
  }),
  z6.z.object({
    chain: z6.z.literal("Solana"),
    programId: z6.z.string(),
    data: hexString,
    accounts: z6.z.array(
      z6.z.object({
        pubkey: z6.z.string(),
        isSigner: z6.z.boolean(),
        isWritable: z6.z.boolean()
      })
    )
  })
]);
var NetworkInfo = z6__default.default.object({
  assets: z6__default.default.array(
    z6__default.default.object({
      asset: z6__default.default.enum(chainflip.chainflipAssets),
      vaultSwapDepositsEnabled: z6__default.default.boolean(),
      depositChannelDepositsEnabled: z6__default.default.boolean(),
      depositChannelCreationEnabled: z6__default.default.boolean(),
      egressEnabled: z6__default.default.boolean(),
      boostDepositsEnabled: z6__default.default.boolean()
    })
  ),
  cfBrokerCommissionBps: z6__default.default.number()
});
var ChainflipAsset = z6.z.enum(chainflip.chainflipAssets);
var NetworkStatus = z6.z.object({
  assets: z6.z.object({
    deposit: z6.z.array(ChainflipAsset),
    destination: z6.z.array(ChainflipAsset),
    all: z6.z.array(ChainflipAsset)
  }),
  boostDepositsEnabled: z6.z.boolean(),
  cfBrokerCommissionBps: z6.z.number()
});
var OpenSwapDepositChannelBody = z6.z.object({
  srcAsset: asset,
  destAsset: asset,
  srcChain: chain,
  destChain: chain,
  destAddress: z6.z.string(),
  amount: numericString,
  ccmParams: ccmParamsSchema.optional(),
  maxBoostFeeBps: z6.z.number().optional(),
  srcAddress: z6.z.string().optional(),
  fillOrKillParams,
  dcaParams: dcaParams.optional(),
  quote: z6.z.object({
    intermediateAmount: z6.z.string().optional(),
    egressAmount: z6.z.string(),
    estimatedPrice: z6.z.string(),
    recommendedSlippageTolerancePercent: z6.z.number().optional(),
    recommendedLivePriceSlippageTolerancePercent: z6.z.number().optional()
  }).optional(),
  takeCommission: z6.z.boolean().optional()
}).transform(({ amount, ...rest }) => ({
  ...rest,
  expectedDepositAmount: amount
}));
var DepositChannelInfo = z6.z.object({
  id: z6.z.string(),
  depositAddress: z6.z.string(),
  brokerCommissionBps: z6.z.number(),
  maxBoostFeeBps: z6.z.number(),
  issuedBlock: z6.z.number(),
  srcChainExpiryBlock: z6.z.string(),
  estimatedExpiryTime: z6.z.number().optional(),
  channelOpeningFee: z6.z.string()
});

// ../shared/src/api/contract.ts
var c = core.initContract();
var apiContract = c.router(
  {
    /** @deprecated DEPRECATED(1.10): using `networkInfo` now */
    networkStatus: {
      method: "GET",
      path: "/networkStatus",
      responses: {
        200: NetworkStatus
      },
      summary: "Get information about the Chainflip network"
    },
    networkInfo: {
      method: "GET",
      path: "/networkInfo",
      responses: {
        200: NetworkInfo
      },
      summary: "Get information about the Chainflip network"
    },
    encodeCfParameters: {
      method: "POST",
      path: "/encodeCfParameters",
      body: CfParameterEncodingRequestWithBroker,
      responses: {
        200: hexString
      }
    },
    encodeVaultSwapData: {
      method: "POST",
      path: "/encodeVaultSwapData",
      body: EncodeVaultSwapBody,
      responses: {
        200: EncodedVaultSwapData
      }
    },
    openSwapDepositChannel: {
      method: "POST",
      path: "/openSwapDepositChannel",
      body: OpenSwapDepositChannelBody,
      responses: {
        201: DepositChannelInfo
      }
    }
  },
  {
    pathPrefix: "/api"
  }
);
var getPriceX128FromPrice = (price, srcAsset, destAsset) => BigNumber3__default.default(price).multipliedBy(new BigNumber3__default.default(2).pow(128)).shiftedBy(chainflip.assetConstants[destAsset].decimals - chainflip.assetConstants[srcAsset].decimals).toFixed(0);
var blocksPerMinute = 60 / consts.CHAINFLIP_BLOCK_TIME_SECONDS;
function parseFoKParams(params, quote) {
  const srcAsset = chainflip.getInternalAsset(quote.srcAsset);
  const destAsset = chainflip.getInternalAsset(quote.destAsset);
  const livePriceProtectionDisabled = params.livePriceSlippageTolerancePercent === false;
  const livePriceProtectionEnabled = typeof params.livePriceSlippageTolerancePercent === "string" || typeof params.livePriceSlippageTolerancePercent === "number";
  const livePriceProtectionAvailable = isNotNullish(
    quote.recommendedLivePriceSlippageTolerancePercent
  );
  if (livePriceProtectionEnabled && !livePriceProtectionAvailable) {
    throw new Error("Live price protection is not available for this asset pair");
  }
  let minPrice;
  let livePriceSlippageTolerancePercent = null;
  if (!livePriceProtectionDisabled) {
    if (isNotNullish(params.livePriceSlippageTolerancePercent) && params.livePriceSlippageTolerancePercent !== false) {
      livePriceSlippageTolerancePercent = new BigNumber3__default.default(params.livePriceSlippageTolerancePercent);
      assert(!livePriceSlippageTolerancePercent.isNaN(), "Invalid live price slippage tolerance");
      assert(
        livePriceSlippageTolerancePercent.gte(0) && livePriceSlippageTolerancePercent.lte(100),
        "Live price slippage tolerance must be between 0 and 100 inclusive"
      );
    } else if (quote.recommendedLivePriceSlippageTolerancePercent) {
      livePriceSlippageTolerancePercent = new BigNumber3__default.default(
        quote.recommendedLivePriceSlippageTolerancePercent
      );
      assert(!livePriceSlippageTolerancePercent.isNaN(), "Invalid live price slippage tolerance");
    }
  }
  if ("minPrice" in params) {
    assert(
      !("slippageTolerancePercent" in params),
      "Cannot have both minPrice and slippageTolerancePercent"
    );
    minPrice = params.minPrice;
  } else if ("slippageTolerancePercent" in params) {
    const tolerance = new BigNumber3__default.default(params.slippageTolerancePercent);
    assert(!tolerance.isNaN(), "Invalid slippage tolerance");
    assert(
      tolerance.gte(0) && tolerance.lte(100),
      "Slippage tolerance must be between 0 and 100 inclusive",
      RangeError
    );
    const estimatedPrice = new BigNumber3__default.default(quote.estimatedPrice);
    assert(!estimatedPrice.isNaN(), "Invalid estimated price");
    minPrice = estimatedPrice.times(new BigNumber3__default.default(100).minus(tolerance).dividedBy(100)).toFixed(chainflip.assetConstants[destAsset].decimals);
  } else {
    throw new Error("Either minPrice or slippageTolerancePercent must be provided");
  }
  const retryDurationBlocks = "retryDurationBlocks" in params ? params.retryDurationBlocks : Math.max(Math.ceil(params.retryDurationMinutes * blocksPerMinute), 0);
  const maxOraclePriceSlippage = livePriceSlippageTolerancePercent?.multipliedBy(100).toNumber() ?? null;
  const parsed = {
    retryDurationBlocks,
    minPriceX128: getPriceX128FromPrice(minPrice, srcAsset, destAsset),
    maxOraclePriceSlippage,
    refundCcmMetadata: params.refundCcmMetadata ?? null
  };
  return "refundAddress" in params ? { ...parsed, refundAddress: params.refundAddress } : parsed;
}
var isTestnet = (network) => network !== "mainnet";

// ../shared/src/consts.ts
var ETHEREUM_EVM_CHAIN_ID = {
  backspin: 10997,
  // backspin ethereum
  sisyphos: 11155111,
  // sepolia
  perseverance: 11155111,
  // sepolia
  mainnet: 1
  // mainnet
};
var ARBITRUM_EVM_CHAIN_ID = {
  backspin: 412346,
  // backspin arbitrum
  sisyphos: 421614,
  // arb-sepolia
  perseverance: 421614,
  // arb-sepolia
  mainnet: 42161
  // mainnet
};
var getEvmChainId = (chain2, network) => {
  switch (chain2) {
    case "Ethereum":
      return ETHEREUM_EVM_CHAIN_ID[network];
    case "Arbitrum":
      return ARBITRUM_EVM_CHAIN_ID[network];
    default:
      return void 0;
  }
};
var SEPOLIA_USDC_CONTRACT_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
var SEPOLIA_USDT_CONTRACT_ADDRESS = "0x27CEA6Eb8a21Aae05Eb29C91c5CA10592892F584";
var ADDRESSES = {
  backspin: {
    FLIP_CONTRACT_ADDRESS: "0x10C6E9530F1C1AF873a391030a1D9E8ed0630D26",
    USDC_CONTRACT_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    USDT_CONTRACT_ADDRESS: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    ARBUSDC_CONTRACT_ADDRESS: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xeEBe00Ac0756308ac4AaBfD76c05c4F3088B8883",
    SOLUSDC_CONTRACT_ADDRESS: "24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p"
  },
  sisyphos: {
    FLIP_CONTRACT_ADDRESS: "0xcD079EAB6B5443b545788Fd210C8800FEADd87fa",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x1F7fE41C798cc7b1D34BdC8de2dDDA4a4bE744D9",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  perseverance: {
    FLIP_CONTRACT_ADDRESS: "0xdC27c60956cB065D19F08bb69a707E37b36d8086",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xA34a967197Ee90BB7fb28e928388a573c5CFd099",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  mainnet: {
    FLIP_CONTRACT_ADDRESS: "0x826180541412D574cf1336d22c0C0a287822678A",
    USDC_CONTRACT_ADDRESS: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    USDT_CONTRACT_ADDRESS: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    ARBUSDC_CONTRACT_ADDRESS: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x6995Ab7c4D7F4B03f467Cf4c8E920427d9621DBd",
    SOLUSDC_CONTRACT_ADDRESS: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  }
};
var ASSET_BLACKLIST = ["Dot"];
var envSafeAssetBlacklist = (network) => isTestnet(network) ? ASSET_BLACKLIST : ASSET_BLACKLIST;

// ../shared/src/dataStructures.ts
var MultiCache = class {
  constructor(fetchers) {
    this.fetchers = fetchers;
  }
  values = {};
  read(type) {
    const { fetch, ttl } = this.fetchers[type];
    let cached = this.values[type];
    if (!cached || cached.timestamp + ttl < Date.now()) {
      cached = {
        timestamp: Date.now(),
        value: fetch().catch((err) => {
          this.values[type] = void 0;
          throw err;
        })
      };
      this.values[type] = cached;
    }
    return cached.value;
  }
};
var camelCase = (str) => str.replace(/_([a-z])/g, (_, char) => char.toUpperCase());
var camelCaseKeys = (obj) => {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map((item) => camelCaseKeys(item));
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [camelCase(key), camelCaseKeys(value)])
  );
};
var createRequest = (method) => async (urlOrNetwork, ...params) => {
  const url = "network" in urlOrNetwork ? rpc.constants.PUBLIC_RPC_ENDPOINTS[urlOrNetwork.network] : urlOrNetwork.rpcUrl;
  const result = await new rpc.HttpClient(url).sendRequest(method, ...params);
  return camelCaseKeys(result);
};
var transform = (fn, cb) => (...args) => fn(...args).then(cb);
var getEnvironment = createRequest("cf_environment");
var getAllBoostPoolsDepth = transform(
  createRequest("cf_boost_pools_depth"),
  (result) => result.filter(({ chain: chain2 }) => chain2 !== "Polkadot").map(({ chain: chain2, asset: asset2, ...rest }) => ({
    asset: chainflip.getInternalAsset({ chain: chain2, asset: asset2 }),
    ...rest
  }))
);
var MAX_SWAP_AMOUNT = 2n ** 128n - 1n;
var validateSwapAmount = (env, asset2, amount) => {
  const minimumAmount = chainflip.readAssetValue(env.ingressEgress.minimumDepositAmounts, asset2);
  if (amount < minimumAmount) {
    return {
      success: false,
      reason: `expected amount is below minimum swap amount (${minimumAmount})`
    };
  }
  const maxAmount = chainflip.readAssetValue(env.swapping.maximumSwapAmounts, asset2) ?? MAX_SWAP_AMOUNT;
  if (maxAmount != null && amount > maxAmount) {
    return {
      success: false,
      reason: `expected amount is above maximum swap amount (${maxAmount})`
    };
  }
  return { success: true };
};
var getTokenContractAddress = (asset2, network) => {
  switch (asset2) {
    case "Btc":
    case "Dot":
    case "Eth":
    case "ArbEth":
    case "Sol":
    case "HubDot":
    case "HubUsdc":
    case "HubUsdt":
      return void 0;
    default:
      return ADDRESSES[network][`${string.toUpperCase(asset2)}_CONTRACT_ADDRESS`];
  }
};
var assetNames = {
  Eth: "Ether",
  Flip: "FLIP",
  Usdc: "USDC",
  Usdt: "USDT",
  Dot: "Polkadot",
  Btc: "Bitcoin",
  ArbEth: "Arbitrum Ether",
  ArbUsdc: "Arbitrum USDC",
  Sol: "Solana",
  SolUsdc: "Solana USDC",
  HubDot: "Assethub DOT",
  HubUsdc: "Assethub USDC",
  HubUsdt: "Assethub USDT"
};
var getAssetData = (asset2, network, env) => {
  const assetConstant = chainflip.assetConstants[asset2];
  return {
    chainflipId: asset2,
    asset: assetConstant.symbol,
    chain: assetConstant.chain,
    contractAddress: getTokenContractAddress(asset2, network),
    decimals: assetConstant.decimals,
    name: assetNames[asset2],
    symbol: assetConstant.symbol,
    isMainnet: !isTestnet(network),
    minimumSwapAmount: chainflip.readAssetValue(env.ingressEgress.minimumDepositAmounts, asset2).toString(),
    maximumSwapAmount: chainflip.readAssetValue(env.swapping.maximumSwapAmounts, asset2)?.toString() ?? null,
    minimumEgressAmount: chainflip.readAssetValue(env.ingressEgress.minimumEgressAmounts, asset2).toString()
  };
};

// src/swap/chains.ts
var getChainData = (chain2, network, env) => ({
  chain: chain2,
  name: chain2,
  evmChainId: getEvmChainId(chain2, network),
  isMainnet: !isTestnet(network),
  requiredBlockConfirmations: isNotNullish(
    env.ingressEgress.witnessSafetyMargins[chain2]
  ) ? Number(env.ingressEgress.witnessSafetyMargins[chain2]) + 1 : void 0,
  maxRetryDurationBlocks: env.swapping.maxSwapRetryDurationBlocks
});

// package.json
var package_default = {
  version: "1.11.1"};

// src/swap/consts.ts
var CF_SDK_VERSION_HEADERS = { "X-Chainflip-Sdk-Version": package_default.version };
var BACKEND_SERVICE_URLS = {
  backspin: "https://chainflip-swap-backspin.staging/",
  sisyphos: "https://chainflip-swap.staging/",
  perseverance: "https://chainflip-swap-perseverance.chainflip.io/",
  mainnet: "https://chainflip-swap.chainflip.io/"
};
var getQuoteV2 = async (baseUrl, quoteRequest, { signal }) => {
  const affiliateCommissionBps = quoteRequest.affiliateBrokers?.reduce((acc, affiliate) => acc + affiliate.commissionBps, 0) ?? 0;
  const totalBrokerCommissionBps = (quoteRequest.brokerCommissionBps ?? 0) + affiliateCommissionBps;
  const params = {
    amount: quoteRequest.amount,
    srcChain: quoteRequest.srcChain,
    srcAsset: quoteRequest.srcAsset,
    destChain: quoteRequest.destChain,
    destAsset: quoteRequest.destAsset,
    isVaultSwap: String(Boolean(quoteRequest.isVaultSwap)),
    isOnChain: String(Boolean(quoteRequest.isOnChain)),
    ...totalBrokerCommissionBps && {
      brokerCommissionBps: String(totalBrokerCommissionBps)
    },
    ...quoteRequest.ccmParams && {
      ccmGasBudget: quoteRequest.ccmParams.gasBudget,
      ccmMessageLengthBytes: String(quoteRequest.ccmParams.messageLengthBytes)
    },
    dcaEnabled: String(Boolean(quoteRequest.dcaEnabled))
  };
  const { data } = await axios__default.default.get("/v2/quote", {
    baseURL: baseUrl,
    params,
    signal,
    headers: CF_SDK_VERSION_HEADERS
  });
  return { ...quoteRequest, quotes: data };
};
var getStatusV2 = async (baseUrl, { id }, { signal }) => {
  const { data } = await axios__default.default.get(`/v2/swaps/${id}`, {
    baseURL: baseUrl,
    signal,
    headers: CF_SDK_VERSION_HEADERS
  });
  return data;
};

// src/swap/sdk.ts
var assertQuoteValid = (quote) => {
  switch (quote.type) {
    case "REGULAR":
      break;
    case "DCA":
      if (quote.dcaParams == null) throw new Error("Failed to find DCA parameters from quote");
      break;
    default:
      throw new Error("Invalid quote type");
  }
};
var SwapSDK = class {
  options;
  rpcConfig;
  apiClient;
  cache;
  dcaEnabled = false;
  blackListedAssets;
  constructor(options = {}) {
    const network = options.network ?? "perseverance";
    this.options = {
      ...options,
      network,
      backendUrl: options.backendUrl ?? BACKEND_SERVICE_URLS[network]
    };
    this.rpcConfig = options.rpcUrl ? { rpcUrl: options.rpcUrl } : { network };
    this.apiClient = core.initClient(apiContract, {
      // remove trailing slashes. this bug has been fixed in `@ts-rest/core`
      // but it hasn't been released yet
      baseUrl: this.options.backendUrl.replace(/\/+$/, ""),
      baseHeaders: CF_SDK_VERSION_HEADERS
    });
    this.dcaEnabled = options.enabledFeatures?.dca ?? false;
    this.cache = new MultiCache({
      environment: {
        fetch: () => getEnvironment(this.rpcConfig),
        ttl: 6e4
      },
      networkInfo: {
        fetch: async () => {
          const res = await this.apiClient.networkInfo();
          assert(res.status === 200, "Failed to fetch network info");
          return res.body;
        },
        ttl: 6e4
      }
    });
    this.blackListedAssets = envSafeAssetBlacklist(this.options.network);
  }
  async getChains(sourceChain, type = "all") {
    if (sourceChain && !chainflip.chainflipChains.includes(sourceChain)) {
      throw new Error(`unsupported source chain "${sourceChain}"`);
    }
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets(type)
    ]);
    const supportedChains = new Set(supportedAssets.map((a) => chainflip.assetConstants[a].chain));
    if (sourceChain && !supportedChains.has(sourceChain)) return [];
    return [...supportedChains].filter((chain2) => chain2 !== "Polkadot").map((chain2) => getChainData(chain2, this.options.network, env)).filter((chain2) => chain2.chain !== sourceChain);
  }
  async getStateChainEnvironment() {
    return this.cache.read("environment");
  }
  async getSupportedAssets(type) {
    const assets = await this.cache.read("networkInfo");
    return assets.assets.filter((a) => !this.blackListedAssets.includes(a.asset)).filter((a) => {
      switch (type) {
        case "all":
          return true;
        case "deposit":
          return a.depositChannelCreationEnabled && a.depositChannelDepositsEnabled && a.vaultSwapDepositsEnabled;
        case "destination":
          return a.egressEnabled;
        case "depositChannel":
          return a.depositChannelCreationEnabled && a.depositChannelDepositsEnabled;
        case "vaultSwap":
          return a.vaultSwapDepositsEnabled;
        default:
          return assertion.unreachable(type, "unexpected type");
      }
    }).map((a) => a.asset);
  }
  async getBoostPoolsDepth() {
    return getAllBoostPoolsDepth(this.rpcConfig);
  }
  async getAssets(chain2, type = "all") {
    if (chain2 && !chainflip.chainflipChains.includes(chain2)) throw new Error(`unsupported chain "${chain2}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets(type)
    ]);
    return supportedAssets.filter((asset2) => asset2 !== "Dot").map((asset2) => getAssetData(asset2, this.options.network, env)).filter((asset2) => !chain2 || asset2.chain === chain2);
  }
  // eslint-disable-next-line class-methods-use-this
  shouldTakeCommission() {
    return false;
  }
  async getCommissionBps(brokerCommissionBps) {
    if (this.shouldTakeCommission()) {
      return (await this.cache.read("networkInfo")).cfBrokerCommissionBps;
    }
    return brokerCommissionBps ?? this.options.broker?.commissionBps ?? 0;
  }
  async getQuoteV2(quoteRequest, options = {}) {
    const submitterBrokerCommissionBps = await this.getCommissionBps(
      quoteRequest.brokerCommissionBps
    );
    return getQuoteV2(
      this.options.backendUrl,
      {
        ...quoteRequest,
        brokerCommissionBps: submitterBrokerCommissionBps,
        dcaEnabled: this.dcaEnabled
      },
      options
    );
  }
  getStatusV2(swapStatusRequest, options = {}) {
    return getStatusV2(this.options.backendUrl, swapStatusRequest, options);
  }
  async validateSwapAmount(asset2, amount) {
    const stateChainEnv = await this.getStateChainEnvironment();
    const internalAsset = chainflip.getInternalAsset(asset2);
    const result = validateSwapAmount(stateChainEnv, internalAsset, amount);
    if (!result.success) throw new Error(result.reason);
  }
  async getSwapLimits() {
    const {
      swapping: { maximumSwapAmounts },
      ingressEgress: { minimumDepositAmounts }
    } = await this.getStateChainEnvironment();
    return { minimumSwapAmounts: minimumDepositAmounts, maximumSwapAmounts };
  }
  async getRequiredBlockConfirmations() {
    const {
      ingressEgress: { witnessSafetyMargins }
    } = await this.getStateChainEnvironment();
    return chainflip.chainflipChains.filter((chain2) => chain2 !== "Polkadot").reduce(
      (acc, chain2) => {
        acc[chain2] = witnessSafetyMargins[chain2] ? Number(witnessSafetyMargins[chain2]) + 1 : null;
        return acc;
      },
      {}
    );
  }
  async getChannelOpeningFees() {
    const {
      ingressEgress: { channelOpeningFees }
    } = await this.getStateChainEnvironment();
    return channelOpeningFees;
  }
  async getBoostLiquidity(params = {}) {
    let poolsDepth = await this.getBoostPoolsDepth();
    if ("chain" in params && "asset" in params) {
      const { chain: chain2, asset: asset2 } = params;
      const internalAsset = chainflip.getInternalAsset({ chain: chain2, asset: asset2 });
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.asset === internalAsset).sort((a, b) => b.tier - a.tier);
    }
    if ("feeTierBps" in params && params.feeTierBps !== void 0) {
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.tier === params.feeTierBps);
    }
    return poolsDepth.map((depth) => ({
      availableAmount: depth.availableAmount,
      feeTierBps: depth.tier,
      ...chainflip.internalAssetToRpcAsset[depth.asset]
    }));
  }
  async requestDepositAddressV2({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: inputFoKParams,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerCommissionBps: brokerCommissionBpsParam
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    assert(!quote.isVaultSwap, "Cannot open a deposit channel for a vault swap quote");
    assert(!quote.isOnChain, "Cannot open a deposit channel for an on-chain quote");
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot open CCM channel for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot open regular channel for quote with CCM params");
    }
    const brokerCommissionBps = await this.getCommissionBps(brokerCommissionBpsParam);
    const depositAddressRequest = {
      srcAsset: quote.srcAsset.asset,
      srcChain: quote.srcAsset.chain,
      destAsset: quote.destAsset.asset,
      destChain: quote.destAsset.chain,
      srcAddress,
      destAddress,
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      fillOrKillParams: parseFoKParams(inputFoKParams, quote),
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      ccmParams,
      amount: quote.depositAmount
    };
    let response;
    if (this.options.broker) {
      const result = await requestSwapDepositAddress(
        {
          ...depositAddressRequest,
          commissionBps: brokerCommissionBps,
          affiliates
        },
        { url: this.options.broker.url },
        this.options.network
      );
      response = {
        id: `${result.issuedBlock}-${quote.srcAsset.chain}-${result.channelId}`,
        depositAddress: result.address,
        brokerCommissionBps,
        srcChainExpiryBlock: result.sourceChainExpiryBlock,
        maxBoostFeeBps: depositAddressRequest.maxBoostFeeBps,
        channelOpeningFee: result.channelOpeningFee
      };
    } else {
      assert(
        !brokerCommissionBps || this.shouldTakeCommission(),
        "Broker commission is supported only when initializing the SDK with a brokerUrl"
      );
      assert(
        !affiliates?.length,
        "Affiliate brokers are supported only when initializing the SDK with a brokerUrl"
      );
      const res = await this.apiClient.openSwapDepositChannel({
        body: {
          ...depositAddressRequest,
          quote,
          takeCommission: this.shouldTakeCommission()
        }
      });
      assert(res.status === 201, "Failed to open swap deposit channel");
      response = res.body;
    }
    return {
      ...depositAddressRequest,
      depositChannelId: response.id,
      depositAddress: response.depositAddress,
      brokerCommissionBps: response.brokerCommissionBps,
      affiliateBrokers: affiliates ?? [],
      maxBoostFeeBps: Number(response.maxBoostFeeBps) || 0,
      depositChannelExpiryBlock: BigInt(response.srcChainExpiryBlock),
      estimatedDepositChannelExpiryTime: response.estimatedExpiryTime,
      channelOpeningFee: BigInt(response.channelOpeningFee),
      fillOrKillParams: inputFoKParams
    };
  }
  async encodeVaultSwapData({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: inputFoKParams,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerAccount,
    brokerCommissionBps: brokerCommissionBpsParam,
    extraParams
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    assert(quote.isVaultSwap, "Cannot encode vault swap data for non-vault swap quotes");
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot encode CCM swap for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot encode regular swap for quote with CCM params");
    }
    const brokerCommissionBps = await this.getCommissionBps(brokerCommissionBpsParam);
    const vaultSwapRequest = {
      srcAsset: quote.srcAsset,
      destAsset: quote.destAsset,
      srcAddress,
      destAddress,
      amount: quote.depositAmount,
      ccmParams,
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      fillOrKillParams: parseFoKParams(inputFoKParams, quote),
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      extraParams,
      brokerAccount,
      commissionBps: brokerCommissionBps,
      affiliates
    };
    if (this.options.broker) {
      assert(
        !vaultSwapRequest.brokerAccount,
        "Cannot overwrite broker account when initializing the SDK with a brokerUrl"
      );
      return requestSwapParameterEncoding(
        vaultSwapRequest,
        { url: this.options.broker.url },
        this.options.network
      );
    }
    assert(
      !vaultSwapRequest.commissionBps || vaultSwapRequest.brokerAccount || this.shouldTakeCommission(),
      "Broker commission is supported only when setting a broker account"
    );
    assert(
      !vaultSwapRequest.affiliates?.length || vaultSwapRequest.brokerAccount,
      "Affiliate brokers are supported only when setting a broker account"
    );
    const res = await this.apiClient.encodeVaultSwapData({
      body: { ...vaultSwapRequest, network: this.options.network }
    });
    if (res.status !== 200) {
      throw new Error("Failed to encode vault swap data", { cause: res });
    }
    switch (res.body.chain) {
      case "Arbitrum":
      case "Ethereum":
        return { ...res.body, value: BigInt(res.body.value) };
      default:
        return res.body;
    }
  }
  async encodeCfParameters({
    quote,
    srcAddress,
    destAddress,
    fillOrKillParams: fillOrKillParams2,
    affiliateBrokers: affiliates,
    ccmParams,
    brokerAccount,
    brokerCommissionBps
  }) {
    await this.validateSwapAmount(quote.srcAsset, BigInt(quote.depositAmount));
    assertQuoteValid(quote);
    if (ccmParams) {
      assert(quote.ccmParams, "Cannot encode CCM swap for quote without CCM params");
    } else {
      assert(!quote.ccmParams, "Cannot encode regular swap for quote with CCM params");
    }
    const requestParams = {
      srcAsset: quote.srcAsset,
      destAsset: quote.destAsset,
      srcAddress,
      destAddress,
      amount: quote.depositAmount,
      ccmParams,
      maxBoostFeeBps: "maxBoostFeeBps" in quote ? quote.maxBoostFeeBps : void 0,
      fillOrKillParams: parseFoKParams(fillOrKillParams2, quote),
      dcaParams: quote.type === "DCA" ? quote.dcaParams : void 0,
      commissionBps: await this.getCommissionBps(brokerCommissionBps),
      affiliates,
      network: this.options.network
    };
    if (this.options.broker) {
      assert(
        !brokerAccount,
        "Cannot overwrite broker account when initializing the SDK with a brokerUrl"
      );
      return requestCfParametersEncoding(requestParams, { url: this.options.broker.url });
    }
    assert(
      !requestParams.commissionBps || brokerAccount || this.shouldTakeCommission(),
      "Broker commission is supported only when setting a broker account"
    );
    assert(
      !requestParams.affiliates?.length || brokerAccount,
      "Affiliate brokers are supported only when setting a broker account"
    );
    const res = await this.apiClient.encodeCfParameters({
      body: { ...requestParams, brokerAccount }
    });
    if (res.status !== 200) {
      throw new Error("Failed to encode cf parameters", { cause: res });
    }
    return res.body;
  }
  /** @deprecated DEPRECATED(1.11) removing this method as it appears to not be used */
  // eslint-disable-next-line class-methods-use-this
  getOnChainSwapExtrinsicArgs({
    quote,
    fillOrKillParams: fillOrKillParams2
  }) {
    assert(quote.isOnChain, "Cannot get extrinsic args for non-on-chain quotes");
    const { retryDurationBlocks, minPriceX128 } = parseFoKParams(fillOrKillParams2, quote);
    return [
      quote.depositAmount,
      chainflip.getInternalAsset(quote.srcAsset),
      chainflip.getInternalAsset(quote.destAsset),
      retryDurationBlocks,
      minPriceX128,
      quote.type === "DCA" ? {
        number_of_chunks: quote.dcaParams.numberOfChunks,
        chunk_interval: quote.dcaParams.chunkIntervalBlocks
      } : null
    ];
  }
  async checkBoostEnabled() {
    const { assets } = await this.cache.read("networkInfo");
    return assets.find((a) => a.asset === "Btc")?.boostDepositsEnabled ?? true;
  }
};
var arrayToMap = (array) => Object.fromEntries(array.map((item) => [item, item]));
var ChainflipNetworks = arrayToMap(chainflip.chainflipNetworks);
var InternalAssets = arrayToMap(chainflip.chainflipAssets.filter((asset2) => asset2 !== "Dot"));
var Chains = arrayToMap(chainflip.chainflipChains.filter((chain2) => chain2 !== "Polkadot"));
var Assets = arrayToMap(chainflip.assetSymbols);

Object.defineProperty(exports, "getChainflipId", {
  enumerable: true,
  get: function () { return chainflip.getInternalAsset; }
});
exports.Assets = Assets;
exports.ChainflipIds = InternalAssets;
exports.ChainflipNetworks = ChainflipNetworks;
exports.Chains = Chains;
exports.SwapSDK = SwapSDK;
