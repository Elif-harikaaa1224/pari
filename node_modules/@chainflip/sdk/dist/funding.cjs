'use strict';

var ethers = require('ethers');
var rpc = require('@chainflip/rpc');

// ../shared/src/abis/factories/ERC20__factory.ts
var _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ERC20__factory = class {
  static abi = _abi;
  static createInterface() {
    return new ethers.Interface(_abi);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi, runner);
  }
};
var _abi2 = [
  {
    inputs: [
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "minFunding",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "communityGuardDisabled",
        type: "bool"
      }
    ],
    name: "CommunityGuardDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "flip",
        type: "address"
      }
    ],
    name: "FLIPSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldSupply",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newSupply",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stateChainBlockNumber",
        type: "uint256"
      }
    ],
    name: "FlipSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "funder",
        type: "address"
      }
    ],
    name: "Funded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "GovernanceWithdrawal",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMinFunding",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMinFunding",
        type: "uint256"
      }
    ],
    name: "MinFundingChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RedemptionExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RedemptionExpired",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "redeemAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint48",
        name: "startTime",
        type: "uint48"
      },
      {
        indexed: false,
        internalType: "uint48",
        name: "expiryTime",
        type: "uint48"
      }
    ],
    name: "RedemptionRegistered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "suspended",
        type: "bool"
      }
    ],
    name: "Suspended",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "keyManager",
        type: "address"
      }
    ],
    name: "UpdatedKeyManager",
    type: "event"
  },
  {
    inputs: [],
    name: "REDEMPTION_DELAY",
    outputs: [
      {
        internalType: "uint48",
        name: "",
        type: "uint48"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "disableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      }
    ],
    name: "executeRedemption",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "fundStateChainAccount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityGuardDisabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityKey",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getFLIP",
    outputs: [
      {
        internalType: "contract IFLIP",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getGovernor",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getKeyManager",
    outputs: [
      {
        internalType: "contract IKeyManager",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastSupplyUpdateBlockNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMinimumFunding",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      }
    ],
    name: "getPendingRedemption",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "redeemAddress",
            type: "address"
          },
          {
            internalType: "uint48",
            name: "startTime",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "expiryTime",
            type: "uint48"
          }
        ],
        internalType: "struct IStateChainGateway.Redemption",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSuspendedState",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "govUpdateFlipIssuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "govWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "redeemAddress",
        type: "address"
      },
      {
        internalType: "uint48",
        name: "expiryTime",
        type: "uint48"
      }
    ],
    name: "registerRedemption",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "resume",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IFLIP",
        name: "flip",
        type: "address"
      }
    ],
    name: "setFlip",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newMinFunding",
        type: "uint256"
      }
    ],
    name: "setMinFunding",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "suspend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "newIssuer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "omitChecks",
        type: "bool"
      }
    ],
    name: "updateFlipIssuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "newTotalSupply",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "stateChainBlockNumber",
        type: "uint256"
      }
    ],
    name: "updateFlipSupply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      },
      {
        internalType: "bool",
        name: "omitChecks",
        type: "bool"
      }
    ],
    name: "updateKeyManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var StateChainGateway__factory = class {
  static abi = _abi2;
  static createInterface() {
    return new ethers.Interface(_abi2);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi2, runner);
  }
};

// ../shared/src/guards.ts
function assert(condition, message, Constructor = Error) {
  if (condition) return;
  const error = new Constructor(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}

// ../shared/src/consts.ts
var SEPOLIA_USDC_CONTRACT_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
var SEPOLIA_USDT_CONTRACT_ADDRESS = "0x27CEA6Eb8a21Aae05Eb29C91c5CA10592892F584";
var ADDRESSES = {
  backspin: {
    FLIP_CONTRACT_ADDRESS: "0x10C6E9530F1C1AF873a391030a1D9E8ed0630D26",
    USDC_CONTRACT_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    USDT_CONTRACT_ADDRESS: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    ARBUSDC_CONTRACT_ADDRESS: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xeEBe00Ac0756308ac4AaBfD76c05c4F3088B8883",
    SOLUSDC_CONTRACT_ADDRESS: "24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p"
  },
  sisyphos: {
    FLIP_CONTRACT_ADDRESS: "0xcD079EAB6B5443b545788Fd210C8800FEADd87fa",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x1F7fE41C798cc7b1D34BdC8de2dDDA4a4bE744D9",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  perseverance: {
    FLIP_CONTRACT_ADDRESS: "0xdC27c60956cB065D19F08bb69a707E37b36d8086",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xA34a967197Ee90BB7fb28e928388a573c5CFd099",
    SOLUSDC_CONTRACT_ADDRESS: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
  },
  mainnet: {
    FLIP_CONTRACT_ADDRESS: "0x826180541412D574cf1336d22c0C0a287822678A",
    USDC_CONTRACT_ADDRESS: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    USDT_CONTRACT_ADDRESS: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    ARBUSDC_CONTRACT_ADDRESS: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x6995Ab7c4D7F4B03f467Cf4c8E920427d9621DBd",
    SOLUSDC_CONTRACT_ADDRESS: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  }
};

// ../shared/src/contracts.ts
var extractOverrides = (transactionOverrides) => {
  const { wait, ...ethersOverrides } = transactionOverrides;
  return ethersOverrides;
};
var getFlipContractAddress = (network) => ADDRESSES[network].FLIP_CONTRACT_ADDRESS;
var getStateChainGatewayContractAddress = (network) => ADDRESSES[network].STATE_CHAIN_GATEWAY_ADDRESS;
var checkAllowance = async (amount, spenderAddress, erc20Address, signer) => {
  const erc20 = ERC20__factory.connect(erc20Address, signer);
  const signerAddress = await signer.getAddress();
  const allowance = await erc20.allowance(signerAddress, spenderAddress);
  return { allowance, hasSufficientAllowance: allowance >= amount, erc20 };
};
var approve = async (amount, spenderAddress, erc20, allowance, txOpts) => {
  if (allowance >= amount) return null;
  const transaction = await erc20.approve(
    spenderAddress,
    amount - allowance,
    extractOverrides(txOpts)
  );
  await transaction.wait(txOpts.wait);
  return transaction;
};
var getFlipBalance = async (network, signer) => {
  const flipAddress = getFlipContractAddress(network);
  const flip = ERC20__factory.connect(flipAddress, signer);
  return flip.balanceOf(await signer.getAddress());
};
var camelCase = (str) => str.replace(/_([a-z])/g, (_, char) => char.toUpperCase());
var camelCaseKeys = (obj) => {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map((item) => camelCaseKeys(item));
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [camelCase(key), camelCaseKeys(value)])
  );
};
var createRequest = (method) => async (urlOrNetwork, ...params) => {
  const url = "network" in urlOrNetwork ? rpc.constants.PUBLIC_RPC_ENDPOINTS[urlOrNetwork.network] : urlOrNetwork.rpcUrl;
  const result = await new rpc.HttpClient(url).sendRequest(method, ...params);
  return camelCaseKeys(result);
};
var getFundingEnvironment = createRequest("cf_funding_environment");

// ../shared/src/stateChainGateway/utils.ts
var getStateChainGateway = (networkOpts) => {
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return StateChainGateway__factory.connect(stateChainGatewayContractAddress, networkOpts.signer);
};

// ../shared/src/stateChainGateway/approval.ts
var checkStateChainGatewayAllowance = async (amount, networkOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getFlipContractAddress(networkOpts.network);
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return checkAllowance(
    amount,
    stateChainGatewayContractAddress,
    flipContractAddress,
    networkOpts.signer
  );
};
var approveStateChainGateway = async (amount, networkOpts, txOpts) => {
  const { allowance, erc20, hasSufficientAllowance } = await checkStateChainGatewayAllowance(
    amount,
    networkOpts
  );
  if (hasSufficientAllowance) return null;
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return approve(amount, stateChainGatewayContractAddress, erc20, allowance, txOpts);
};

// ../shared/src/stateChainGateway/index.ts
var fundStateChainAccount = async (accountId, amount, networkOpts, txOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getFlipContractAddress(networkOpts.network);
  const stateChainGateway = getStateChainGateway(networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(
    amount,
    await stateChainGateway.getAddress(),
    flipContractAddress,
    networkOpts.signer
  );
  assert(hasSufficientAllowance, "Insufficient allowance");
  const transaction = await stateChainGateway.fundStateChainAccount(
    accountId,
    amount,
    extractOverrides(txOpts)
  );
  await transaction.wait(txOpts.wait);
  return transaction;
};
var executeRedemption = async (accountId, networkOpts, txOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const transaction = await stateChainGateway.executeRedemption(
    accountId,
    extractOverrides(txOpts)
  );
  await transaction.wait(txOpts.wait);
  return transaction;
};
var getMinimumFunding = (networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.getMinimumFunding();
};
var getRedemptionDelay = (networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.REDEMPTION_DELAY();
};
var getPendingRedemption = async (accountId, networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const pendingRedemption = await stateChainGateway.getPendingRedemption(accountId);
  return pendingRedemption.amount !== 0n ? stateChainGateway.getPendingRedemption(accountId) : void 0;
};

// src/funding/sdk.ts
var FundingSDK = class {
  options;
  rpcConfig;
  redemptionTax;
  constructor(options) {
    const network = options.network ?? "perseverance";
    this.options = {
      ...options,
      network
    };
    this.rpcConfig = options.rpcUrl ? { rpcUrl: options.rpcUrl } : { network };
  }
  /**
   * @param accountId the hex-encoded validator account id
   * @param amount the amount to fund in base units of FLIP
   */
  async fundStateChainAccount(accountId, amount, txOpts = {}) {
    const tx = await fundStateChainAccount(accountId, amount, this.options, txOpts);
    return tx.hash;
  }
  /**
   * @param accountId the hex-encoded validator account id
   */
  async executeRedemption(accountId, txOpts = {}) {
    const tx = await executeRedemption(accountId, this.options, txOpts);
    return tx.hash;
  }
  async getMinimumFunding() {
    return getMinimumFunding(this.options);
  }
  async getRedemptionDelay() {
    return getRedemptionDelay(this.options);
  }
  async getFlipBalance() {
    return getFlipBalance(this.options.network, this.options.signer);
  }
  async getPendingRedemption(accountId) {
    return getPendingRedemption(accountId, this.options);
  }
  /**
   * @param the amount of FLIP to request approval for
   * @returns the transaction hash or null if no approval was required
   */
  async approveStateChainGateway(amount, txOpts = {}) {
    const tx = await approveStateChainGateway(amount, this.options, txOpts);
    return tx ? tx.hash : null;
  }
  async getRedemptionTax() {
    this.redemptionTax ??= (await getFundingEnvironment(this.rpcConfig)).redemptionTax;
    return this.redemptionTax;
  }
};

exports.FundingSDK = FundingSDK;
