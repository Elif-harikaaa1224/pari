"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/codecs.ts
var codecs_exports = {};
__export(codecs_exports, {
  createVaultParamsDecoder: () => createVaultParamsDecoder,
  decodeSolanaAdditionalData: () => decodeSolanaAdditionalData,
  solVersionedCcmAdditionalDataCodec: () => solVersionedCcmAdditionalDataCodec,
  vaultCcmCfParametersCodec: () => vaultCcmCfParametersCodec,
  vaultCfParametersCodec: () => vaultCfParametersCodec
});
module.exports = __toCommonJS(codecs_exports);
var base58 = __toESM(require("@chainflip/utils/base58"), 1);
var import_bytes = require("@chainflip/utils/bytes");
var import_consts = require("@chainflip/utils/consts");
var ss58 = __toESM(require("@chainflip/utils/ss58"), 1);
var import_scale_ts = require("scale-ts");
var refundParamsWithCcmRefund = (refundAddressCodec) => (0, import_scale_ts.Struct)({
  retryDurationBlocks: import_scale_ts.u32,
  refundAddress: refundAddressCodec,
  minPriceX128: import_scale_ts.u256,
  refundCcmMetadata: (0, import_scale_ts.Option)(
    (0, import_scale_ts.Struct)({
      channelMetadata: (0, import_scale_ts.Struct)({
        message: (0, import_scale_ts.Bytes)(),
        gasBudget: import_scale_ts.u128,
        additionalData: (0, import_scale_ts.Bytes)()
      })
    })
  ),
  maxOraclePriceSlippage: (0, import_scale_ts.Option)(import_scale_ts.u16)
});
var refundParams = (refundAddressCodec) => (0, import_scale_ts.Struct)({
  retryDurationBlocks: import_scale_ts.u32,
  refundAddress: refundAddressCodec,
  minPriceX128: import_scale_ts.u256
});
var vaultSwapParametersCodec = (refundParamsCodec) => (0, import_scale_ts.Struct)({
  refundParams: refundParamsCodec,
  dcaParams: (0, import_scale_ts.Option)((0, import_scale_ts.Struct)({ numberOfChunks: import_scale_ts.u32, chunkIntervalBlocks: import_scale_ts.u32 })),
  boostFee: import_scale_ts.u8,
  brokerFees: (0, import_scale_ts.Struct)({ account: (0, import_scale_ts.Bytes)(32), commissionBps: import_scale_ts.u16 }),
  affiliateFees: (0, import_scale_ts.Vector)((0, import_scale_ts.Struct)({ account: import_scale_ts.u8, commissionBps: import_scale_ts.u8 }))
});
var vaultCcmCfParametersCodec = (refundAddressCodec) => (0, import_scale_ts.Enum)({
  V0: (0, import_scale_ts.Struct)({
    ccmAdditionalData: (0, import_scale_ts.Bytes)(),
    vaultSwapParameters: vaultSwapParametersCodec(refundParams(refundAddressCodec))
  }),
  V1: (0, import_scale_ts.Struct)({
    ccmAdditionalData: (0, import_scale_ts.Bytes)(),
    vaultSwapParameters: vaultSwapParametersCodec(refundParamsWithCcmRefund(refundAddressCodec))
  })
});
var vaultCfParametersCodec = (refundAddressCodec) => (0, import_scale_ts.Enum)({
  V0: (0, import_scale_ts.Struct)({
    vaultSwapParameters: vaultSwapParametersCodec(refundParams(refundAddressCodec))
  }),
  V1: (0, import_scale_ts.Struct)({
    vaultSwapParameters: vaultSwapParametersCodec(refundParamsWithCcmRefund(refundAddressCodec))
  })
});
var solCcmAccounts = (0, import_scale_ts.Struct)({
  cf_receiver: (0, import_scale_ts.Struct)({
    pubkey: (0, import_scale_ts.Bytes)(32),
    is_writable: import_scale_ts.bool
  }),
  additional_accounts: (0, import_scale_ts.Vector)(
    (0, import_scale_ts.Struct)({
      pubkey: (0, import_scale_ts.Bytes)(32),
      is_writable: import_scale_ts.bool
    })
  ),
  fallback_address: (0, import_scale_ts.Bytes)(32)
});
var solVersionedCcmAdditionalDataCodec = (0, import_scale_ts.Enum)({
  V0: solCcmAccounts,
  V1: (0, import_scale_ts.Struct)({
    ccmAccounts: solCcmAccounts,
    alts: (0, import_scale_ts.Vector)((0, import_scale_ts.Bytes)(32))
  })
});
var decodeSolanaAdditionalData = (data) => {
  try {
    const { value } = solVersionedCcmAdditionalDataCodec.dec(data);
    const accounts = "ccmAccounts" in value ? value.ccmAccounts : value;
    return {
      fallbackAddress: base58.encode(accounts.fallback_address),
      cfReceiver: {
        pubkey: base58.encode(accounts.cf_receiver.pubkey),
        isWritable: accounts.cf_receiver.is_writable
      },
      additionalAccounts: accounts.additional_accounts.map((account) => ({
        pubkey: base58.encode(account.pubkey),
        isWritable: account.is_writable
      }))
    };
  } catch {
    return (0, import_bytes.bytesToHex)(data);
  }
};
function createVaultParamsDecoder(refundAddressCodec, encodeAddress, decodeAdditionalData) {
  const basicCodec = vaultCfParametersCodec(refundAddressCodec);
  const additionalDataCodec = vaultCcmCfParametersCodec(refundAddressCodec);
  const tryVariants = (data) => {
    const errors = [];
    try {
      return {
        ok: true,
        value: { ccmAdditionalData: null, ...basicCodec.dec(data).value }
      };
    } catch (e) {
      errors.push(e);
    }
    try {
      return { ok: true, value: additionalDataCodec.dec(data).value };
    } catch (e) {
      errors.push(e);
    }
    return { ok: false, reason: errors };
  };
  const tryDecodeCfParams = (data) => {
    const result = tryVariants(data);
    if (!result.ok) return result;
    const { ccmAdditionalData, vaultSwapParameters } = result.value;
    return {
      ok: true,
      value: {
        ccmAdditionalData: ccmAdditionalData && (decodeAdditionalData ?? import_bytes.bytesToHex)(ccmAdditionalData),
        refundParams: {
          retryDurationBlocks: vaultSwapParameters.refundParams.retryDurationBlocks,
          refundAddress: encodeAddress(vaultSwapParameters.refundParams.refundAddress),
          minPriceX128: vaultSwapParameters.refundParams.minPriceX128.toString(),
          maxOraclePriceSlippage: "maxOraclePriceSlippage" in vaultSwapParameters.refundParams ? vaultSwapParameters.refundParams.maxOraclePriceSlippage ?? null : null,
          refundCcmMetadata: "refundCcmMetadata" in vaultSwapParameters.refundParams && vaultSwapParameters.refundParams.refundCcmMetadata ? {
            message: (0, import_bytes.bytesToHex)(
              vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.message
            ),
            gasBudget: vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.gasBudget,
            additionalData: (decodeAdditionalData ?? import_bytes.bytesToHex)(
              vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.additionalData
            )
          } : null
        },
        dcaParams: vaultSwapParameters.dcaParams ? {
          numberOfChunks: vaultSwapParameters.dcaParams.numberOfChunks,
          chunkIntervalBlocks: vaultSwapParameters.dcaParams.chunkIntervalBlocks
        } : null,
        boostFee: vaultSwapParameters.boostFee,
        brokerFees: {
          account: ss58.encode({
            data: vaultSwapParameters.brokerFees.account,
            ss58Format: import_consts.CHAINFLIP_SS58_PREFIX
          }),
          commissionBps: vaultSwapParameters.brokerFees.commissionBps
        },
        affiliateFees: vaultSwapParameters.affiliateFees
      }
    };
  };
  return tryDecodeCfParams;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createVaultParamsDecoder,
  decodeSolanaAdditionalData,
  solVersionedCcmAdditionalDataCodec,
  vaultCcmCfParametersCodec,
  vaultCfParametersCodec
});
