// src/codecs.ts
import * as base58 from "@chainflip/utils/base58";
import { bytesToHex } from "@chainflip/utils/bytes";
import { CHAINFLIP_SS58_PREFIX } from "@chainflip/utils/consts";
import * as ss58 from "@chainflip/utils/ss58";
import {
  u32,
  Struct,
  Option,
  u16,
  u256,
  Bytes,
  Enum,
  Vector,
  u8,
  bool,
  u128
} from "scale-ts";
var refundParamsWithCcmRefund = (refundAddressCodec) => Struct({
  retryDurationBlocks: u32,
  refundAddress: refundAddressCodec,
  minPriceX128: u256,
  refundCcmMetadata: Option(
    Struct({
      channelMetadata: Struct({
        message: Bytes(),
        gasBudget: u128,
        additionalData: Bytes()
      })
    })
  ),
  maxOraclePriceSlippage: Option(u16)
});
var refundParams = (refundAddressCodec) => Struct({
  retryDurationBlocks: u32,
  refundAddress: refundAddressCodec,
  minPriceX128: u256
});
var vaultSwapParametersCodec = (refundParamsCodec) => Struct({
  refundParams: refundParamsCodec,
  dcaParams: Option(Struct({ numberOfChunks: u32, chunkIntervalBlocks: u32 })),
  boostFee: u8,
  brokerFees: Struct({ account: Bytes(32), commissionBps: u16 }),
  affiliateFees: Vector(Struct({ account: u8, commissionBps: u8 }))
});
var vaultCcmCfParametersCodec = (refundAddressCodec) => Enum({
  V0: Struct({
    ccmAdditionalData: Bytes(),
    vaultSwapParameters: vaultSwapParametersCodec(refundParams(refundAddressCodec))
  }),
  V1: Struct({
    ccmAdditionalData: Bytes(),
    vaultSwapParameters: vaultSwapParametersCodec(refundParamsWithCcmRefund(refundAddressCodec))
  })
});
var vaultCfParametersCodec = (refundAddressCodec) => Enum({
  V0: Struct({
    vaultSwapParameters: vaultSwapParametersCodec(refundParams(refundAddressCodec))
  }),
  V1: Struct({
    vaultSwapParameters: vaultSwapParametersCodec(refundParamsWithCcmRefund(refundAddressCodec))
  })
});
var solCcmAccounts = Struct({
  cf_receiver: Struct({
    pubkey: Bytes(32),
    is_writable: bool
  }),
  additional_accounts: Vector(
    Struct({
      pubkey: Bytes(32),
      is_writable: bool
    })
  ),
  fallback_address: Bytes(32)
});
var solVersionedCcmAdditionalDataCodec = Enum({
  V0: solCcmAccounts,
  V1: Struct({
    ccmAccounts: solCcmAccounts,
    alts: Vector(Bytes(32))
  })
});
var decodeSolanaAdditionalData = (data) => {
  try {
    const { value } = solVersionedCcmAdditionalDataCodec.dec(data);
    const accounts = "ccmAccounts" in value ? value.ccmAccounts : value;
    return {
      fallbackAddress: base58.encode(accounts.fallback_address),
      cfReceiver: {
        pubkey: base58.encode(accounts.cf_receiver.pubkey),
        isWritable: accounts.cf_receiver.is_writable
      },
      additionalAccounts: accounts.additional_accounts.map((account) => ({
        pubkey: base58.encode(account.pubkey),
        isWritable: account.is_writable
      }))
    };
  } catch {
    return bytesToHex(data);
  }
};
function createVaultParamsDecoder(refundAddressCodec, encodeAddress, decodeAdditionalData) {
  const basicCodec = vaultCfParametersCodec(refundAddressCodec);
  const additionalDataCodec = vaultCcmCfParametersCodec(refundAddressCodec);
  const tryVariants = (data) => {
    const errors = [];
    try {
      return {
        ok: true,
        value: { ccmAdditionalData: null, ...basicCodec.dec(data).value }
      };
    } catch (e) {
      errors.push(e);
    }
    try {
      return { ok: true, value: additionalDataCodec.dec(data).value };
    } catch (e) {
      errors.push(e);
    }
    return { ok: false, reason: errors };
  };
  const tryDecodeCfParams = (data) => {
    const result = tryVariants(data);
    if (!result.ok) return result;
    const { ccmAdditionalData, vaultSwapParameters } = result.value;
    return {
      ok: true,
      value: {
        ccmAdditionalData: ccmAdditionalData && (decodeAdditionalData ?? bytesToHex)(ccmAdditionalData),
        refundParams: {
          retryDurationBlocks: vaultSwapParameters.refundParams.retryDurationBlocks,
          refundAddress: encodeAddress(vaultSwapParameters.refundParams.refundAddress),
          minPriceX128: vaultSwapParameters.refundParams.minPriceX128.toString(),
          maxOraclePriceSlippage: "maxOraclePriceSlippage" in vaultSwapParameters.refundParams ? vaultSwapParameters.refundParams.maxOraclePriceSlippage ?? null : null,
          refundCcmMetadata: "refundCcmMetadata" in vaultSwapParameters.refundParams && vaultSwapParameters.refundParams.refundCcmMetadata ? {
            message: bytesToHex(
              vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.message
            ),
            gasBudget: vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.gasBudget,
            additionalData: (decodeAdditionalData ?? bytesToHex)(
              vaultSwapParameters.refundParams.refundCcmMetadata.channelMetadata.additionalData
            )
          } : null
        },
        dcaParams: vaultSwapParameters.dcaParams ? {
          numberOfChunks: vaultSwapParameters.dcaParams.numberOfChunks,
          chunkIntervalBlocks: vaultSwapParameters.dcaParams.chunkIntervalBlocks
        } : null,
        boostFee: vaultSwapParameters.boostFee,
        brokerFees: {
          account: ss58.encode({
            data: vaultSwapParameters.brokerFees.account,
            ss58Format: CHAINFLIP_SS58_PREFIX
          }),
          commissionBps: vaultSwapParameters.brokerFees.commissionBps
        },
        affiliateFees: vaultSwapParameters.affiliateFees
      }
    };
  };
  return tryDecodeCfParams;
}
export {
  createVaultParamsDecoder,
  decodeSolanaAdditionalData,
  solVersionedCcmAdditionalDataCodec,
  vaultCcmCfParametersCodec,
  vaultCfParametersCodec
};
