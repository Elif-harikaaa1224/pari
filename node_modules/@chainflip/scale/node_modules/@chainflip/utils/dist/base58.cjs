"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/base58.ts
var base58_exports = {};
__export(base58_exports, {
  CHARSET: () => CHARSET,
  decode: () => decode,
  encode: () => encode
});
module.exports = __toCommonJS(base58_exports);

// src/guard.ts
var createIsGuard = (type) => (value) => typeof value === type;
var isString = createIsGuard("string");
var isNumber = createIsGuard("number");
var isBigInt = createIsGuard("bigint");
var isBoolean = createIsGuard("boolean");
var isSymbol = createIsGuard("symbol");
var isObject = createIsGuard("object");
var isUndefined = createIsGuard("undefined");

// src/assertion.ts
function assert(condition, message = "assertion failed", Constructor = Error) {
  if (!condition) {
    throw new Constructor(message);
  }
}

// src/bytes.ts
var hexToBytes = (input) => {
  assert(/^0x[\da-f]*$/i.test(input) && input.length % 2 === 0, "Invalid hex string");
  const hex = input.slice(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
};
var convertBase = (inputBytes, fromBase, toBase) => {
  const bytes = typeof inputBytes === "string" ? hexToBytes(inputBytes) : new Uint8Array(inputBytes);
  const result = [];
  for (const byte of bytes) {
    let carry = byte;
    for (let i = 0; i < result.length; i += 1) {
      carry += result[i] * fromBase;
      result[i] = carry % toBase;
      carry = Math.floor(carry / toBase);
    }
    while (carry !== 0) {
      result.push(carry % toBase);
      carry = Math.floor(carry / toBase);
    }
  }
  let leadingZeros = 0;
  while (bytes[leadingZeros] === 0) {
    leadingZeros += 1;
    result.push(0);
  }
  return result.reverse();
};
var encodeBytesWithCharset = (bytes, charset) => convertBase(bytes, 256, charset.length).map((charCode) => charset.charAt(charCode)).join("");
var decodeBytesWithCharset = (input, charset) => {
  assert(new RegExp(`^[${charset}]*$`).test(input), "Invalid input");
  const charMap = Object.fromEntries([...charset].map((char, index) => [char, index]));
  const bytes = input.split("").map((char) => charMap[char]);
  return new Uint8Array(convertBase(bytes, charset.length, 256));
};

// src/base58.ts
var CHARSET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var encode = (bytes) => encodeBytesWithCharset(bytes, CHARSET);
var decode = (input) => decodeBytesWithCharset(input, CHARSET);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CHARSET,
  decode,
  encode
});
